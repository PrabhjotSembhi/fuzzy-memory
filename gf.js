(() => {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __pow = Math.pow;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
    var __commonJS = (cb, mod) => function __require() {
      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module2, desc) => {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))
          if (!__hasOwnProp.call(target, key) && key !== "default")
            __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module2) => {
      return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
    };
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
  
    // node_modules/svg4everybody/dist/svg4everybody.js
    var require_svg4everybody = __commonJS({
      "node_modules/svg4everybody/dist/svg4everybody.js"(exports2, module2) {
        !function(root, factory) {
          typeof define == "function" && define.amd ? define([], function() {
            return root.svg4everybody = factory();
          }) : typeof module2 == "object" && module2.exports ? module2.exports = factory() : root.svg4everybody = factory();
        }(exports2, function() {
          function embed(parent2, svg, target) {
            if (target) {
              var fragment2 = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
              viewBox && svg.setAttribute("viewBox", viewBox);
              for (var clone = target.cloneNode(true); clone.childNodes.length; ) {
                fragment2.appendChild(clone.firstChild);
              }
              parent2.appendChild(fragment2);
            }
          }
          function loadreadystatechange(xhr) {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                var cachedDocument = xhr._cachedDocument;
                cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), xhr._embeds.splice(0).map(function(item) {
                  var target = xhr._cachedTarget[item.id];
                  target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), embed(item.parent, item.svg, target);
                });
              }
            }, xhr.onreadystatechange();
          }
          function svg4everybody2(rawopts) {
            function oninterval() {
              for (var index2 = 0; index2 < uses.length; ) {
                var use = uses[index2], parent2 = use.parentNode, svg = getSVGAncestor(parent2), src2 = use.getAttribute("xlink:href") || use.getAttribute("href");
                if (!src2 && opts.attributeName && (src2 = use.getAttribute(opts.attributeName)), svg && src2) {
                  if (polyfill) {
                    if (!opts.validate || opts.validate(src2, svg, use)) {
                      parent2.removeChild(use);
                      var srcSplit = src2.split("#"), url = srcSplit.shift(), id2 = srcSplit.join("#");
                      if (url.length) {
                        var xhr = requests[url];
                        xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []), xhr._embeds.push({
                          parent: parent2,
                          svg,
                          id: id2
                        }), loadreadystatechange(xhr);
                      } else {
                        embed(parent2, svg, document.getElementById(id2));
                      }
                    } else {
                      ++index2, ++numberOfSvgUseElementsToBypass;
                    }
                  }
                } else {
                  ++index2;
                }
              }
              (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame2(oninterval, 67);
            }
            var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
            polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
            var requests = {}, requestAnimationFrame2 = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
            polyfill && oninterval();
          }
          function getSVGAncestor(node) {
            for (var svg = node; svg.nodeName.toLowerCase() !== "svg" && (svg = svg.parentNode); ) {
            }
            return svg;
          }
          return svg4everybody2;
        });
      }
    });
  
    // node_modules/bezier-easing/src/index.js
    var require_src = __commonJS({
      "node_modules/bezier-easing/src/index.js"(exports2, module2) {
        var NEWTON_ITERATIONS2 = 4;
        var NEWTON_MIN_SLOPE2 = 1e-3;
        var SUBDIVISION_PRECISION2 = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS2 = 10;
        var kSplineTableSize2 = 11;
        var kSampleStepSize2 = 1 / (kSplineTableSize2 - 1);
        var float32ArraySupported2 = typeof Float32Array === "function";
        function A2(aA1, aA2) {
          return 1 - 3 * aA2 + 3 * aA1;
        }
        function B2(aA1, aA2) {
          return 3 * aA2 - 6 * aA1;
        }
        function C2(aA1) {
          return 3 * aA1;
        }
        function calcBezier2(aT, aA1, aA2) {
          return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
        }
        function getSlope2(aT, aA1, aA2) {
          return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
        }
        function binarySubdivide2(aX, aA, aB, mX1, mX2) {
          var currentX, currentT, i2 = 0;
          do {
            currentT = aA + (aB - aA) / 2;
            currentX = calcBezier2(currentT, mX1, mX2) - aX;
            if (currentX > 0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION2 && ++i2 < SUBDIVISION_MAX_ITERATIONS2);
          return currentT;
        }
        function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
          for (var i2 = 0; i2 < NEWTON_ITERATIONS2; ++i2) {
            var currentSlope = getSlope2(aGuessT, mX1, mX2);
            if (currentSlope === 0) {
              return aGuessT;
            }
            var currentX = calcBezier2(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
        }
        function LinearEasing2(x) {
          return x;
        }
        module2.exports = function bezier4(mX1, mY1, mX2, mY2) {
          if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
            throw new Error("bezier x values must be in [0, 1] range");
          }
          if (mX1 === mY1 && mX2 === mY2) {
            return LinearEasing2;
          }
          var sampleValues = float32ArraySupported2 ? new Float32Array(kSplineTableSize2) : new Array(kSplineTableSize2);
          for (var i2 = 0; i2 < kSplineTableSize2; ++i2) {
            sampleValues[i2] = calcBezier2(i2 * kSampleStepSize2, mX1, mX2);
          }
          function getTForX(aX) {
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize2 - 1;
            for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize2;
            }
            --currentSample;
            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize2;
            var initialSlope = getSlope2(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE2) {
              return newtonRaphsonIterate2(aX, guessForT, mX1, mX2);
            } else if (initialSlope === 0) {
              return guessForT;
            } else {
              return binarySubdivide2(aX, intervalStart, intervalStart + kSampleStepSize2, mX1, mX2);
            }
          }
          return function BezierEasing(x) {
            if (x === 0) {
              return 0;
            }
            if (x === 1) {
              return 1;
            }
            return calcBezier2(getTForX(x), mY1, mY2);
          };
        };
      }
    });
  
    // node_modules/lottie-web/build/player/lottie_light.js
    var require_lottie_light = __commonJS({
      "node_modules/lottie-web/build/player/lottie_light.js"(exports2, module2) {
        typeof navigator !== "undefined" && function(root, factory) {
          if (typeof define === "function" && define.amd) {
            define(function() {
              return factory(root);
            });
          } else if (typeof module2 === "object" && module2.exports) {
            module2.exports = factory(root);
          } else {
            root.lottie = factory(root);
            root.bodymovin = root.lottie;
          }
        }(window || {}, function(window2) {
          "use strict";
          var svgNS = "http://www.w3.org/2000/svg";
          var locationHref = "";
          var initialDefaultFrame = -999999;
          var _useWebWorker = false;
          var subframeEnabled = true;
          var idPrefix = "";
          var expressionsPlugin;
          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          var cachedColors = {};
          var bmRnd;
          var bmPow = Math.pow;
          var bmSqrt = Math.sqrt;
          var bmFloor = Math.floor;
          var bmMax = Math.max;
          var bmMin = Math.min;
          var BMMath = {};
          (function() {
            var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
            var i2;
            var len = propertyNames.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              BMMath[propertyNames[i2]] = Math[propertyNames[i2]];
            }
          })();
          function ProjectInterface() {
            return {};
          }
          BMMath.random = Math.random;
          BMMath.abs = function(val) {
            var tOfVal = typeof val;
            if (tOfVal === "object" && val.length) {
              var absArr = createSizedArray(val.length);
              var i2;
              var len = val.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                absArr[i2] = Math.abs(val[i2]);
              }
              return absArr;
            }
            return Math.abs(val);
          };
          var defaultCurveSegments = 150;
          var degToRads = Math.PI / 180;
          var roundCorner = 0.5519;
          function roundValues(flag) {
            if (flag) {
              bmRnd = Math.round;
            } else {
              bmRnd = function(val) {
                return val;
              };
            }
          }
          roundValues(false);
          function styleDiv(element) {
            element.style.position = "absolute";
            element.style.top = 0;
            element.style.left = 0;
            element.style.display = "block";
            element.style.transformOrigin = "0 0";
            element.style.webkitTransformOrigin = "0 0";
            element.style.backfaceVisibility = "visible";
            element.style.webkitBackfaceVisibility = "visible";
            element.style.transformStyle = "preserve-3d";
            element.style.webkitTransformStyle = "preserve-3d";
            element.style.mozTransformStyle = "preserve-3d";
          }
          function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
            this.type = type;
            this.currentTime = currentTime;
            this.totalTime = totalTime;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }
          function BMCompleteEvent(type, frameMultiplier) {
            this.type = type;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }
          function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
            this.type = type;
            this.currentLoop = currentLoop;
            this.totalLoops = totalLoops;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }
          function BMSegmentStartEvent(type, firstFrame, totalFrames) {
            this.type = type;
            this.firstFrame = firstFrame;
            this.totalFrames = totalFrames;
          }
          function BMDestroyEvent(type, target) {
            this.type = type;
            this.target = target;
          }
          function BMRenderFrameErrorEvent(nativeError, currentTime) {
            this.type = "renderFrameError";
            this.nativeError = nativeError;
            this.currentTime = currentTime;
          }
          function BMConfigErrorEvent(nativeError) {
            this.type = "configError";
            this.nativeError = nativeError;
          }
          function BMAnimationConfigErrorEvent(type, nativeError) {
            this.type = type;
            this.nativeError = nativeError;
          }
          var createElementID = function() {
            var _count = 0;
            return function createID() {
              _count += 1;
              return idPrefix + "__lottie_element_" + _count;
            };
          }();
          function HSVtoRGB(h, s, v) {
            var r;
            var g;
            var b;
            var i2;
            var f;
            var p;
            var q;
            var t;
            i2 = Math.floor(h * 6);
            f = h * 6 - i2;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i2 % 6) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;
              case 1:
                r = q;
                g = v;
                b = p;
                break;
              case 2:
                r = p;
                g = v;
                b = t;
                break;
              case 3:
                r = p;
                g = q;
                b = v;
                break;
              case 4:
                r = t;
                g = p;
                b = v;
                break;
              case 5:
                r = v;
                g = p;
                b = q;
                break;
              default:
                break;
            }
            return [
              r,
              g,
              b
            ];
          }
          function RGBtoHSV(r, g, b) {
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var d = max - min;
            var h;
            var s = max === 0 ? 0 : d / max;
            var v = max / 255;
            switch (max) {
              case min:
                h = 0;
                break;
              case r:
                h = g - b + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
              case g:
                h = b - r + d * 2;
                h /= 6 * d;
                break;
              case b:
                h = r - g + d * 4;
                h /= 6 * d;
                break;
              default:
                break;
            }
            return [
              h,
              s,
              v
            ];
          }
          function addSaturationToRGB(color, offset2) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[1] += offset2;
            if (hsv[1] > 1) {
              hsv[1] = 1;
            } else if (hsv[1] <= 0) {
              hsv[1] = 0;
            }
            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }
          function addBrightnessToRGB(color, offset2) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[2] += offset2;
            if (hsv[2] > 1) {
              hsv[2] = 1;
            } else if (hsv[2] < 0) {
              hsv[2] = 0;
            }
            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }
          function addHueToRGB(color, offset2) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[0] += offset2 / 360;
            if (hsv[0] > 1) {
              hsv[0] -= 1;
            } else if (hsv[0] < 0) {
              hsv[0] += 1;
            }
            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }
          var rgbToHex = function() {
            var colorMap = [];
            var i2;
            var hex;
            for (i2 = 0; i2 < 256; i2 += 1) {
              hex = i2.toString(16);
              colorMap[i2] = hex.length === 1 ? "0" + hex : hex;
            }
            return function(r, g, b) {
              if (r < 0) {
                r = 0;
              }
              if (g < 0) {
                g = 0;
              }
              if (b < 0) {
                b = 0;
              }
              return "#" + colorMap[r] + colorMap[g] + colorMap[b];
            };
          }();
          function BaseEvent() {
          }
          BaseEvent.prototype = {
            triggerEvent: function(eventName, args) {
              if (this._cbs[eventName]) {
                var callbacks = this._cbs[eventName];
                for (var i2 = 0; i2 < callbacks.length; i2 += 1) {
                  callbacks[i2](args);
                }
              }
            },
            addEventListener: function(eventName, callback) {
              if (!this._cbs[eventName]) {
                this._cbs[eventName] = [];
              }
              this._cbs[eventName].push(callback);
              return function() {
                this.removeEventListener(eventName, callback);
              }.bind(this);
            },
            removeEventListener: function(eventName, callback) {
              if (!callback) {
                this._cbs[eventName] = null;
              } else if (this._cbs[eventName]) {
                var i2 = 0;
                var len = this._cbs[eventName].length;
                while (i2 < len) {
                  if (this._cbs[eventName][i2] === callback) {
                    this._cbs[eventName].splice(i2, 1);
                    i2 -= 1;
                    len -= 1;
                  }
                  i2 += 1;
                }
                if (!this._cbs[eventName].length) {
                  this._cbs[eventName] = null;
                }
              }
            }
          };
          var createTypedArray = function() {
            function createRegularArray(type, len) {
              var i2 = 0;
              var arr = [];
              var value;
              switch (type) {
                case "int16":
                case "uint8c":
                  value = 1;
                  break;
                default:
                  value = 1.1;
                  break;
              }
              for (i2 = 0; i2 < len; i2 += 1) {
                arr.push(value);
              }
              return arr;
            }
            function createTypedArrayFactory(type, len) {
              if (type === "float32") {
                return new Float32Array(len);
              }
              if (type === "int16") {
                return new Int16Array(len);
              }
              if (type === "uint8c") {
                return new Uint8ClampedArray(len);
              }
              return createRegularArray(type, len);
            }
            if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
              return createTypedArrayFactory;
            }
            return createRegularArray;
          }();
          function createSizedArray(len) {
            return Array.apply(null, { length: len });
          }
          function createNS(type) {
            return document.createElementNS(svgNS, type);
          }
          function createTag(type) {
            return document.createElement(type);
          }
          function DynamicPropertyContainer() {
          }
          DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(prop) {
              if (this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
                this.container.addDynamicProperty(this);
                this._isAnimated = true;
              }
            },
            iterateDynamicProperties: function() {
              this._mdf = false;
              var i2;
              var len = this.dynamicProperties.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.dynamicProperties[i2].getValue();
                if (this.dynamicProperties[i2]._mdf) {
                  this._mdf = true;
                }
              }
            },
            initDynamicPropertyContainer: function(container) {
              this.container = container;
              this.dynamicProperties = [];
              this._mdf = false;
              this._isAnimated = false;
            }
          };
          var getBlendMode = function() {
            var blendModeEnums = {
              0: "source-over",
              1: "multiply",
              2: "screen",
              3: "overlay",
              4: "darken",
              5: "lighten",
              6: "color-dodge",
              7: "color-burn",
              8: "hard-light",
              9: "soft-light",
              10: "difference",
              11: "exclusion",
              12: "hue",
              13: "saturation",
              14: "color",
              15: "luminosity"
            };
            return function(mode) {
              return blendModeEnums[mode] || "";
            };
          }();
          var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
          };
          var lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
          };
          var Matrix = function() {
            var _cos2 = Math.cos;
            var _sin2 = Math.sin;
            var _tan = Math.tan;
            var _rnd = Math.round;
            function reset() {
              this.props[0] = 1;
              this.props[1] = 0;
              this.props[2] = 0;
              this.props[3] = 0;
              this.props[4] = 0;
              this.props[5] = 1;
              this.props[6] = 0;
              this.props[7] = 0;
              this.props[8] = 0;
              this.props[9] = 0;
              this.props[10] = 1;
              this.props[11] = 0;
              this.props[12] = 0;
              this.props[13] = 0;
              this.props[14] = 0;
              this.props[15] = 1;
              return this;
            }
            function rotate(angle) {
              if (angle === 0) {
                return this;
              }
              var mCos = _cos2(angle);
              var mSin = _sin2(angle);
              return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            function rotateX(angle) {
              if (angle === 0) {
                return this;
              }
              var mCos = _cos2(angle);
              var mSin = _sin2(angle);
              return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
            }
            function rotateY(angle) {
              if (angle === 0) {
                return this;
              }
              var mCos = _cos2(angle);
              var mSin = _sin2(angle);
              return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
            }
            function rotateZ(angle) {
              if (angle === 0) {
                return this;
              }
              var mCos = _cos2(angle);
              var mSin = _sin2(angle);
              return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            function shear(sx, sy) {
              return this._t(1, sy, sx, 1, 0, 0);
            }
            function skew(ax, ay) {
              return this.shear(_tan(ax), _tan(ay));
            }
            function skewFromAxis(ax, angle) {
              var mCos = _cos2(angle);
              var mSin = _sin2(angle);
              return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            function scale(sx, sy, sz) {
              if (!sz && sz !== 0) {
                sz = 1;
              }
              if (sx === 1 && sy === 1 && sz === 1) {
                return this;
              }
              return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
            }
            function setTransform(a, b, c, d, e, f, g, h, i2, j, k, l, m, n, o, p) {
              this.props[0] = a;
              this.props[1] = b;
              this.props[2] = c;
              this.props[3] = d;
              this.props[4] = e;
              this.props[5] = f;
              this.props[6] = g;
              this.props[7] = h;
              this.props[8] = i2;
              this.props[9] = j;
              this.props[10] = k;
              this.props[11] = l;
              this.props[12] = m;
              this.props[13] = n;
              this.props[14] = o;
              this.props[15] = p;
              return this;
            }
            function translate2(tx, ty, tz) {
              tz = tz || 0;
              if (tx !== 0 || ty !== 0 || tz !== 0) {
                return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
              }
              return this;
            }
            function transform3(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
              var _p = this.props;
              if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
                _p[12] = _p[12] * a2 + _p[15] * m2;
                _p[13] = _p[13] * f2 + _p[15] * n2;
                _p[14] = _p[14] * k2 + _p[15] * o2;
                _p[15] *= p2;
                this._identityCalculated = false;
                return this;
              }
              var a1 = _p[0];
              var b1 = _p[1];
              var c1 = _p[2];
              var d1 = _p[3];
              var e1 = _p[4];
              var f1 = _p[5];
              var g1 = _p[6];
              var h1 = _p[7];
              var i1 = _p[8];
              var j1 = _p[9];
              var k1 = _p[10];
              var l1 = _p[11];
              var m1 = _p[12];
              var n1 = _p[13];
              var o1 = _p[14];
              var p1 = _p[15];
              _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
              _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
              _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
              _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
              _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
              _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
              _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
              _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
              _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
              _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
              _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
              _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
              _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
              _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
              _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
              _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
              this._identityCalculated = false;
              return this;
            }
            function isIdentity() {
              if (!this._identityCalculated) {
                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
                this._identityCalculated = true;
              }
              return this._identity;
            }
            function equals2(matr) {
              var i2 = 0;
              while (i2 < 16) {
                if (matr.props[i2] !== this.props[i2]) {
                  return false;
                }
                i2 += 1;
              }
              return true;
            }
            function clone(matr) {
              var i2;
              for (i2 = 0; i2 < 16; i2 += 1) {
                matr.props[i2] = this.props[i2];
              }
              return matr;
            }
            function cloneFromProps(props) {
              var i2;
              for (i2 = 0; i2 < 16; i2 += 1) {
                this.props[i2] = props[i2];
              }
            }
            function applyToPoint(x, y, z) {
              return {
                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
              };
            }
            function applyToX(x, y, z) {
              return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
            }
            function applyToY(x, y, z) {
              return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
            }
            function applyToZ(x, y, z) {
              return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
            }
            function getInverseMatrix() {
              var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
              var a = this.props[5] / determinant;
              var b = -this.props[1] / determinant;
              var c = -this.props[4] / determinant;
              var d = this.props[0] / determinant;
              var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
              var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
              var inverseMatrix = new Matrix();
              inverseMatrix.props[0] = a;
              inverseMatrix.props[1] = b;
              inverseMatrix.props[4] = c;
              inverseMatrix.props[5] = d;
              inverseMatrix.props[12] = e;
              inverseMatrix.props[13] = f;
              return inverseMatrix;
            }
            function inversePoint(pt) {
              var inverseMatrix = this.getInverseMatrix();
              return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
            }
            function inversePoints(pts) {
              var i2;
              var len = pts.length;
              var retPts = [];
              for (i2 = 0; i2 < len; i2 += 1) {
                retPts[i2] = inversePoint(pts[i2]);
              }
              return retPts;
            }
            function applyToTriplePoints(pt1, pt2, pt3) {
              var arr = createTypedArray("float32", 6);
              if (this.isIdentity()) {
                arr[0] = pt1[0];
                arr[1] = pt1[1];
                arr[2] = pt2[0];
                arr[3] = pt2[1];
                arr[4] = pt3[0];
                arr[5] = pt3[1];
              } else {
                var p0 = this.props[0];
                var p1 = this.props[1];
                var p4 = this.props[4];
                var p5 = this.props[5];
                var p12 = this.props[12];
                var p13 = this.props[13];
                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
              }
              return arr;
            }
            function applyToPointArray(x, y, z) {
              var arr;
              if (this.isIdentity()) {
                arr = [x, y, z];
              } else {
                arr = [
                  x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                  x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                  x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
                ];
              }
              return arr;
            }
            function applyToPointStringified(x, y) {
              if (this.isIdentity()) {
                return x + "," + y;
              }
              var _p = this.props;
              return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
            }
            function toCSS() {
              var i2 = 0;
              var props = this.props;
              var cssValue = "matrix3d(";
              var v = 1e4;
              while (i2 < 16) {
                cssValue += _rnd(props[i2] * v) / v;
                cssValue += i2 === 15 ? ")" : ",";
                i2 += 1;
              }
              return cssValue;
            }
            function roundMatrixProperty(val) {
              var v = 1e4;
              if (val < 1e-6 && val > 0 || val > -1e-6 && val < 0) {
                return _rnd(val * v) / v;
              }
              return val;
            }
            function to2dCSS() {
              var props = this.props;
              var _a = roundMatrixProperty(props[0]);
              var _b = roundMatrixProperty(props[1]);
              var _c = roundMatrixProperty(props[4]);
              var _d = roundMatrixProperty(props[5]);
              var _e = roundMatrixProperty(props[12]);
              var _f = roundMatrixProperty(props[13]);
              return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
            }
            return function() {
              this.reset = reset;
              this.rotate = rotate;
              this.rotateX = rotateX;
              this.rotateY = rotateY;
              this.rotateZ = rotateZ;
              this.skew = skew;
              this.skewFromAxis = skewFromAxis;
              this.shear = shear;
              this.scale = scale;
              this.setTransform = setTransform;
              this.translate = translate2;
              this.transform = transform3;
              this.applyToPoint = applyToPoint;
              this.applyToX = applyToX;
              this.applyToY = applyToY;
              this.applyToZ = applyToZ;
              this.applyToPointArray = applyToPointArray;
              this.applyToTriplePoints = applyToTriplePoints;
              this.applyToPointStringified = applyToPointStringified;
              this.toCSS = toCSS;
              this.to2dCSS = to2dCSS;
              this.clone = clone;
              this.cloneFromProps = cloneFromProps;
              this.equals = equals2;
              this.inversePoints = inversePoints;
              this.inversePoint = inversePoint;
              this.getInverseMatrix = getInverseMatrix;
              this._t = this.transform;
              this.isIdentity = isIdentity;
              this._identity = true;
              this._identityCalculated = false;
              this.props = createTypedArray("float32", 16);
              this.reset();
            };
          }();
          (function(pool, math) {
            var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
            function seedrandom(seed, options, callback) {
              var key = [];
              options = options === true ? { entropy: true } : options || {};
              var shortseed = mixkey(flatten2(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key);
              var arc4 = new ARC4(key);
              var prng = function() {
                var n = arc4.g(chunks), d = startdenom, x = 0;
                while (n < significance) {
                  n = (n + x) * width;
                  d *= width;
                  x = arc4.g(1);
                }
                while (n >= overflow) {
                  n /= 2;
                  d /= 2;
                  x >>>= 1;
                }
                return (n + x) / d;
              };
              prng.int32 = function() {
                return arc4.g(4) | 0;
              };
              prng.quick = function() {
                return arc4.g(4) / 4294967296;
              };
              prng.double = prng;
              mixkey(tostring(arc4.S), pool);
              return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
                if (state) {
                  if (state.S) {
                    copy(state, arc4);
                  }
                  prng2.state = function() {
                    return copy(arc4, {});
                  };
                }
                if (is_math_call) {
                  math[rngname] = prng2;
                  return seed2;
                } else
                  return prng2;
              })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
            }
            math["seed" + rngname] = seedrandom;
            function ARC4(key) {
              var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
              if (!keylen) {
                key = [keylen++];
              }
              while (i2 < width) {
                s[i2] = i2++;
              }
              for (i2 = 0; i2 < width; i2++) {
                s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
                s[j] = t;
              }
              me.g = function(count) {
                var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
                while (count--) {
                  t2 = s2[i3 = mask & i3 + 1];
                  r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
                }
                me.i = i3;
                me.j = j2;
                return r;
              };
            }
            function copy(f, t) {
              t.i = f.i;
              t.j = f.j;
              t.S = f.S.slice();
              return t;
            }
            function flatten2(obj, depth) {
              var result = [], typ = typeof obj, prop;
              if (depth && typ == "object") {
                for (prop in obj) {
                  try {
                    result.push(flatten2(obj[prop], depth - 1));
                  } catch (e) {
                  }
                }
              }
              return result.length ? result : typ == "string" ? obj : obj + "\0";
            }
            function mixkey(seed, key) {
              var stringseed = seed + "", smear, j = 0;
              while (j < stringseed.length) {
                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
              }
              return tostring(key);
            }
            function autoseed() {
              try {
                if (nodecrypto) {
                  return tostring(nodecrypto.randomBytes(width));
                }
                var out = new Uint8Array(width);
                (global2.crypto || global2.msCrypto).getRandomValues(out);
                return tostring(out);
              } catch (e) {
                var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
                return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
              }
            }
            function tostring(a) {
              return String.fromCharCode.apply(0, a);
            }
            mixkey(math.random(), pool);
          })([], BMMath);
          var BezierFactory = function() {
            var ob = {};
            ob.getBezierEasing = getBezierEasing;
            var beziers = {};
            function getBezierEasing(a, b, c, d, nm) {
              var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
              if (beziers[str]) {
                return beziers[str];
              }
              var bezEasing = new BezierEasing([a, b, c, d]);
              beziers[str] = bezEasing;
              return bezEasing;
            }
            var NEWTON_ITERATIONS2 = 4;
            var NEWTON_MIN_SLOPE2 = 1e-3;
            var SUBDIVISION_PRECISION2 = 1e-7;
            var SUBDIVISION_MAX_ITERATIONS2 = 10;
            var kSplineTableSize2 = 11;
            var kSampleStepSize2 = 1 / (kSplineTableSize2 - 1);
            var float32ArraySupported2 = typeof Float32Array === "function";
            function A2(aA1, aA2) {
              return 1 - 3 * aA2 + 3 * aA1;
            }
            function B2(aA1, aA2) {
              return 3 * aA2 - 6 * aA1;
            }
            function C2(aA1) {
              return 3 * aA1;
            }
            function calcBezier2(aT, aA1, aA2) {
              return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
            }
            function getSlope2(aT, aA1, aA2) {
              return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
            }
            function binarySubdivide2(aX, aA, aB, mX1, mX2) {
              var currentX, currentT, i2 = 0;
              do {
                currentT = aA + (aB - aA) / 2;
                currentX = calcBezier2(currentT, mX1, mX2) - aX;
                if (currentX > 0) {
                  aB = currentT;
                } else {
                  aA = currentT;
                }
              } while (Math.abs(currentX) > SUBDIVISION_PRECISION2 && ++i2 < SUBDIVISION_MAX_ITERATIONS2);
              return currentT;
            }
            function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
              for (var i2 = 0; i2 < NEWTON_ITERATIONS2; ++i2) {
                var currentSlope = getSlope2(aGuessT, mX1, mX2);
                if (currentSlope === 0)
                  return aGuessT;
                var currentX = calcBezier2(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
              }
              return aGuessT;
            }
            function BezierEasing(points) {
              this._p = points;
              this._mSampleValues = float32ArraySupported2 ? new Float32Array(kSplineTableSize2) : new Array(kSplineTableSize2);
              this._precomputed = false;
              this.get = this.get.bind(this);
            }
            BezierEasing.prototype = {
              get: function(x) {
                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                if (!this._precomputed)
                  this._precompute();
                if (mX1 === mY1 && mX2 === mY2)
                  return x;
                if (x === 0)
                  return 0;
                if (x === 1)
                  return 1;
                return calcBezier2(this._getTForX(x), mY1, mY2);
              },
              _precompute: function() {
                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                this._precomputed = true;
                if (mX1 !== mY1 || mX2 !== mY2) {
                  this._calcSampleValues();
                }
              },
              _calcSampleValues: function() {
                var mX1 = this._p[0], mX2 = this._p[2];
                for (var i2 = 0; i2 < kSplineTableSize2; ++i2) {
                  this._mSampleValues[i2] = calcBezier2(i2 * kSampleStepSize2, mX1, mX2);
                }
              },
              _getTForX: function(aX) {
                var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
                var intervalStart = 0;
                var currentSample = 1;
                var lastSample = kSplineTableSize2 - 1;
                for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                  intervalStart += kSampleStepSize2;
                }
                --currentSample;
                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
                var guessForT = intervalStart + dist * kSampleStepSize2;
                var initialSlope = getSlope2(guessForT, mX1, mX2);
                if (initialSlope >= NEWTON_MIN_SLOPE2) {
                  return newtonRaphsonIterate2(aX, guessForT, mX1, mX2);
                }
                if (initialSlope === 0) {
                  return guessForT;
                }
                return binarySubdivide2(aX, intervalStart, intervalStart + kSampleStepSize2, mX1, mX2);
              }
            };
            return ob;
          }();
          (function() {
            var lastTime = 0;
            var vendors = ["ms", "moz", "webkit", "o"];
            for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
              window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
              window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
            }
            if (!window2.requestAnimationFrame) {
              window2.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id2 = setTimeout(function() {
                  callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id2;
              };
            }
            if (!window2.cancelAnimationFrame) {
              window2.cancelAnimationFrame = function(id2) {
                clearTimeout(id2);
              };
            }
          })();
          function extendPrototype(sources, destination) {
            var i2;
            var len = sources.length;
            var sourcePrototype;
            for (i2 = 0; i2 < len; i2 += 1) {
              sourcePrototype = sources[i2].prototype;
              for (var attr2 in sourcePrototype) {
                if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr2))
                  destination.prototype[attr2] = sourcePrototype[attr2];
              }
            }
          }
          function getDescriptor(object, prop) {
            return Object.getOwnPropertyDescriptor(object, prop);
          }
          function createProxyFunction(prototype) {
            function ProxyFunction() {
            }
            ProxyFunction.prototype = prototype;
            return ProxyFunction;
          }
          function bezFunction() {
            var math = Math;
            function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
              var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
              return det1 > -1e-3 && det1 < 1e-3;
            }
            function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
              if (z1 === 0 && z2 === 0 && z3 === 0) {
                return pointOnLine2D(x1, y1, x2, y2, x3, y3);
              }
              var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
              var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
              var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
              var diffDist;
              if (dist1 > dist2) {
                if (dist1 > dist3) {
                  diffDist = dist1 - dist2 - dist3;
                } else {
                  diffDist = dist3 - dist2 - dist1;
                }
              } else if (dist3 > dist2) {
                diffDist = dist3 - dist2 - dist1;
              } else {
                diffDist = dist2 - dist1 - dist3;
              }
              return diffDist > -1e-4 && diffDist < 1e-4;
            }
            var getBezierLength = function() {
              return function(pt1, pt2, pt3, pt4) {
                var curveSegments = defaultCurveSegments;
                var k;
                var i2;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point = [];
                var lastPoint = [];
                var lengthData = bezierLengthPool.newElement();
                len = pt3.length;
                for (k = 0; k < curveSegments; k += 1) {
                  perc = k / (curveSegments - 1);
                  ptDistance = 0;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * pt3[i2] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i2] + bmPow(perc, 3) * pt2[i2];
                    point[i2] = ptCoord;
                    if (lastPoint[i2] !== null) {
                      ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                    }
                    lastPoint[i2] = point[i2];
                  }
                  if (ptDistance) {
                    ptDistance = bmSqrt(ptDistance);
                    addedLength += ptDistance;
                  }
                  lengthData.percents[k] = perc;
                  lengthData.lengths[k] = addedLength;
                }
                lengthData.addedLength = addedLength;
                return lengthData;
              };
            }();
            function getSegmentsLength(shapeData) {
              var segmentsLength = segmentsLengthPool.newElement();
              var closed = shapeData.c;
              var pathV = shapeData.v;
              var pathO = shapeData.o;
              var pathI = shapeData.i;
              var i2;
              var len = shapeData._length;
              var lengths = segmentsLength.lengths;
              var totalLength = 0;
              for (i2 = 0; i2 < len - 1; i2 += 1) {
                lengths[i2] = getBezierLength(pathV[i2], pathV[i2 + 1], pathO[i2], pathI[i2 + 1]);
                totalLength += lengths[i2].addedLength;
              }
              if (closed && len) {
                lengths[i2] = getBezierLength(pathV[i2], pathV[0], pathO[i2], pathI[0]);
                totalLength += lengths[i2].addedLength;
              }
              segmentsLength.totalLength = totalLength;
              return segmentsLength;
            }
            function BezierData(length) {
              this.segmentLength = 0;
              this.points = new Array(length);
            }
            function PointData(partial, point) {
              this.partialLength = partial;
              this.point = point;
            }
            var buildBezierData = function() {
              var storedData = {};
              return function(pt1, pt2, pt3, pt4) {
                var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
                if (!storedData[bezierName]) {
                  var curveSegments = defaultCurveSegments;
                  var k;
                  var i2;
                  var len;
                  var ptCoord;
                  var perc;
                  var addedLength = 0;
                  var ptDistance;
                  var point;
                  var lastPoint = null;
                  if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                    curveSegments = 2;
                  }
                  var bezierData = new BezierData(curveSegments);
                  len = pt3.length;
                  for (k = 0; k < curveSegments; k += 1) {
                    point = createSizedArray(len);
                    perc = k / (curveSegments - 1);
                    ptDistance = 0;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i2] + pt3[i2]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i2] + pt4[i2]) + bmPow(perc, 3) * pt2[i2];
                      point[i2] = ptCoord;
                      if (lastPoint !== null) {
                        ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                      }
                    }
                    ptDistance = bmSqrt(ptDistance);
                    addedLength += ptDistance;
                    bezierData.points[k] = new PointData(ptDistance, point);
                    lastPoint = point;
                  }
                  bezierData.segmentLength = addedLength;
                  storedData[bezierName] = bezierData;
                }
                return storedData[bezierName];
              };
            }();
            function getDistancePerc(perc, bezierData) {
              var percents = bezierData.percents;
              var lengths = bezierData.lengths;
              var len = percents.length;
              var initPos = bmFloor((len - 1) * perc);
              var lengthPos = perc * bezierData.addedLength;
              var lPerc = 0;
              if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
                return percents[initPos];
              }
              var dir = lengths[initPos] > lengthPos ? -1 : 1;
              var flag = true;
              while (flag) {
                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                  lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                  flag = false;
                } else {
                  initPos += dir;
                }
                if (initPos < 0 || initPos >= len - 1) {
                  if (initPos === len - 1) {
                    return percents[initPos];
                  }
                  flag = false;
                }
              }
              return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
            }
            function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
              var t1 = getDistancePerc(percent, bezierData);
              var u1 = 1 - t1;
              var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
              var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
              return [ptX, ptY];
            }
            var bezierSegmentPoints = createTypedArray("float32", 8);
            function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
              if (startPerc < 0) {
                startPerc = 0;
              } else if (startPerc > 1) {
                startPerc = 1;
              }
              var t0 = getDistancePerc(startPerc, bezierData);
              endPerc = endPerc > 1 ? 1 : endPerc;
              var t1 = getDistancePerc(endPerc, bezierData);
              var i2;
              var len = pt1.length;
              var u0 = 1 - t0;
              var u1 = 1 - t1;
              var u0u0u0 = u0 * u0 * u0;
              var t0u0u0_3 = t0 * u0 * u0 * 3;
              var t0t0u0_3 = t0 * t0 * u0 * 3;
              var t0t0t0 = t0 * t0 * t0;
              var u0u0u1 = u0 * u0 * u1;
              var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
              var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
              var t0t0t1 = t0 * t0 * t1;
              var u0u1u1 = u0 * u1 * u1;
              var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
              var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
              var t0t1t1 = t0 * t1 * t1;
              var u1u1u1 = u1 * u1 * u1;
              var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
              var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
              var t1t1t1 = t1 * t1 * t1;
              for (i2 = 0; i2 < len; i2 += 1) {
                bezierSegmentPoints[i2 * 4] = math.round((u0u0u0 * pt1[i2] + t0u0u0_3 * pt3[i2] + t0t0u0_3 * pt4[i2] + t0t0t0 * pt2[i2]) * 1e3) / 1e3;
                bezierSegmentPoints[i2 * 4 + 1] = math.round((u0u0u1 * pt1[i2] + t0u0u1_3 * pt3[i2] + t0t0u1_3 * pt4[i2] + t0t0t1 * pt2[i2]) * 1e3) / 1e3;
                bezierSegmentPoints[i2 * 4 + 2] = math.round((u0u1u1 * pt1[i2] + t0u1u1_3 * pt3[i2] + t0t1u1_3 * pt4[i2] + t0t1t1 * pt2[i2]) * 1e3) / 1e3;
                bezierSegmentPoints[i2 * 4 + 3] = math.round((u1u1u1 * pt1[i2] + t1u1u1_3 * pt3[i2] + t1t1u1_3 * pt4[i2] + t1t1t1 * pt2[i2]) * 1e3) / 1e3;
              }
              return bezierSegmentPoints;
            }
            return {
              getSegmentsLength,
              getNewSegment,
              getPointInSegment,
              buildBezierData,
              pointOnLine2D,
              pointOnLine3D
            };
          }
          var bez = bezFunction();
          var dataManager = function() {
            var _counterId = 1;
            var processes = [];
            var workerFn;
            var workerInstance;
            var workerProxy = {
              onmessage: function() {
              },
              postMessage: function(path) {
                workerFn({
                  data: path
                });
              }
            };
            var _workerSelf = {
              postMessage: function(data) {
                workerProxy.onmessage({
                  data
                });
              }
            };
            function createWorker(fn) {
              if (window2.Worker && window2.Blob && _useWebWorker) {
                var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], { type: "text/javascript" });
                var url = URL.createObjectURL(blob);
                return new Worker(url);
              }
              workerFn = fn;
              return workerProxy;
            }
            function setupWorker() {
              if (!workerInstance) {
                workerInstance = createWorker(function workerStart(e) {
                  function dataFunctionManager() {
                    function completeLayers(layers, comps) {
                      var layerData;
                      var i2;
                      var len = layers.length;
                      var j;
                      var jLen;
                      var k;
                      var kLen;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        layerData = layers[i2];
                        if ("ks" in layerData && !layerData.completed) {
                          layerData.completed = true;
                          if (layerData.tt) {
                            layers[i2 - 1].td = layerData.tt;
                          }
                          if (layerData.hasMask) {
                            var maskProps = layerData.masksProperties;
                            jLen = maskProps.length;
                            for (j = 0; j < jLen; j += 1) {
                              if (maskProps[j].pt.k.i) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k);
                              } else {
                                kLen = maskProps[j].pt.k.length;
                                for (k = 0; k < kLen; k += 1) {
                                  if (maskProps[j].pt.k[k].s) {
                                    convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                                  }
                                  if (maskProps[j].pt.k[k].e) {
                                    convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                                  }
                                }
                              }
                            }
                          }
                          if (layerData.ty === 0) {
                            layerData.layers = findCompLayers(layerData.refId, comps);
                            completeLayers(layerData.layers, comps);
                          } else if (layerData.ty === 4) {
                            completeShapes(layerData.shapes);
                          } else if (layerData.ty === 5) {
                            completeText(layerData);
                          }
                        }
                      }
                    }
                    function findCompLayers(id2, comps) {
                      var i2 = 0;
                      var len = comps.length;
                      while (i2 < len) {
                        if (comps[i2].id === id2) {
                          if (!comps[i2].layers.__used) {
                            comps[i2].layers.__used = true;
                            return comps[i2].layers;
                          }
                          return JSON.parse(JSON.stringify(comps[i2].layers));
                        }
                        i2 += 1;
                      }
                      return null;
                    }
                    function completeShapes(arr) {
                      var i2;
                      var len = arr.length;
                      var j;
                      var jLen;
                      for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                        if (arr[i2].ty === "sh") {
                          if (arr[i2].ks.k.i) {
                            convertPathsToAbsoluteValues(arr[i2].ks.k);
                          } else {
                            jLen = arr[i2].ks.k.length;
                            for (j = 0; j < jLen; j += 1) {
                              if (arr[i2].ks.k[j].s) {
                                convertPathsToAbsoluteValues(arr[i2].ks.k[j].s[0]);
                              }
                              if (arr[i2].ks.k[j].e) {
                                convertPathsToAbsoluteValues(arr[i2].ks.k[j].e[0]);
                              }
                            }
                          }
                        } else if (arr[i2].ty === "gr") {
                          completeShapes(arr[i2].it);
                        }
                      }
                    }
                    function convertPathsToAbsoluteValues(path) {
                      var i2;
                      var len = path.i.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        path.i[i2][0] += path.v[i2][0];
                        path.i[i2][1] += path.v[i2][1];
                        path.o[i2][0] += path.v[i2][0];
                        path.o[i2][1] += path.v[i2][1];
                      }
                    }
                    function checkVersion(minimum, animVersionString) {
                      var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                      if (minimum[0] > animVersion[0]) {
                        return true;
                      }
                      if (animVersion[0] > minimum[0]) {
                        return false;
                      }
                      if (minimum[1] > animVersion[1]) {
                        return true;
                      }
                      if (animVersion[1] > minimum[1]) {
                        return false;
                      }
                      if (minimum[2] > animVersion[2]) {
                        return true;
                      }
                      if (animVersion[2] > minimum[2]) {
                        return false;
                      }
                      return null;
                    }
                    var checkText = function() {
                      var minimumVersion = [4, 4, 14];
                      function updateTextLayer(textLayer) {
                        var documentData = textLayer.t.d;
                        textLayer.t.d = {
                          k: [
                            {
                              s: documentData,
                              t: 0
                            }
                          ]
                        };
                      }
                      function iterateLayers(layers) {
                        var i2;
                        var len = layers.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (layers[i2].ty === 5) {
                            updateTextLayer(layers[i2]);
                          }
                        }
                      }
                      return function(animationData2) {
                        if (checkVersion(minimumVersion, animationData2.v)) {
                          iterateLayers(animationData2.layers);
                          if (animationData2.assets) {
                            var i2;
                            var len = animationData2.assets.length;
                            for (i2 = 0; i2 < len; i2 += 1) {
                              if (animationData2.assets[i2].layers) {
                                iterateLayers(animationData2.assets[i2].layers);
                              }
                            }
                          }
                        }
                      };
                    }();
                    var checkChars = function() {
                      var minimumVersion = [4, 7, 99];
                      return function(animationData2) {
                        if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                          var i2;
                          var len = animationData2.chars.length;
                          var j;
                          var jLen;
                          var pathData;
                          var paths;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData2.chars[i2].data && animationData2.chars[i2].data.shapes) {
                              paths = animationData2.chars[i2].data.shapes[0].it;
                              jLen = paths.length;
                              for (j = 0; j < jLen; j += 1) {
                                pathData = paths[j].ks.k;
                                if (!pathData.__converted) {
                                  convertPathsToAbsoluteValues(paths[j].ks.k);
                                  pathData.__converted = true;
                                }
                              }
                            }
                          }
                        }
                      };
                    }();
                    var checkPathProperties = function() {
                      var minimumVersion = [5, 7, 15];
                      function updateTextLayer(textLayer) {
                        var pathData = textLayer.t.p;
                        if (typeof pathData.a === "number") {
                          pathData.a = {
                            a: 0,
                            k: pathData.a
                          };
                        }
                        if (typeof pathData.p === "number") {
                          pathData.p = {
                            a: 0,
                            k: pathData.p
                          };
                        }
                        if (typeof pathData.r === "number") {
                          pathData.r = {
                            a: 0,
                            k: pathData.r
                          };
                        }
                      }
                      function iterateLayers(layers) {
                        var i2;
                        var len = layers.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (layers[i2].ty === 5) {
                            updateTextLayer(layers[i2]);
                          }
                        }
                      }
                      return function(animationData2) {
                        if (checkVersion(minimumVersion, animationData2.v)) {
                          iterateLayers(animationData2.layers);
                          if (animationData2.assets) {
                            var i2;
                            var len = animationData2.assets.length;
                            for (i2 = 0; i2 < len; i2 += 1) {
                              if (animationData2.assets[i2].layers) {
                                iterateLayers(animationData2.assets[i2].layers);
                              }
                            }
                          }
                        }
                      };
                    }();
                    var checkColors = function() {
                      var minimumVersion = [4, 1, 9];
                      function iterateShapes(shapes) {
                        var i2;
                        var len = shapes.length;
                        var j;
                        var jLen;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (shapes[i2].ty === "gr") {
                            iterateShapes(shapes[i2].it);
                          } else if (shapes[i2].ty === "fl" || shapes[i2].ty === "st") {
                            if (shapes[i2].c.k && shapes[i2].c.k[0].i) {
                              jLen = shapes[i2].c.k.length;
                              for (j = 0; j < jLen; j += 1) {
                                if (shapes[i2].c.k[j].s) {
                                  shapes[i2].c.k[j].s[0] /= 255;
                                  shapes[i2].c.k[j].s[1] /= 255;
                                  shapes[i2].c.k[j].s[2] /= 255;
                                  shapes[i2].c.k[j].s[3] /= 255;
                                }
                                if (shapes[i2].c.k[j].e) {
                                  shapes[i2].c.k[j].e[0] /= 255;
                                  shapes[i2].c.k[j].e[1] /= 255;
                                  shapes[i2].c.k[j].e[2] /= 255;
                                  shapes[i2].c.k[j].e[3] /= 255;
                                }
                              }
                            } else {
                              shapes[i2].c.k[0] /= 255;
                              shapes[i2].c.k[1] /= 255;
                              shapes[i2].c.k[2] /= 255;
                              shapes[i2].c.k[3] /= 255;
                            }
                          }
                        }
                      }
                      function iterateLayers(layers) {
                        var i2;
                        var len = layers.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (layers[i2].ty === 4) {
                            iterateShapes(layers[i2].shapes);
                          }
                        }
                      }
                      return function(animationData2) {
                        if (checkVersion(minimumVersion, animationData2.v)) {
                          iterateLayers(animationData2.layers);
                          if (animationData2.assets) {
                            var i2;
                            var len = animationData2.assets.length;
                            for (i2 = 0; i2 < len; i2 += 1) {
                              if (animationData2.assets[i2].layers) {
                                iterateLayers(animationData2.assets[i2].layers);
                              }
                            }
                          }
                        }
                      };
                    }();
                    var checkShapes = function() {
                      var minimumVersion = [4, 4, 18];
                      function completeClosingShapes(arr) {
                        var i2;
                        var len = arr.length;
                        var j;
                        var jLen;
                        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                          if (arr[i2].ty === "sh") {
                            if (arr[i2].ks.k.i) {
                              arr[i2].ks.k.c = arr[i2].closed;
                            } else {
                              jLen = arr[i2].ks.k.length;
                              for (j = 0; j < jLen; j += 1) {
                                if (arr[i2].ks.k[j].s) {
                                  arr[i2].ks.k[j].s[0].c = arr[i2].closed;
                                }
                                if (arr[i2].ks.k[j].e) {
                                  arr[i2].ks.k[j].e[0].c = arr[i2].closed;
                                }
                              }
                            }
                          } else if (arr[i2].ty === "gr") {
                            completeClosingShapes(arr[i2].it);
                          }
                        }
                      }
                      function iterateLayers(layers) {
                        var layerData;
                        var i2;
                        var len = layers.length;
                        var j;
                        var jLen;
                        var k;
                        var kLen;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          layerData = layers[i2];
                          if (layerData.hasMask) {
                            var maskProps = layerData.masksProperties;
                            jLen = maskProps.length;
                            for (j = 0; j < jLen; j += 1) {
                              if (maskProps[j].pt.k.i) {
                                maskProps[j].pt.k.c = maskProps[j].cl;
                              } else {
                                kLen = maskProps[j].pt.k.length;
                                for (k = 0; k < kLen; k += 1) {
                                  if (maskProps[j].pt.k[k].s) {
                                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                                  }
                                  if (maskProps[j].pt.k[k].e) {
                                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                                  }
                                }
                              }
                            }
                          }
                          if (layerData.ty === 4) {
                            completeClosingShapes(layerData.shapes);
                          }
                        }
                      }
                      return function(animationData2) {
                        if (checkVersion(minimumVersion, animationData2.v)) {
                          iterateLayers(animationData2.layers);
                          if (animationData2.assets) {
                            var i2;
                            var len = animationData2.assets.length;
                            for (i2 = 0; i2 < len; i2 += 1) {
                              if (animationData2.assets[i2].layers) {
                                iterateLayers(animationData2.assets[i2].layers);
                              }
                            }
                          }
                        }
                      };
                    }();
                    function completeData(animationData2) {
                      if (animationData2.__complete) {
                        return;
                      }
                      checkColors(animationData2);
                      checkText(animationData2);
                      checkChars(animationData2);
                      checkPathProperties(animationData2);
                      checkShapes(animationData2);
                      completeLayers(animationData2.layers, animationData2.assets);
                      animationData2.__complete = true;
                    }
                    function completeText(data) {
                      if (data.t.a.length === 0 && !("m" in data.t.p)) {
                        data.singleShape = true;
                      }
                    }
                    var moduleOb = {};
                    moduleOb.completeData = completeData;
                    moduleOb.checkColors = checkColors;
                    moduleOb.checkChars = checkChars;
                    moduleOb.checkPathProperties = checkPathProperties;
                    moduleOb.checkShapes = checkShapes;
                    moduleOb.completeLayers = completeLayers;
                    return moduleOb;
                  }
                  if (!_workerSelf.dataManager) {
                    _workerSelf.dataManager = dataFunctionManager();
                  }
                  if (!_workerSelf.assetLoader) {
                    _workerSelf.assetLoader = function() {
                      function formatResponse(xhr) {
                        var contentTypeHeader = xhr.getResponseHeader("content-type");
                        if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                          return xhr.response;
                        }
                        if (xhr.response && typeof xhr.response === "object") {
                          return xhr.response;
                        }
                        if (xhr.response && typeof xhr.response === "string") {
                          return JSON.parse(xhr.response);
                        }
                        if (xhr.responseText) {
                          return JSON.parse(xhr.responseText);
                        }
                        return null;
                      }
                      function loadAsset(path, fullPath, callback, errorCallback) {
                        var response;
                        var xhr = new XMLHttpRequest();
                        try {
                          xhr.responseType = "json";
                        } catch (err) {
                        }
                        xhr.onreadystatechange = function() {
                          if (xhr.readyState === 4) {
                            if (xhr.status === 200) {
                              response = formatResponse(xhr);
                              callback(response);
                            } else {
                              try {
                                response = formatResponse(xhr);
                                callback(response);
                              } catch (err) {
                                if (errorCallback) {
                                  errorCallback(err);
                                }
                              }
                            }
                          }
                        };
                        try {
                          xhr.open("GET", path, true);
                        } catch (error) {
                          xhr.open("GET", fullPath + "/" + path, true);
                        }
                        xhr.send();
                      }
                      return {
                        load: loadAsset
                      };
                    }();
                  }
                  if (e.data.type === "loadAnimation") {
                    _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {
                      _workerSelf.dataManager.completeData(data);
                      _workerSelf.postMessage({
                        id: e.data.id,
                        payload: data,
                        status: "success"
                      });
                    }, function() {
                      _workerSelf.postMessage({
                        id: e.data.id,
                        status: "error"
                      });
                    });
                  } else if (e.data.type === "complete") {
                    var animation = e.data.animation;
                    _workerSelf.dataManager.completeData(animation);
                    _workerSelf.postMessage({
                      id: e.data.id,
                      payload: animation,
                      status: "success"
                    });
                  } else if (e.data.type === "loadData") {
                    _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {
                      _workerSelf.postMessage({
                        id: e.data.id,
                        payload: data,
                        status: "success"
                      });
                    }, function() {
                      _workerSelf.postMessage({
                        id: e.data.id,
                        status: "error"
                      });
                    });
                  }
                });
                workerInstance.onmessage = function(event2) {
                  var data = event2.data;
                  var id2 = data.id;
                  var process = processes[id2];
                  processes[id2] = null;
                  if (data.status === "success") {
                    process.onComplete(data.payload);
                  } else if (process.onError) {
                    process.onError();
                  }
                };
              }
            }
            function createProcess(onComplete, onError) {
              _counterId += 1;
              var id2 = "processId_" + _counterId;
              processes[id2] = {
                onComplete,
                onError
              };
              return id2;
            }
            function loadAnimation2(path, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "loadAnimation",
                path,
                fullPath: window2.location.origin + window2.location.pathname,
                id: processId
              });
            }
            function loadData(path, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "loadData",
                path,
                fullPath: window2.location.origin + window2.location.pathname,
                id: processId
              });
            }
            function completeAnimation(anim, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "complete",
                animation: anim,
                id: processId
              });
            }
            return {
              loadAnimation: loadAnimation2,
              loadData,
              completeAnimation
            };
          }();
          function getFontProperties(fontData) {
            var styles2 = fontData.fStyle ? fontData.fStyle.split(" ") : [];
            var fWeight = "normal";
            var fStyle = "normal";
            var len = styles2.length;
            var styleName;
            for (var i2 = 0; i2 < len; i2 += 1) {
              styleName = styles2[i2].toLowerCase();
              switch (styleName) {
                case "italic":
                  fStyle = "italic";
                  break;
                case "bold":
                  fWeight = "700";
                  break;
                case "black":
                  fWeight = "900";
                  break;
                case "medium":
                  fWeight = "500";
                  break;
                case "regular":
                case "normal":
                  fWeight = "400";
                  break;
                case "light":
                case "thin":
                  fWeight = "200";
                  break;
                default:
                  break;
              }
            }
            return {
              style: fStyle,
              weight: fontData.fWeight || fWeight
            };
          }
          var FontManager = function() {
            var maxWaitingTime = 5e3;
            var emptyChar = {
              w: 0,
              size: 0,
              shapes: []
            };
            var combinedCharacters = [];
            combinedCharacters = combinedCharacters.concat([
              2304,
              2305,
              2306,
              2307,
              2362,
              2363,
              2364,
              2364,
              2366,
              2367,
              2368,
              2369,
              2370,
              2371,
              2372,
              2373,
              2374,
              2375,
              2376,
              2377,
              2378,
              2379,
              2380,
              2381,
              2382,
              2383,
              2387,
              2388,
              2389,
              2390,
              2391,
              2402,
              2403
            ]);
            var surrogateModifiers = [
              "d83cdffb",
              "d83cdffc",
              "d83cdffd",
              "d83cdffe",
              "d83cdfff"
            ];
            var zeroWidthJoiner = [65039, 8205];
            function trimFontOptions(font) {
              var familyArray = font.split(",");
              var i2;
              var len = familyArray.length;
              var enabledFamilies = [];
              for (i2 = 0; i2 < len; i2 += 1) {
                if (familyArray[i2] !== "sans-serif" && familyArray[i2] !== "monospace") {
                  enabledFamilies.push(familyArray[i2]);
                }
              }
              return enabledFamilies.join(",");
            }
            function setUpNode(font, family) {
              var parentNode = createTag("span");
              parentNode.setAttribute("aria-hidden", true);
              parentNode.style.fontFamily = family;
              var node = createTag("span");
              node.innerText = "giItT1WQy@!-/#";
              parentNode.style.position = "absolute";
              parentNode.style.left = "-10000px";
              parentNode.style.top = "-10000px";
              parentNode.style.fontSize = "300px";
              parentNode.style.fontVariant = "normal";
              parentNode.style.fontStyle = "normal";
              parentNode.style.fontWeight = "normal";
              parentNode.style.letterSpacing = "0";
              parentNode.appendChild(node);
              document.body.appendChild(parentNode);
              var width = node.offsetWidth;
              node.style.fontFamily = trimFontOptions(font) + ", " + family;
              return { node, w: width, parent: parentNode };
            }
            function checkLoadedFonts() {
              var i2;
              var len = this.fonts.length;
              var node;
              var w;
              var loadedCount = len;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (this.fonts[i2].loaded) {
                  loadedCount -= 1;
                } else if (this.fonts[i2].fOrigin === "n" || this.fonts[i2].origin === 0) {
                  this.fonts[i2].loaded = true;
                } else {
                  node = this.fonts[i2].monoCase.node;
                  w = this.fonts[i2].monoCase.w;
                  if (node.offsetWidth !== w) {
                    loadedCount -= 1;
                    this.fonts[i2].loaded = true;
                  } else {
                    node = this.fonts[i2].sansCase.node;
                    w = this.fonts[i2].sansCase.w;
                    if (node.offsetWidth !== w) {
                      loadedCount -= 1;
                      this.fonts[i2].loaded = true;
                    }
                  }
                  if (this.fonts[i2].loaded) {
                    this.fonts[i2].sansCase.parent.parentNode.removeChild(this.fonts[i2].sansCase.parent);
                    this.fonts[i2].monoCase.parent.parentNode.removeChild(this.fonts[i2].monoCase.parent);
                  }
                }
              }
              if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
                setTimeout(this.checkLoadedFontsBinded, 20);
              } else {
                setTimeout(this.setIsLoadedBinded, 10);
              }
            }
            function createHelper(def, fontData) {
              var tHelper = createNS("text");
              tHelper.style.fontSize = "100px";
              var fontProps = getFontProperties(fontData);
              tHelper.setAttribute("font-family", fontData.fFamily);
              tHelper.setAttribute("font-style", fontProps.style);
              tHelper.setAttribute("font-weight", fontProps.weight);
              tHelper.textContent = "1";
              if (fontData.fClass) {
                tHelper.style.fontFamily = "inherit";
                tHelper.setAttribute("class", fontData.fClass);
              } else {
                tHelper.style.fontFamily = fontData.fFamily;
              }
              def.appendChild(tHelper);
              var tCanvasHelper = createTag("canvas").getContext("2d");
              tCanvasHelper.font = fontData.fWeight + " " + fontData.fStyle + " 100px " + fontData.fFamily;
              return tHelper;
            }
            function addFonts(fontData, defs) {
              if (!fontData) {
                this.isLoaded = true;
                return;
              }
              if (this.chars) {
                this.isLoaded = true;
                this.fonts = fontData.list;
                return;
              }
              var fontArr = fontData.list;
              var i2;
              var len = fontArr.length;
              var _pendingFonts = len;
              for (i2 = 0; i2 < len; i2 += 1) {
                var shouldLoadFont = true;
                var loadedSelector;
                var j;
                fontArr[i2].loaded = false;
                fontArr[i2].monoCase = setUpNode(fontArr[i2].fFamily, "monospace");
                fontArr[i2].sansCase = setUpNode(fontArr[i2].fFamily, "sans-serif");
                if (!fontArr[i2].fPath) {
                  fontArr[i2].loaded = true;
                  _pendingFonts -= 1;
                } else if (fontArr[i2].fOrigin === "p" || fontArr[i2].origin === 3) {
                  loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i2].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i2].fFamily + '"]');
                  if (loadedSelector.length > 0) {
                    shouldLoadFont = false;
                  }
                  if (shouldLoadFont) {
                    var s = createTag("style");
                    s.setAttribute("f-forigin", fontArr[i2].fOrigin);
                    s.setAttribute("f-origin", fontArr[i2].origin);
                    s.setAttribute("f-family", fontArr[i2].fFamily);
                    s.type = "text/css";
                    s.innerText = "@font-face {font-family: " + fontArr[i2].fFamily + "; font-style: normal; src: url('" + fontArr[i2].fPath + "');}";
                    defs.appendChild(s);
                  }
                } else if (fontArr[i2].fOrigin === "g" || fontArr[i2].origin === 1) {
                  loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                  for (j = 0; j < loadedSelector.length; j += 1) {
                    if (loadedSelector[j].href.indexOf(fontArr[i2].fPath) !== -1) {
                      shouldLoadFont = false;
                    }
                  }
                  if (shouldLoadFont) {
                    var l = createTag("link");
                    l.setAttribute("f-forigin", fontArr[i2].fOrigin);
                    l.setAttribute("f-origin", fontArr[i2].origin);
                    l.type = "text/css";
                    l.rel = "stylesheet";
                    l.href = fontArr[i2].fPath;
                    document.body.appendChild(l);
                  }
                } else if (fontArr[i2].fOrigin === "t" || fontArr[i2].origin === 2) {
                  loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                  for (j = 0; j < loadedSelector.length; j += 1) {
                    if (fontArr[i2].fPath === loadedSelector[j].src) {
                      shouldLoadFont = false;
                    }
                  }
                  if (shouldLoadFont) {
                    var sc = createTag("link");
                    sc.setAttribute("f-forigin", fontArr[i2].fOrigin);
                    sc.setAttribute("f-origin", fontArr[i2].origin);
                    sc.setAttribute("rel", "stylesheet");
                    sc.setAttribute("href", fontArr[i2].fPath);
                    defs.appendChild(sc);
                  }
                }
                fontArr[i2].helper = createHelper(defs, fontArr[i2]);
                fontArr[i2].cache = {};
                this.fonts.push(fontArr[i2]);
              }
              if (_pendingFonts === 0) {
                this.isLoaded = true;
              } else {
                setTimeout(this.checkLoadedFonts.bind(this), 100);
              }
            }
            function addChars(chars) {
              if (!chars) {
                return;
              }
              if (!this.chars) {
                this.chars = [];
              }
              var i2;
              var len = chars.length;
              var j;
              var jLen = this.chars.length;
              var found;
              for (i2 = 0; i2 < len; i2 += 1) {
                j = 0;
                found = false;
                while (j < jLen) {
                  if (this.chars[j].style === chars[i2].style && this.chars[j].fFamily === chars[i2].fFamily && this.chars[j].ch === chars[i2].ch) {
                    found = true;
                  }
                  j += 1;
                }
                if (!found) {
                  this.chars.push(chars[i2]);
                  jLen += 1;
                }
              }
            }
            function getCharData(char, style, font) {
              var i2 = 0;
              var len = this.chars.length;
              while (i2 < len) {
                if (this.chars[i2].ch === char && this.chars[i2].style === style && this.chars[i2].fFamily === font) {
                  return this.chars[i2];
                }
                i2 += 1;
              }
              if ((typeof char === "string" && char.charCodeAt(0) !== 13 || !char) && console && console.warn && !this._warned) {
                this._warned = true;
                console.warn("Missing character from exported characters list: ", char, style, font);
              }
              return emptyChar;
            }
            function measureText(char, fontName, size) {
              var fontData = this.getFontByName(fontName);
              var index3 = char.charCodeAt(0);
              if (!fontData.cache[index3 + 1]) {
                var tHelper = fontData.helper;
                if (char === " ") {
                  tHelper.textContent = "|" + char + "|";
                  var doubleSize = tHelper.getComputedTextLength();
                  tHelper.textContent = "||";
                  var singleSize = tHelper.getComputedTextLength();
                  fontData.cache[index3 + 1] = (doubleSize - singleSize) / 100;
                } else {
                  tHelper.textContent = char;
                  fontData.cache[index3 + 1] = tHelper.getComputedTextLength() / 100;
                }
              }
              return fontData.cache[index3 + 1] * size;
            }
            function getFontByName(name) {
              var i2 = 0;
              var len = this.fonts.length;
              while (i2 < len) {
                if (this.fonts[i2].fName === name) {
                  return this.fonts[i2];
                }
                i2 += 1;
              }
              return this.fonts[0];
            }
            function isModifier(firstCharCode, secondCharCode) {
              var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
              return surrogateModifiers.indexOf(sum) !== -1;
            }
            function isZeroWidthJoiner(firstCharCode, secondCharCode) {
              if (!secondCharCode) {
                return firstCharCode === zeroWidthJoiner[1];
              }
              return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
            }
            function isCombinedCharacter(char) {
              return combinedCharacters.indexOf(char) !== -1;
            }
            function setIsLoaded() {
              this.isLoaded = true;
            }
            var Font2 = function() {
              this.fonts = [];
              this.chars = null;
              this.typekitLoaded = 0;
              this.isLoaded = false;
              this._warned = false;
              this.initTime = Date.now();
              this.setIsLoadedBinded = this.setIsLoaded.bind(this);
              this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
            };
            Font2.isModifier = isModifier;
            Font2.isZeroWidthJoiner = isZeroWidthJoiner;
            Font2.isCombinedCharacter = isCombinedCharacter;
            var fontPrototype = {
              addChars,
              addFonts,
              getCharData,
              getFontByName,
              measureText,
              checkLoadedFonts,
              setIsLoaded
            };
            Font2.prototype = fontPrototype;
            return Font2;
          }();
          var PropertyFactory = function() {
            var initFrame = initialDefaultFrame;
            var mathAbs = Math.abs;
            function interpolateValue(frameNum, caching) {
              var offsetTime = this.offsetTime;
              var newValue;
              if (this.propType === "multidimensional") {
                newValue = createTypedArray("float32", this.pv.length);
              }
              var iterationIndex = caching.lastIndex;
              var i2 = iterationIndex;
              var len = this.keyframes.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;
              while (flag) {
                keyData = this.keyframes[i2];
                nextKeyData = this.keyframes[i2 + 1];
                if (i2 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                  if (keyData.h) {
                    keyData = nextKeyData;
                  }
                  iterationIndex = 0;
                  break;
                }
                if (nextKeyData.t - offsetTime > frameNum) {
                  iterationIndex = i2;
                  break;
                }
                if (i2 < len - 1) {
                  i2 += 1;
                } else {
                  iterationIndex = 0;
                  flag = false;
                }
              }
              keyframeMetadata = this.keyframesMetadata[i2] || {};
              var k;
              var kLen;
              var perc;
              var jLen;
              var j;
              var fnc;
              var nextKeyTime = nextKeyData.t - offsetTime;
              var keyTime = keyData.t - offsetTime;
              var endValue;
              if (keyData.to) {
                if (!keyframeMetadata.bezierData) {
                  keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
                }
                var bezierData = keyframeMetadata.bezierData;
                if (frameNum >= nextKeyTime || frameNum < keyTime) {
                  var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                  kLen = bezierData.points[ind].point.length;
                  for (k = 0; k < kLen; k += 1) {
                    newValue[k] = bezierData.points[ind].point[k];
                  }
                } else {
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                    keyframeMetadata.__fnct = fnc;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  var distanceInLine = bezierData.segmentLength * perc;
                  var segmentPerc;
                  var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastAddedLength : 0;
                  j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastPoint : 0;
                  flag = true;
                  jLen = bezierData.points.length;
                  while (flag) {
                    addedLength += bezierData.points[j].partialLength;
                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                      kLen = bezierData.points[j].point.length;
                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[j].point[k];
                      }
                      break;
                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                      segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                      kLen = bezierData.points[j].point.length;
                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                      }
                      break;
                    }
                    if (j < jLen - 1) {
                      j += 1;
                    } else {
                      flag = false;
                    }
                  }
                  caching._lastPoint = j;
                  caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
                  caching._lastKeyframeIndex = i2;
                }
              } else {
                var outX;
                var outY;
                var inX;
                var inY;
                var keyValue;
                len = keyData.s.length;
                endValue = nextKeyData.s || keyData.e;
                if (this.sh && keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    newValue[0] = endValue[0];
                    newValue[1] = endValue[1];
                    newValue[2] = endValue[2];
                  } else if (frameNum <= keyTime) {
                    newValue[0] = keyData.s[0];
                    newValue[1] = keyData.s[1];
                    newValue[2] = keyData.s[2];
                  } else {
                    var quatStart = createQuaternion(keyData.s);
                    var quatEnd = createQuaternion(endValue);
                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                  }
                } else {
                  for (i2 = 0; i2 < len; i2 += 1) {
                    if (keyData.h !== 1) {
                      if (frameNum >= nextKeyTime) {
                        perc = 1;
                      } else if (frameNum < keyTime) {
                        perc = 0;
                      } else {
                        if (keyData.o.x.constructor === Array) {
                          if (!keyframeMetadata.__fnct) {
                            keyframeMetadata.__fnct = [];
                          }
                          if (!keyframeMetadata.__fnct[i2]) {
                            outX = keyData.o.x[i2] === void 0 ? keyData.o.x[0] : keyData.o.x[i2];
                            outY = keyData.o.y[i2] === void 0 ? keyData.o.y[0] : keyData.o.y[i2];
                            inX = keyData.i.x[i2] === void 0 ? keyData.i.x[0] : keyData.i.x[i2];
                            inY = keyData.i.y[i2] === void 0 ? keyData.i.y[0] : keyData.i.y[i2];
                            fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                            keyframeMetadata.__fnct[i2] = fnc;
                          } else {
                            fnc = keyframeMetadata.__fnct[i2];
                          }
                        } else if (!keyframeMetadata.__fnct) {
                          outX = keyData.o.x;
                          outY = keyData.o.y;
                          inX = keyData.i.x;
                          inY = keyData.i.y;
                          fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                          keyData.keyframeMetadata = fnc;
                        } else {
                          fnc = keyframeMetadata.__fnct;
                        }
                        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                      }
                    }
                    endValue = nextKeyData.s || keyData.e;
                    keyValue = keyData.h === 1 ? keyData.s[i2] : keyData.s[i2] + (endValue[i2] - keyData.s[i2]) * perc;
                    if (this.propType === "multidimensional") {
                      newValue[i2] = keyValue;
                    } else {
                      newValue = keyValue;
                    }
                  }
                }
              }
              caching.lastIndex = iterationIndex;
              return newValue;
            }
            function slerp(a, b, t) {
              var out = [];
              var ax = a[0];
              var ay = a[1];
              var az = a[2];
              var aw = a[3];
              var bx = b[0];
              var by = b[1];
              var bz = b[2];
              var bw = b[3];
              var omega;
              var cosom;
              var sinom;
              var scale0;
              var scale1;
              cosom = ax * bx + ay * by + az * bz + aw * bw;
              if (cosom < 0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
              }
              if (1 - cosom > 1e-6) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
              } else {
                scale0 = 1 - t;
                scale1 = t;
              }
              out[0] = scale0 * ax + scale1 * bx;
              out[1] = scale0 * ay + scale1 * by;
              out[2] = scale0 * az + scale1 * bz;
              out[3] = scale0 * aw + scale1 * bw;
              return out;
            }
            function quaternionToEuler(out, quat) {
              var qx = quat[0];
              var qy = quat[1];
              var qz = quat[2];
              var qw = quat[3];
              var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
              var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
              var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
              out[0] = heading / degToRads;
              out[1] = attitude / degToRads;
              out[2] = bank / degToRads;
            }
            function createQuaternion(values) {
              var heading = values[0] * degToRads;
              var attitude = values[1] * degToRads;
              var bank = values[2] * degToRads;
              var c1 = Math.cos(heading / 2);
              var c2 = Math.cos(attitude / 2);
              var c3 = Math.cos(bank / 2);
              var s1 = Math.sin(heading / 2);
              var s2 = Math.sin(attitude / 2);
              var s3 = Math.sin(bank / 2);
              var w = c1 * c2 * c3 - s1 * s2 * s3;
              var x = s1 * s2 * c3 + c1 * c2 * s3;
              var y = s1 * c2 * c3 + c1 * s2 * s3;
              var z = c1 * s2 * c3 - s1 * c2 * s3;
              return [x, y, z, w];
            }
            function getValueAtCurrentTime() {
              var frameNum = this.comp.renderedFrame - this.offsetTime;
              var initTime = this.keyframes[0].t - this.offsetTime;
              var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
                if (this._caching.lastFrame >= frameNum) {
                  this._caching._lastKeyframeIndex = -1;
                  this._caching.lastIndex = 0;
                }
                var renderResult = this.interpolateValue(frameNum, this._caching);
                this.pv = renderResult;
              }
              this._caching.lastFrame = frameNum;
              return this.pv;
            }
            function setVValue(val) {
              var multipliedValue;
              if (this.propType === "unidimensional") {
                multipliedValue = val * this.mult;
                if (mathAbs(this.v - multipliedValue) > 1e-5) {
                  this.v = multipliedValue;
                  this._mdf = true;
                }
              } else {
                var i2 = 0;
                var len = this.v.length;
                while (i2 < len) {
                  multipliedValue = val[i2] * this.mult;
                  if (mathAbs(this.v[i2] - multipliedValue) > 1e-5) {
                    this.v[i2] = multipliedValue;
                    this._mdf = true;
                  }
                  i2 += 1;
                }
              }
            }
            function processEffectsSequence() {
              if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              this.lock = true;
              this._mdf = this._isFirstFrame;
              var i2;
              var len = this.effectsSequence.length;
              var finalValue = this.kf ? this.pv : this.data.k;
              for (i2 = 0; i2 < len; i2 += 1) {
                finalValue = this.effectsSequence[i2](finalValue);
              }
              this.setVValue(finalValue);
              this._isFirstFrame = false;
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            }
            function addEffect(effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.container.addDynamicProperty(this);
            }
            function ValueProperty(elem, data, mult, container) {
              this.propType = "unidimensional";
              this.mult = mult || 1;
              this.data = data;
              this.v = mult ? data.k * mult : data.k;
              this.pv = data.k;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.vel = 0;
              this.effectsSequence = [];
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }
            function MultiDimensionalProperty(elem, data, mult, container) {
              this.propType = "multidimensional";
              this.mult = mult || 1;
              this.data = data;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.frameId = -1;
              var i2;
              var len = data.k.length;
              this.v = createTypedArray("float32", len);
              this.pv = createTypedArray("float32", len);
              this.vel = createTypedArray("float32", len);
              for (i2 = 0; i2 < len; i2 += 1) {
                this.v[i2] = data.k[i2] * this.mult;
                this.pv[i2] = data.k[i2];
              }
              this._isFirstFrame = true;
              this.effectsSequence = [];
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }
            function KeyframedValueProperty(elem, data, mult, container) {
              this.propType = "unidimensional";
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.frameId = -1;
              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
              };
              this.k = true;
              this.kf = true;
              this.data = data;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.v = initFrame;
              this.pv = initFrame;
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.addEffect = addEffect;
            }
            function KeyframedMultidimensionalProperty(elem, data, mult, container) {
              this.propType = "multidimensional";
              var i2;
              var len = data.k.length;
              var s;
              var e;
              var to;
              var ti;
              for (i2 = 0; i2 < len - 1; i2 += 1) {
                if (data.k[i2].to && data.k[i2].s && data.k[i2 + 1] && data.k[i2 + 1].s) {
                  s = data.k[i2].s;
                  e = data.k[i2 + 1].s;
                  to = data.k[i2].to;
                  ti = data.k[i2].ti;
                  if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
                    data.k[i2].to = null;
                    data.k[i2].ti = null;
                  }
                  if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                      data.k[i2].to = null;
                      data.k[i2].ti = null;
                    }
                  }
                }
              }
              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.data = data;
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.k = true;
              this.kf = true;
              this._isFirstFrame = true;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.frameId = -1;
              var arrLen = data.k[0].s.length;
              this.v = createTypedArray("float32", arrLen);
              this.pv = createTypedArray("float32", arrLen);
              for (i2 = 0; i2 < arrLen; i2 += 1) {
                this.v[i2] = initFrame;
                this.pv[i2] = initFrame;
              }
              this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray("float32", arrLen) };
              this.addEffect = addEffect;
            }
            function getProp(elem, data, type, mult, container) {
              var p;
              if (!data.k.length) {
                p = new ValueProperty(elem, data, mult, container);
              } else if (typeof data.k[0] === "number") {
                p = new MultiDimensionalProperty(elem, data, mult, container);
              } else {
                switch (type) {
                  case 0:
                    p = new KeyframedValueProperty(elem, data, mult, container);
                    break;
                  case 1:
                    p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                    break;
                  default:
                    break;
                }
              }
              if (p.effectsSequence.length) {
                container.addDynamicProperty(p);
              }
              return p;
            }
            var ob = {
              getProp
            };
            return ob;
          }();
          var TransformPropertyFactory = function() {
            var defaultVector = [0, 0];
            function applyToMatrix(mat) {
              var _mdf = this._mdf;
              this.iterateDynamicProperties();
              this._mdf = this._mdf || _mdf;
              if (this.a) {
                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              }
              if (this.s) {
                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              }
              if (this.sk) {
                mat.skewFromAxis(-this.sk.v, this.sa.v);
              }
              if (this.r) {
                mat.rotate(-this.r.v);
              } else {
                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              }
              if (this.data.p.s) {
                if (this.data.p.z) {
                  mat.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                  mat.translate(this.px.v, this.py.v, 0);
                }
              } else {
                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
            }
            function processKeys(forceRender) {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              if (this._isDirty) {
                this.precalculateMatrix();
                this._isDirty = false;
              }
              this.iterateDynamicProperties();
              if (this._mdf || forceRender) {
                var frameRate;
                this.v.cloneFromProps(this.pre.props);
                if (this.appliedTransformations < 1) {
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                }
                if (this.appliedTransformations < 2) {
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                }
                if (this.sk && this.appliedTransformations < 3) {
                  this.v.skewFromAxis(-this.sk.v, this.sa.v);
                }
                if (this.r && this.appliedTransformations < 4) {
                  this.v.rotate(-this.r.v);
                } else if (!this.r && this.appliedTransformations < 4) {
                  this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                }
                if (this.autoOriented) {
                  var v1;
                  var v2;
                  frameRate = this.elem.globalData.frameRate;
                  if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                    if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                      v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                      v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                    } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                      v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                      v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                    } else {
                      v1 = this.p.pv;
                      v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                    }
                  } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                    v1 = [];
                    v2 = [];
                    var px2 = this.px;
                    var py2 = this.py;
                    if (px2._caching.lastFrame + px2.offsetTime <= px2.keyframes[0].t) {
                      v1[0] = px2.getValueAtTime((px2.keyframes[0].t + 0.01) / frameRate, 0);
                      v1[1] = py2.getValueAtTime((py2.keyframes[0].t + 0.01) / frameRate, 0);
                      v2[0] = px2.getValueAtTime(px2.keyframes[0].t / frameRate, 0);
                      v2[1] = py2.getValueAtTime(py2.keyframes[0].t / frameRate, 0);
                    } else if (px2._caching.lastFrame + px2.offsetTime >= px2.keyframes[px2.keyframes.length - 1].t) {
                      v1[0] = px2.getValueAtTime(px2.keyframes[px2.keyframes.length - 1].t / frameRate, 0);
                      v1[1] = py2.getValueAtTime(py2.keyframes[py2.keyframes.length - 1].t / frameRate, 0);
                      v2[0] = px2.getValueAtTime((px2.keyframes[px2.keyframes.length - 1].t - 0.01) / frameRate, 0);
                      v2[1] = py2.getValueAtTime((py2.keyframes[py2.keyframes.length - 1].t - 0.01) / frameRate, 0);
                    } else {
                      v1 = [px2.pv, py2.pv];
                      v2[0] = px2.getValueAtTime((px2._caching.lastFrame + px2.offsetTime - 0.01) / frameRate, px2.offsetTime);
                      v2[1] = py2.getValueAtTime((py2._caching.lastFrame + py2.offsetTime - 0.01) / frameRate, py2.offsetTime);
                    }
                  } else {
                    v2 = defaultVector;
                    v1 = v2;
                  }
                  this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                }
                if (this.data.p && this.data.p.s) {
                  if (this.data.p.z) {
                    this.v.translate(this.px.v, this.py.v, -this.pz.v);
                  } else {
                    this.v.translate(this.px.v, this.py.v, 0);
                  }
                } else {
                  this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                }
              }
              this.frameId = this.elem.globalData.frameId;
            }
            function precalculateMatrix() {
              if (!this.a.k) {
                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                this.appliedTransformations = 1;
              } else {
                return;
              }
              if (!this.s.effectsSequence.length) {
                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                this.appliedTransformations = 2;
              } else {
                return;
              }
              if (this.sk) {
                if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                  this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                  this.appliedTransformations = 3;
                } else {
                  return;
                }
              }
              if (this.r) {
                if (!this.r.effectsSequence.length) {
                  this.pre.rotate(-this.r.v);
                  this.appliedTransformations = 4;
                }
              } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                this.appliedTransformations = 4;
              }
            }
            function autoOrient() {
            }
            function addDynamicProperty(prop) {
              this._addDynamicProperty(prop);
              this.elem.addDynamicProperty(prop);
              this._isDirty = true;
            }
            function TransformProperty(elem, data, container) {
              this.elem = elem;
              this.frameId = -1;
              this.propType = "transform";
              this.data = data;
              this.v = new Matrix();
              this.pre = new Matrix();
              this.appliedTransformations = 0;
              this.initDynamicPropertyContainer(container || elem);
              if (data.p && data.p.s) {
                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
                if (data.p.z) {
                  this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
                }
              } else {
                this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
              }
              if (data.rx) {
                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
                if (data.or.k[0].ti) {
                  var i2;
                  var len = data.or.k.length;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    data.or.k[i2].to = null;
                    data.or.k[i2].ti = null;
                  }
                }
                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
                this.or.sh = true;
              } else {
                this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
              }
              if (data.sk) {
                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
              }
              this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
              this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
              if (data.o) {
                this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
              } else {
                this.o = { _mdf: false, v: 1 };
              }
              this._isDirty = true;
              if (!this.dynamicProperties.length) {
                this.getValue(true);
              }
            }
            TransformProperty.prototype = {
              applyToMatrix,
              getValue: processKeys,
              precalculateMatrix,
              autoOrient
            };
            extendPrototype([DynamicPropertyContainer], TransformProperty);
            TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
            TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
            function getTransformProperty(elem, data, container) {
              return new TransformProperty(elem, data, container);
            }
            return {
              getTransformProperty
            };
          }();
          function ShapePath2() {
            this.c = false;
            this._length = 0;
            this._maxLength = 8;
            this.v = createSizedArray(this._maxLength);
            this.o = createSizedArray(this._maxLength);
            this.i = createSizedArray(this._maxLength);
          }
          ShapePath2.prototype.setPathData = function(closed, len) {
            this.c = closed;
            this.setLength(len);
            var i2 = 0;
            while (i2 < len) {
              this.v[i2] = pointPool.newElement();
              this.o[i2] = pointPool.newElement();
              this.i[i2] = pointPool.newElement();
              i2 += 1;
            }
          };
          ShapePath2.prototype.setLength = function(len) {
            while (this._maxLength < len) {
              this.doubleArrayLength();
            }
            this._length = len;
          };
          ShapePath2.prototype.doubleArrayLength = function() {
            this.v = this.v.concat(createSizedArray(this._maxLength));
            this.i = this.i.concat(createSizedArray(this._maxLength));
            this.o = this.o.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
          };
          ShapePath2.prototype.setXYAt = function(x, y, type, pos, replace) {
            var arr;
            this._length = Math.max(this._length, pos + 1);
            if (this._length >= this._maxLength) {
              this.doubleArrayLength();
            }
            switch (type) {
              case "v":
                arr = this.v;
                break;
              case "i":
                arr = this.i;
                break;
              case "o":
                arr = this.o;
                break;
              default:
                arr = [];
                break;
            }
            if (!arr[pos] || arr[pos] && !replace) {
              arr[pos] = pointPool.newElement();
            }
            arr[pos][0] = x;
            arr[pos][1] = y;
          };
          ShapePath2.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
            this.setXYAt(vX, vY, "v", pos, replace);
            this.setXYAt(oX, oY, "o", pos, replace);
            this.setXYAt(iX, iY, "i", pos, replace);
          };
          ShapePath2.prototype.reverse = function() {
            var newPath = new ShapePath2();
            newPath.setPathData(this.c, this._length);
            var vertices = this.v;
            var outPoints = this.o;
            var inPoints = this.i;
            var init6 = 0;
            if (this.c) {
              newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
              init6 = 1;
            }
            var cnt = this._length - 1;
            var len = this._length;
            var i2;
            for (i2 = init6; i2 < len; i2 += 1) {
              newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i2, false);
              cnt -= 1;
            }
            return newPath;
          };
          var ShapePropertyFactory = function() {
            var initFrame = -999999;
            function interpolateShape(frameNum, previousValue, caching) {
              var iterationIndex = caching.lastIndex;
              var keyPropS;
              var keyPropE;
              var isHold;
              var j;
              var k;
              var jLen;
              var kLen;
              var perc;
              var vertexValue;
              var kf = this.keyframes;
              if (frameNum < kf[0].t - this.offsetTime) {
                keyPropS = kf[0].s[0];
                isHold = true;
                iterationIndex = 0;
              } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
                isHold = true;
              } else {
                var i2 = iterationIndex;
                var len = kf.length - 1;
                var flag = true;
                var keyData;
                var nextKeyData;
                var keyframeMetadata;
                while (flag) {
                  keyData = kf[i2];
                  nextKeyData = kf[i2 + 1];
                  if (nextKeyData.t - this.offsetTime > frameNum) {
                    break;
                  }
                  if (i2 < len - 1) {
                    i2 += 1;
                  } else {
                    flag = false;
                  }
                }
                keyframeMetadata = this.keyframesMetadata[i2] || {};
                isHold = keyData.h === 1;
                iterationIndex = i2;
                if (!isHold) {
                  if (frameNum >= nextKeyData.t - this.offsetTime) {
                    perc = 1;
                  } else if (frameNum < keyData.t - this.offsetTime) {
                    perc = 0;
                  } else {
                    var fnc;
                    if (keyframeMetadata.__fnct) {
                      fnc = keyframeMetadata.__fnct;
                    } else {
                      fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                      keyframeMetadata.__fnct = fnc;
                    }
                    perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                  }
                  keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                }
                keyPropS = keyData.s[0];
              }
              jLen = previousValue._length;
              kLen = keyPropS.i[0].length;
              caching.lastIndex = iterationIndex;
              for (j = 0; j < jLen; j += 1) {
                for (k = 0; k < kLen; k += 1) {
                  vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
                  previousValue.i[j][k] = vertexValue;
                  vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
                  previousValue.o[j][k] = vertexValue;
                  vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
                  previousValue.v[j][k] = vertexValue;
                }
              }
            }
            function interpolateShapeCurrentTime() {
              var frameNum = this.comp.renderedFrame - this.offsetTime;
              var initTime = this.keyframes[0].t - this.offsetTime;
              var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              var lastFrame = this._caching.lastFrame;
              if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
                this.interpolateShape(frameNum, this.pv, this._caching);
              }
              this._caching.lastFrame = frameNum;
              return this.pv;
            }
            function resetShape() {
              this.paths = this.localShapeCollection;
            }
            function shapesEqual(shape1, shape2) {
              if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
                return false;
              }
              var i2;
              var len = shape1._length;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (shape1.v[i2][0] !== shape2.v[i2][0] || shape1.v[i2][1] !== shape2.v[i2][1] || shape1.o[i2][0] !== shape2.o[i2][0] || shape1.o[i2][1] !== shape2.o[i2][1] || shape1.i[i2][0] !== shape2.i[i2][0] || shape1.i[i2][1] !== shape2.i[i2][1]) {
                  return false;
                }
              }
              return true;
            }
            function setVValue(newPath) {
              if (!shapesEqual(this.v, newPath)) {
                this.v = shapePool.clone(newPath);
                this.localShapeCollection.releaseShapes();
                this.localShapeCollection.addShape(this.v);
                this._mdf = true;
                this.paths = this.localShapeCollection;
              }
            }
            function processEffectsSequence() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              if (!this.effectsSequence.length) {
                this._mdf = false;
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              this.lock = true;
              this._mdf = false;
              var finalValue;
              if (this.kf) {
                finalValue = this.pv;
              } else if (this.data.ks) {
                finalValue = this.data.ks.k;
              } else {
                finalValue = this.data.pt.k;
              }
              var i2;
              var len = this.effectsSequence.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                finalValue = this.effectsSequence[i2](finalValue);
              }
              this.setVValue(finalValue);
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            }
            function ShapeProperty(elem, data, type) {
              this.propType = "shape";
              this.comp = elem.comp;
              this.container = elem;
              this.elem = elem;
              this.data = data;
              this.k = false;
              this.kf = false;
              this._mdf = false;
              var pathData = type === 3 ? data.pt.k : data.ks.k;
              this.v = shapePool.clone(pathData);
              this.pv = shapePool.clone(this.v);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.paths.addShape(this.v);
              this.reset = resetShape;
              this.effectsSequence = [];
            }
            function addEffect(effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.container.addDynamicProperty(this);
            }
            ShapeProperty.prototype.interpolateShape = interpolateShape;
            ShapeProperty.prototype.getValue = processEffectsSequence;
            ShapeProperty.prototype.setVValue = setVValue;
            ShapeProperty.prototype.addEffect = addEffect;
            function KeyframedShapeProperty(elem, data, type) {
              this.propType = "shape";
              this.comp = elem.comp;
              this.elem = elem;
              this.container = elem;
              this.offsetTime = elem.data.st;
              this.keyframes = type === 3 ? data.pt.k : data.ks.k;
              this.keyframesMetadata = [];
              this.k = true;
              this.kf = true;
              var len = this.keyframes[0].s[0].i.length;
              this.v = shapePool.newElement();
              this.v.setPathData(this.keyframes[0].s[0].c, len);
              this.pv = shapePool.clone(this.v);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.paths.addShape(this.v);
              this.lastFrame = initFrame;
              this.reset = resetShape;
              this._caching = { lastFrame: initFrame, lastIndex: 0 };
              this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
            }
            KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
            KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
            KeyframedShapeProperty.prototype.setVValue = setVValue;
            KeyframedShapeProperty.prototype.addEffect = addEffect;
            var EllShapeProperty = function() {
              var cPoint = roundCorner;
              function EllShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 4);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.localShapeCollection.addShape(this.v);
                this.d = data.d;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertEllToPath();
                }
              }
              EllShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }
                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();
                  if (this._mdf) {
                    this.convertEllToPath();
                  }
                },
                convertEllToPath: function() {
                  var p0 = this.p.v[0];
                  var p1 = this.p.v[1];
                  var s0 = this.s.v[0] / 2;
                  var s1 = this.s.v[1] / 2;
                  var _cw = this.d !== 3;
                  var _v = this.v;
                  _v.v[0][0] = p0;
                  _v.v[0][1] = p1 - s1;
                  _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.v[1][1] = p1;
                  _v.v[2][0] = p0;
                  _v.v[2][1] = p1 + s1;
                  _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.v[3][1] = p1;
                  _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                  _v.i[0][1] = p1 - s1;
                  _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.i[1][1] = p1 - s1 * cPoint;
                  _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                  _v.i[2][1] = p1 + s1;
                  _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.i[3][1] = p1 + s1 * cPoint;
                  _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                  _v.o[0][1] = p1 - s1;
                  _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.o[1][1] = p1 + s1 * cPoint;
                  _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                  _v.o[2][1] = p1 + s1;
                  _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.o[3][1] = p1 - s1 * cPoint;
                }
              };
              extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
              return EllShapePropertyFactory;
            }();
            var StarShapeProperty = function() {
              function StarShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 0);
                this.elem = elem;
                this.comp = elem.comp;
                this.data = data;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                if (data.sy === 1) {
                  this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                  this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
                  this.convertToPath = this.convertStarToPath;
                } else {
                  this.convertToPath = this.convertPolygonToPath;
                }
                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertToPath();
                }
              }
              StarShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }
                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();
                  if (this._mdf) {
                    this.convertToPath();
                  }
                },
                convertStarToPath: function() {
                  var numPts = Math.floor(this.pt.v) * 2;
                  var angle = Math.PI * 2 / numPts;
                  var longFlag = true;
                  var longRad = this.or.v;
                  var shortRad = this.ir.v;
                  var longRound = this.os.v;
                  var shortRound = this.is.v;
                  var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                  var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                  var i2;
                  var rad;
                  var roundness;
                  var perimSegment;
                  var currentAng = -Math.PI / 2;
                  currentAng += this.r.v;
                  var dir = this.data.d === 3 ? -1 : 1;
                  this.v._length = 0;
                  for (i2 = 0; i2 < numPts; i2 += 1) {
                    rad = longFlag ? longRad : shortRad;
                    roundness = longFlag ? longRound : shortRound;
                    perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                    var x = rad * Math.cos(currentAng);
                    var y = rad * Math.sin(currentAng);
                    var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                    var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                    x += +this.p.v[0];
                    y += +this.p.v[1];
                    this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i2, true);
                    longFlag = !longFlag;
                    currentAng += angle * dir;
                  }
                },
                convertPolygonToPath: function() {
                  var numPts = Math.floor(this.pt.v);
                  var angle = Math.PI * 2 / numPts;
                  var rad = this.or.v;
                  var roundness = this.os.v;
                  var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                  var i2;
                  var currentAng = -Math.PI * 0.5;
                  var dir = this.data.d === 3 ? -1 : 1;
                  currentAng += this.r.v;
                  this.v._length = 0;
                  for (i2 = 0; i2 < numPts; i2 += 1) {
                    var x = rad * Math.cos(currentAng);
                    var y = rad * Math.sin(currentAng);
                    var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                    var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                    x += +this.p.v[0];
                    y += +this.p.v[1];
                    this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i2, true);
                    currentAng += angle * dir;
                  }
                  this.paths.length = 0;
                  this.paths[0] = this.v;
                }
              };
              extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
              return StarShapePropertyFactory;
            }();
            var RectShapeProperty = function() {
              function RectShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.c = true;
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertRectToPath();
                }
              }
              RectShapePropertyFactory.prototype = {
                convertRectToPath: function() {
                  var p0 = this.p.v[0];
                  var p1 = this.p.v[1];
                  var v0 = this.s.v[0] / 2;
                  var v1 = this.s.v[1] / 2;
                  var round = bmMin(v0, v1, this.r.v);
                  var cPoint = round * (1 - roundCorner);
                  this.v._length = 0;
                  if (this.d === 2 || this.d === 1) {
                    this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                    if (round !== 0) {
                      this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                      this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                      this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                      this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                      this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                      this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                    } else {
                      this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                      this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                    }
                  } else {
                    this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                    if (round !== 0) {
                      this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                      this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                      this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                      this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                      this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                      this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                      this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                    } else {
                      this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                      this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                      this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                    }
                  }
                },
                getValue: function() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }
                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();
                  if (this._mdf) {
                    this.convertRectToPath();
                  }
                },
                reset: resetShape
              };
              extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
              return RectShapePropertyFactory;
            }();
            function getShapeProp(elem, data, type) {
              var prop;
              if (type === 3 || type === 4) {
                var dataProp = type === 3 ? data.pt : data.ks;
                var keys = dataProp.k;
                if (keys.length) {
                  prop = new KeyframedShapeProperty(elem, data, type);
                } else {
                  prop = new ShapeProperty(elem, data, type);
                }
              } else if (type === 5) {
                prop = new RectShapeProperty(elem, data);
              } else if (type === 6) {
                prop = new EllShapeProperty(elem, data);
              } else if (type === 7) {
                prop = new StarShapeProperty(elem, data);
              }
              if (prop.k) {
                elem.addDynamicProperty(prop);
              }
              return prop;
            }
            function getConstructorFunction() {
              return ShapeProperty;
            }
            function getKeyframedConstructorFunction() {
              return KeyframedShapeProperty;
            }
            var ob = {};
            ob.getShapeProp = getShapeProp;
            ob.getConstructorFunction = getConstructorFunction;
            ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
            return ob;
          }();
          var ShapeModifiers = function() {
            var ob = {};
            var modifiers = {};
            ob.registerModifier = registerModifier;
            ob.getModifier = getModifier;
            function registerModifier(nm, factory) {
              if (!modifiers[nm]) {
                modifiers[nm] = factory;
              }
            }
            function getModifier(nm, elem, data) {
              return new modifiers[nm](elem, data);
            }
            return ob;
          }();
          function ShapeModifier() {
          }
          ShapeModifier.prototype.initModifierProperties = function() {
          };
          ShapeModifier.prototype.addShapeToModifier = function() {
          };
          ShapeModifier.prototype.addShape = function(data) {
            if (!this.closed) {
              data.sh.container.addDynamicProperty(data.sh);
              var shapeData = { shape: data.sh, data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
              this.shapes.push(shapeData);
              this.addShapeToModifier(shapeData);
              if (this._isAnimated) {
                data.setAsAnimated();
              }
            }
          };
          ShapeModifier.prototype.init = function(elem, data) {
            this.shapes = [];
            this.elem = elem;
            this.initDynamicPropertyContainer(elem);
            this.initModifierProperties(elem, data);
            this.frameId = initialDefaultFrame;
            this.closed = false;
            this.k = false;
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.getValue(true);
            }
          };
          ShapeModifier.prototype.processKeys = function() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
          };
          extendPrototype([DynamicPropertyContainer], ShapeModifier);
          function TrimModifier() {
          }
          extendPrototype([ShapeModifier], TrimModifier);
          TrimModifier.prototype.initModifierProperties = function(elem, data) {
            this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
            this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
            this.sValue = 0;
            this.eValue = 0;
            this.getValue = this.processKeys;
            this.m = data.m;
            this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
          };
          TrimModifier.prototype.addShapeToModifier = function(shapeData) {
            shapeData.pathsData = [];
          };
          TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
            var segments = [];
            if (e <= 1) {
              segments.push({
                s,
                e
              });
            } else if (s >= 1) {
              segments.push({
                s: s - 1,
                e: e - 1
              });
            } else {
              segments.push({
                s,
                e: 1
              });
              segments.push({
                s: 0,
                e: e - 1
              });
            }
            var shapeSegments = [];
            var i2;
            var len = segments.length;
            var segmentOb;
            for (i2 = 0; i2 < len; i2 += 1) {
              segmentOb = segments[i2];
              if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
                var shapeS;
                var shapeE;
                if (segmentOb.s * totalModifierLength <= addedLength) {
                  shapeS = 0;
                } else {
                  shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
                }
                if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                  shapeE = 1;
                } else {
                  shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
                }
                shapeSegments.push([shapeS, shapeE]);
              }
            }
            if (!shapeSegments.length) {
              shapeSegments.push([0, 0]);
            }
            return shapeSegments;
          };
          TrimModifier.prototype.releasePathsData = function(pathsData) {
            var i2;
            var len = pathsData.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              segmentsLengthPool.release(pathsData[i2]);
            }
            pathsData.length = 0;
            return pathsData;
          };
          TrimModifier.prototype.processShapes = function(_isFirstFrame) {
            var s;
            var e;
            if (this._mdf || _isFirstFrame) {
              var o = this.o.v % 360 / 360;
              if (o < 0) {
                o += 1;
              }
              if (this.s.v > 1) {
                s = 1 + o;
              } else if (this.s.v < 0) {
                s = 0 + o;
              } else {
                s = this.s.v + o;
              }
              if (this.e.v > 1) {
                e = 1 + o;
              } else if (this.e.v < 0) {
                e = 0 + o;
              } else {
                e = this.e.v + o;
              }
              if (s > e) {
                var _s = s;
                s = e;
                e = _s;
              }
              s = Math.round(s * 1e4) * 1e-4;
              e = Math.round(e * 1e4) * 1e-4;
              this.sValue = s;
              this.eValue = e;
            } else {
              s = this.sValue;
              e = this.eValue;
            }
            var shapePaths;
            var i2;
            var len = this.shapes.length;
            var j;
            var jLen;
            var pathsData;
            var pathData;
            var totalShapeLength;
            var totalModifierLength = 0;
            if (e === s) {
              for (i2 = 0; i2 < len; i2 += 1) {
                this.shapes[i2].localShapeCollection.releaseShapes();
                this.shapes[i2].shape._mdf = true;
                this.shapes[i2].shape.paths = this.shapes[i2].localShapeCollection;
                if (this._mdf) {
                  this.shapes[i2].pathsData.length = 0;
                }
              }
            } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
              var segments = [];
              var shapeData;
              var localShapeCollection;
              for (i2 = 0; i2 < len; i2 += 1) {
                shapeData = this.shapes[i2];
                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                  shapeData.shape.paths = shapeData.localShapeCollection;
                } else {
                  shapePaths = shapeData.shape.paths;
                  jLen = shapePaths._length;
                  totalShapeLength = 0;
                  if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                    totalShapeLength = shapeData.totalShapeLength;
                  } else {
                    pathsData = this.releasePathsData(shapeData.pathsData);
                    for (j = 0; j < jLen; j += 1) {
                      pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                      pathsData.push(pathData);
                      totalShapeLength += pathData.totalLength;
                    }
                    shapeData.totalShapeLength = totalShapeLength;
                    shapeData.pathsData = pathsData;
                  }
                  totalModifierLength += totalShapeLength;
                  shapeData.shape._mdf = true;
                }
              }
              var shapeS = s;
              var shapeE = e;
              var addedLength = 0;
              var edges;
              for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                shapeData = this.shapes[i2];
                if (shapeData.shape._mdf) {
                  localShapeCollection = shapeData.localShapeCollection;
                  localShapeCollection.releaseShapes();
                  if (this.m === 2 && len > 1) {
                    edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                    addedLength += shapeData.totalShapeLength;
                  } else {
                    edges = [[shapeS, shapeE]];
                  }
                  jLen = edges.length;
                  for (j = 0; j < jLen; j += 1) {
                    shapeS = edges[j][0];
                    shapeE = edges[j][1];
                    segments.length = 0;
                    if (shapeE <= 1) {
                      segments.push({
                        s: shapeData.totalShapeLength * shapeS,
                        e: shapeData.totalShapeLength * shapeE
                      });
                    } else if (shapeS >= 1) {
                      segments.push({
                        s: shapeData.totalShapeLength * (shapeS - 1),
                        e: shapeData.totalShapeLength * (shapeE - 1)
                      });
                    } else {
                      segments.push({
                        s: shapeData.totalShapeLength * shapeS,
                        e: shapeData.totalShapeLength
                      });
                      segments.push({
                        s: 0,
                        e: shapeData.totalShapeLength * (shapeE - 1)
                      });
                    }
                    var newShapesData = this.addShapes(shapeData, segments[0]);
                    if (segments[0].s !== segments[0].e) {
                      if (segments.length > 1) {
                        var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                        if (lastShapeInCollection.c) {
                          var lastShape = newShapesData.pop();
                          this.addPaths(newShapesData, localShapeCollection);
                          newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                        } else {
                          this.addPaths(newShapesData, localShapeCollection);
                          newShapesData = this.addShapes(shapeData, segments[1]);
                        }
                      }
                      this.addPaths(newShapesData, localShapeCollection);
                    }
                  }
                  shapeData.shape.paths = localShapeCollection;
                }
              }
            } else if (this._mdf) {
              for (i2 = 0; i2 < len; i2 += 1) {
                this.shapes[i2].pathsData.length = 0;
                this.shapes[i2].shape._mdf = true;
              }
            }
          };
          TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
            var i2;
            var len = newPaths.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              localShapeCollection.addShape(newPaths[i2]);
            }
          };
          TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
            shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
            shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
            if (newShape) {
              shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
            }
            shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
          };
          TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
            shapePath.setXYAt(points[1], points[5], "o", pos);
            shapePath.setXYAt(points[2], points[6], "i", pos + 1);
            if (newShape) {
              shapePath.setXYAt(points[0], points[4], "v", pos);
            }
            shapePath.setXYAt(points[3], points[7], "v", pos + 1);
          };
          TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
            var pathsData = shapeData.pathsData;
            var shapePaths = shapeData.shape.paths.shapes;
            var i2;
            var len = shapeData.shape.paths._length;
            var j;
            var jLen;
            var addedLength = 0;
            var currentLengthData;
            var segmentCount;
            var lengths;
            var segment;
            var shapes = [];
            var initPos;
            var newShape = true;
            if (!shapePath) {
              shapePath = shapePool.newElement();
              segmentCount = 0;
              initPos = 0;
            } else {
              segmentCount = shapePath._length;
              initPos = shapePath._length;
            }
            shapes.push(shapePath);
            for (i2 = 0; i2 < len; i2 += 1) {
              lengths = pathsData[i2].lengths;
              shapePath.c = shapePaths[i2].c;
              jLen = shapePaths[i2].c ? lengths.length : lengths.length + 1;
              for (j = 1; j < jLen; j += 1) {
                currentLengthData = lengths[j - 1];
                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                  addedLength += currentLengthData.addedLength;
                  shapePath.c = false;
                } else if (addedLength > shapeSegment.e) {
                  shapePath.c = false;
                  break;
                } else {
                  if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                    this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], shapePaths[i2].v[j], shapePath, segmentCount, newShape);
                    newShape = false;
                  } else {
                    segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[j], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                    newShape = false;
                    shapePath.c = false;
                  }
                  addedLength += currentLengthData.addedLength;
                  segmentCount += 1;
                }
              }
              if (shapePaths[i2].c && lengths.length) {
                currentLengthData = lengths[j - 1];
                if (addedLength <= shapeSegment.e) {
                  var segmentLength = lengths[j - 1].addedLength;
                  if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                    this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], shapePaths[i2].v[0], shapePath, segmentCount, newShape);
                    newShape = false;
                  } else {
                    segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[0], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                    newShape = false;
                    shapePath.c = false;
                  }
                } else {
                  shapePath.c = false;
                }
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
              }
              if (shapePath._length) {
                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
              }
              if (addedLength > shapeSegment.e) {
                break;
              }
              if (i2 < len - 1) {
                shapePath = shapePool.newElement();
                newShape = true;
                shapes.push(shapePath);
                segmentCount = 0;
              }
            }
            return shapes;
          };
          ShapeModifiers.registerModifier("tm", TrimModifier);
          function RoundCornersModifier() {
          }
          extendPrototype([ShapeModifier], RoundCornersModifier);
          RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {
            this.getValue = this.processKeys;
            this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
            this._isAnimated = !!this.rd.effectsSequence.length;
          };
          RoundCornersModifier.prototype.processPath = function(path, round) {
            var clonedPath = shapePool.newElement();
            clonedPath.c = path.c;
            var i2;
            var len = path._length;
            var currentV;
            var currentI;
            var currentO;
            var closerV;
            var distance;
            var newPosPerc;
            var index3 = 0;
            var vX;
            var vY;
            var oX;
            var oY;
            var iX;
            var iY;
            for (i2 = 0; i2 < len; i2 += 1) {
              currentV = path.v[i2];
              currentO = path.o[i2];
              currentI = path.i[i2];
              if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
                if ((i2 === 0 || i2 === len - 1) && !path.c) {
                  clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index3);
                  index3 += 1;
                } else {
                  if (i2 === 0) {
                    closerV = path.v[len - 1];
                  } else {
                    closerV = path.v[i2 - 1];
                  }
                  distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                  newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                  iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                  vX = iX;
                  iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                  vY = iY;
                  oX = vX - (vX - currentV[0]) * roundCorner;
                  oY = vY - (vY - currentV[1]) * roundCorner;
                  clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index3);
                  index3 += 1;
                  if (i2 === len - 1) {
                    closerV = path.v[0];
                  } else {
                    closerV = path.v[i2 + 1];
                  }
                  distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                  newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                  oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                  vX = oX;
                  oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                  vY = oY;
                  iX = vX - (vX - currentV[0]) * roundCorner;
                  iY = vY - (vY - currentV[1]) * roundCorner;
                  clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index3);
                  index3 += 1;
                }
              } else {
                clonedPath.setTripleAt(path.v[i2][0], path.v[i2][1], path.o[i2][0], path.o[i2][1], path.i[i2][0], path.i[i2][1], index3);
                index3 += 1;
              }
            }
            return clonedPath;
          };
          RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
            var shapePaths;
            var i2;
            var len = this.shapes.length;
            var j;
            var jLen;
            var rd = this.rd.v;
            if (rd !== 0) {
              var shapeData;
              var localShapeCollection;
              for (i2 = 0; i2 < len; i2 += 1) {
                shapeData = this.shapes[i2];
                localShapeCollection = shapeData.localShapeCollection;
                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                  localShapeCollection.releaseShapes();
                  shapeData.shape._mdf = true;
                  shapePaths = shapeData.shape.paths.shapes;
                  jLen = shapeData.shape.paths._length;
                  for (j = 0; j < jLen; j += 1) {
                    localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
                  }
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
              }
            }
            if (!this.dynamicProperties.length) {
              this._mdf = false;
            }
          };
          ShapeModifiers.registerModifier("rd", RoundCornersModifier);
          function PuckerAndBloatModifier() {
          }
          extendPrototype([ShapeModifier], PuckerAndBloatModifier);
          PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {
            this.getValue = this.processKeys;
            this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
            this._isAnimated = !!this.amount.effectsSequence.length;
          };
          PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
            var percent = amount / 100;
            var centerPoint = [0, 0];
            var pathLength = path._length;
            var i2 = 0;
            for (i2 = 0; i2 < pathLength; i2 += 1) {
              centerPoint[0] += path.v[i2][0];
              centerPoint[1] += path.v[i2][1];
            }
            centerPoint[0] /= pathLength;
            centerPoint[1] /= pathLength;
            var clonedPath = shapePool.newElement();
            clonedPath.c = path.c;
            var vX;
            var vY;
            var oX;
            var oY;
            var iX;
            var iY;
            for (i2 = 0; i2 < pathLength; i2 += 1) {
              vX = path.v[i2][0] + (centerPoint[0] - path.v[i2][0]) * percent;
              vY = path.v[i2][1] + (centerPoint[1] - path.v[i2][1]) * percent;
              oX = path.o[i2][0] + (centerPoint[0] - path.o[i2][0]) * -percent;
              oY = path.o[i2][1] + (centerPoint[1] - path.o[i2][1]) * -percent;
              iX = path.i[i2][0] + (centerPoint[0] - path.i[i2][0]) * -percent;
              iY = path.i[i2][1] + (centerPoint[1] - path.i[i2][1]) * -percent;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i2);
            }
            return clonedPath;
          };
          PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
            var shapePaths;
            var i2;
            var len = this.shapes.length;
            var j;
            var jLen;
            var amount = this.amount.v;
            if (amount !== 0) {
              var shapeData;
              var localShapeCollection;
              for (i2 = 0; i2 < len; i2 += 1) {
                shapeData = this.shapes[i2];
                localShapeCollection = shapeData.localShapeCollection;
                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                  localShapeCollection.releaseShapes();
                  shapeData.shape._mdf = true;
                  shapePaths = shapeData.shape.paths.shapes;
                  jLen = shapeData.shape.paths._length;
                  for (j = 0; j < jLen; j += 1) {
                    localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                  }
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
              }
            }
            if (!this.dynamicProperties.length) {
              this._mdf = false;
            }
          };
          ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
          function RepeaterModifier() {
          }
          extendPrototype([ShapeModifier], RepeaterModifier);
          RepeaterModifier.prototype.initModifierProperties = function(elem, data) {
            this.getValue = this.processKeys;
            this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
            this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
            this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
            this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
            this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
            this.data = data;
            if (!this.dynamicProperties.length) {
              this.getValue(true);
            }
            this._isAnimated = !!this.dynamicProperties.length;
            this.pMatrix = new Matrix();
            this.rMatrix = new Matrix();
            this.sMatrix = new Matrix();
            this.tMatrix = new Matrix();
            this.matrix = new Matrix();
          };
          RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform3, perc, inv) {
            var dir = inv ? -1 : 1;
            var scaleX = transform3.s.v[0] + (1 - transform3.s.v[0]) * (1 - perc);
            var scaleY = transform3.s.v[1] + (1 - transform3.s.v[1]) * (1 - perc);
            pMatrix.translate(transform3.p.v[0] * dir * perc, transform3.p.v[1] * dir * perc, transform3.p.v[2]);
            rMatrix.translate(-transform3.a.v[0], -transform3.a.v[1], transform3.a.v[2]);
            rMatrix.rotate(-transform3.r.v * dir * perc);
            rMatrix.translate(transform3.a.v[0], transform3.a.v[1], transform3.a.v[2]);
            sMatrix.translate(-transform3.a.v[0], -transform3.a.v[1], transform3.a.v[2]);
            sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
            sMatrix.translate(transform3.a.v[0], transform3.a.v[1], transform3.a.v[2]);
          };
          RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
            this.elem = elem;
            this.arr = arr;
            this.pos = pos;
            this.elemsData = elemsData;
            this._currentCopies = 0;
            this._elements = [];
            this._groups = [];
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem);
            this.initModifierProperties(elem, arr[pos]);
            while (pos > 0) {
              pos -= 1;
              this._elements.unshift(arr[pos]);
            }
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.getValue(true);
            }
          };
          RepeaterModifier.prototype.resetElements = function(elements) {
            var i2;
            var len = elements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              elements[i2]._processed = false;
              if (elements[i2].ty === "gr") {
                this.resetElements(elements[i2].it);
              }
            }
          };
          RepeaterModifier.prototype.cloneElements = function(elements) {
            var newElements = JSON.parse(JSON.stringify(elements));
            this.resetElements(newElements);
            return newElements;
          };
          RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
            var i2;
            var len = elements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              elements[i2]._render = renderFlag;
              if (elements[i2].ty === "gr") {
                this.changeGroupRender(elements[i2].it, renderFlag);
              }
            }
          };
          RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
            var items;
            var itemsTransform;
            var i2;
            var dir;
            var cont;
            var hasReloaded = false;
            if (this._mdf || _isFirstFrame) {
              var copies = Math.ceil(this.c.v);
              if (this._groups.length < copies) {
                while (this._groups.length < copies) {
                  var group = {
                    it: this.cloneElements(this._elements),
                    ty: "gr"
                  };
                  group.it.push({
                    a: { a: 0, ix: 1, k: [0, 0] },
                    nm: "Transform",
                    o: { a: 0, ix: 7, k: 100 },
                    p: { a: 0, ix: 2, k: [0, 0] },
                    r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] },
                    s: { a: 0, ix: 3, k: [100, 100] },
                    sa: { a: 0, ix: 5, k: 0 },
                    sk: { a: 0, ix: 4, k: 0 },
                    ty: "tr"
                  });
                  this.arr.splice(0, 0, group);
                  this._groups.splice(0, 0, group);
                  this._currentCopies += 1;
                }
                this.elem.reloadShapes();
                hasReloaded = true;
              }
              cont = 0;
              var renderFlag;
              for (i2 = 0; i2 <= this._groups.length - 1; i2 += 1) {
                renderFlag = cont < copies;
                this._groups[i2]._render = renderFlag;
                this.changeGroupRender(this._groups[i2].it, renderFlag);
                if (!renderFlag) {
                  var elems = this.elemsData[i2].it;
                  var transformData = elems[elems.length - 1];
                  if (transformData.transform.op.v !== 0) {
                    transformData.transform.op._mdf = true;
                    transformData.transform.op.v = 0;
                  } else {
                    transformData.transform.op._mdf = false;
                  }
                }
                cont += 1;
              }
              this._currentCopies = copies;
              var offset2 = this.o.v;
              var offsetModulo = offset2 % 1;
              var roundOffset = offset2 > 0 ? Math.floor(offset2) : Math.ceil(offset2);
              var pProps = this.pMatrix.props;
              var rProps = this.rMatrix.props;
              var sProps = this.sMatrix.props;
              this.pMatrix.reset();
              this.rMatrix.reset();
              this.sMatrix.reset();
              this.tMatrix.reset();
              this.matrix.reset();
              var iteration = 0;
              if (offset2 > 0) {
                while (iteration < roundOffset) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                  iteration += 1;
                }
                if (offsetModulo) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                  iteration += offsetModulo;
                }
              } else if (offset2 < 0) {
                while (iteration > roundOffset) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                  iteration -= 1;
                }
                if (offsetModulo) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                  iteration -= offsetModulo;
                }
              }
              i2 = this.data.m === 1 ? 0 : this._currentCopies - 1;
              dir = this.data.m === 1 ? 1 : -1;
              cont = this._currentCopies;
              var j;
              var jLen;
              while (cont) {
                items = this.elemsData[i2].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                jLen = itemsTransform.length;
                items[items.length - 1].transform.mProps._mdf = true;
                items[items.length - 1].transform.op._mdf = true;
                items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i2 / (this._currentCopies - 1));
                if (iteration !== 0) {
                  if (i2 !== 0 && dir === 1 || i2 !== this._currentCopies - 1 && dir === -1) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                  }
                  this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                  this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                  this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                  for (j = 0; j < jLen; j += 1) {
                    itemsTransform[j] = this.matrix.props[j];
                  }
                  this.matrix.reset();
                } else {
                  this.matrix.reset();
                  for (j = 0; j < jLen; j += 1) {
                    itemsTransform[j] = this.matrix.props[j];
                  }
                }
                iteration += 1;
                cont -= 1;
                i2 += dir;
              }
            } else {
              cont = this._currentCopies;
              i2 = 0;
              dir = 1;
              while (cont) {
                items = this.elemsData[i2].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                items[items.length - 1].transform.mProps._mdf = false;
                items[items.length - 1].transform.op._mdf = false;
                cont -= 1;
                i2 += dir;
              }
            }
            return hasReloaded;
          };
          RepeaterModifier.prototype.addShape = function() {
          };
          ShapeModifiers.registerModifier("rp", RepeaterModifier);
          function ShapeCollection() {
            this._length = 0;
            this._maxLength = 4;
            this.shapes = createSizedArray(this._maxLength);
          }
          ShapeCollection.prototype.addShape = function(shapeData) {
            if (this._length === this._maxLength) {
              this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
              this._maxLength *= 2;
            }
            this.shapes[this._length] = shapeData;
            this._length += 1;
          };
          ShapeCollection.prototype.releaseShapes = function() {
            var i2;
            for (i2 = 0; i2 < this._length; i2 += 1) {
              shapePool.release(this.shapes[i2]);
            }
            this._length = 0;
          };
          function DashProperty(elem, data, renderer2, container) {
            this.elem = elem;
            this.frameId = -1;
            this.dataProps = createSizedArray(data.length);
            this.renderer = renderer2;
            this.k = false;
            this.dashStr = "";
            this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0);
            this.dashoffset = createTypedArray("float32", 1);
            this.initDynamicPropertyContainer(container);
            var i2;
            var len = data.length || 0;
            var prop;
            for (i2 = 0; i2 < len; i2 += 1) {
              prop = PropertyFactory.getProp(elem, data[i2].v, 0, 0, this);
              this.k = prop.k || this.k;
              this.dataProps[i2] = { n: data[i2].n, p: prop };
            }
            if (!this.k) {
              this.getValue(true);
            }
            this._isAnimated = this.k;
          }
          DashProperty.prototype.getValue = function(forceRender) {
            if (this.elem.globalData.frameId === this.frameId && !forceRender) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || forceRender;
            if (this._mdf) {
              var i2 = 0;
              var len = this.dataProps.length;
              if (this.renderer === "svg") {
                this.dashStr = "";
              }
              for (i2 = 0; i2 < len; i2 += 1) {
                if (this.dataProps[i2].n !== "o") {
                  if (this.renderer === "svg") {
                    this.dashStr += " " + this.dataProps[i2].p.v;
                  } else {
                    this.dashArray[i2] = this.dataProps[i2].p.v;
                  }
                } else {
                  this.dashoffset[0] = this.dataProps[i2].p.v;
                }
              }
            }
          };
          extendPrototype([DynamicPropertyContainer], DashProperty);
          function GradientProperty(elem, data, container) {
            this.data = data;
            this.c = createTypedArray("uint8c", data.p * 4);
            var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
            this.o = createTypedArray("float32", cLength);
            this._cmdf = false;
            this._omdf = false;
            this._collapsable = this.checkCollapsable();
            this._hasOpacity = cLength;
            this.initDynamicPropertyContainer(container);
            this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
            this.k = this.prop.k;
            this.getValue(true);
          }
          GradientProperty.prototype.comparePoints = function(values, points) {
            var i2 = 0;
            var len = this.o.length / 2;
            var diff;
            while (i2 < len) {
              diff = Math.abs(values[i2 * 4] - values[points * 4 + i2 * 2]);
              if (diff > 0.01) {
                return false;
              }
              i2 += 1;
            }
            return true;
          };
          GradientProperty.prototype.checkCollapsable = function() {
            if (this.o.length / 2 !== this.c.length / 4) {
              return false;
            }
            if (this.data.k.k[0].s) {
              var i2 = 0;
              var len = this.data.k.k.length;
              while (i2 < len) {
                if (!this.comparePoints(this.data.k.k[i2].s, this.data.p)) {
                  return false;
                }
                i2 += 1;
              }
            } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
              return false;
            }
            return true;
          };
          GradientProperty.prototype.getValue = function(forceRender) {
            this.prop.getValue();
            this._mdf = false;
            this._cmdf = false;
            this._omdf = false;
            if (this.prop._mdf || forceRender) {
              var i2;
              var len = this.data.p * 4;
              var mult;
              var val;
              for (i2 = 0; i2 < len; i2 += 1) {
                mult = i2 % 4 === 0 ? 100 : 255;
                val = Math.round(this.prop.v[i2] * mult);
                if (this.c[i2] !== val) {
                  this.c[i2] = val;
                  this._cmdf = !forceRender;
                }
              }
              if (this.o.length) {
                len = this.prop.v.length;
                for (i2 = this.data.p * 4; i2 < len; i2 += 1) {
                  mult = i2 % 2 === 0 ? 100 : 1;
                  val = i2 % 2 === 0 ? Math.round(this.prop.v[i2] * 100) : this.prop.v[i2];
                  if (this.o[i2 - this.data.p * 4] !== val) {
                    this.o[i2 - this.data.p * 4] = val;
                    this._omdf = !forceRender;
                  }
                }
              }
              this._mdf = !forceRender;
            }
          };
          extendPrototype([DynamicPropertyContainer], GradientProperty);
          var buildShapeString = function(pathNodes, length, closed, mat) {
            if (length === 0) {
              return "";
            }
            var _o = pathNodes.o;
            var _i = pathNodes.i;
            var _v = pathNodes.v;
            var i2;
            var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            for (i2 = 1; i2 < length; i2 += 1) {
              shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[i2][0], _i[i2][1]) + " " + mat.applyToPointStringified(_v[i2][0], _v[i2][1]);
            }
            if (closed && length) {
              shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
              shapeString += "z";
            }
            return shapeString;
          };
          var audioControllerFactory = function() {
            function AudioController(audioFactory) {
              this.audios = [];
              this.audioFactory = audioFactory;
              this._volume = 1;
              this._isMuted = false;
            }
            AudioController.prototype = {
              addAudio: function(audio) {
                this.audios.push(audio);
              },
              pause: function() {
                var i2;
                var len = this.audios.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  this.audios[i2].pause();
                }
              },
              resume: function() {
                var i2;
                var len = this.audios.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  this.audios[i2].resume();
                }
              },
              setRate: function(rateValue) {
                var i2;
                var len = this.audios.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  this.audios[i2].setRate(rateValue);
                }
              },
              createAudio: function(assetPath) {
                if (this.audioFactory) {
                  return this.audioFactory(assetPath);
                }
                if (Howl) {
                  return new Howl({
                    src: [assetPath]
                  });
                }
                return {
                  isPlaying: false,
                  play: function() {
                    this.isPlaying = true;
                  },
                  seek: function() {
                    this.isPlaying = false;
                  },
                  playing: function() {
                  },
                  rate: function() {
                  },
                  setVolume: function() {
                  }
                };
              },
              setAudioFactory: function(audioFactory) {
                this.audioFactory = audioFactory;
              },
              setVolume: function(value) {
                this._volume = value;
                this._updateVolume();
              },
              mute: function() {
                this._isMuted = true;
                this._updateVolume();
              },
              unmute: function() {
                this._isMuted = false;
                this._updateVolume();
              },
              getVolume: function() {
                return this._volume;
              },
              _updateVolume: function() {
                var i2;
                var len = this.audios.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  this.audios[i2].volume(this._volume * (this._isMuted ? 0 : 1));
                }
              }
            };
            return function() {
              return new AudioController();
            };
          }();
          var ImagePreloader = function() {
            var proxyImage = function() {
              var canvas = createTag("canvas");
              canvas.width = 1;
              canvas.height = 1;
              var ctx = canvas.getContext("2d");
              ctx.fillStyle = "rgba(0,0,0,0)";
              ctx.fillRect(0, 0, 1, 1);
              return canvas;
            }();
            function imageLoaded() {
              this.loadedAssets += 1;
              if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                if (this.imagesLoadedCb) {
                  this.imagesLoadedCb(null);
                }
              }
            }
            function footageLoaded() {
              this.loadedFootagesCount += 1;
              if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                if (this.imagesLoadedCb) {
                  this.imagesLoadedCb(null);
                }
              }
            }
            function getAssetsPath(assetData, assetsPath, originalPath) {
              var path = "";
              if (assetData.e) {
                path = assetData.p;
              } else if (assetsPath) {
                var imagePath = assetData.p;
                if (imagePath.indexOf("images/") !== -1) {
                  imagePath = imagePath.split("/")[1];
                }
                path = assetsPath + imagePath;
              } else {
                path = originalPath;
                path += assetData.u ? assetData.u : "";
                path += assetData.p;
              }
              return path;
            }
            function testImageLoaded(img) {
              var _count = 0;
              var intervalId = setInterval(function() {
                var box = img.getBBox();
                if (box.width || _count > 500) {
                  this._imageLoaded();
                  clearInterval(intervalId);
                }
                _count += 1;
              }.bind(this), 50);
            }
            function createImageData(assetData) {
              var path = getAssetsPath(assetData, this.assetsPath, this.path);
              var img = createNS("image");
              if (isSafari) {
                this.testImageLoaded(img);
              } else {
                img.addEventListener("load", this._imageLoaded, false);
              }
              img.addEventListener("error", function() {
                ob.img = proxyImage;
                this._imageLoaded();
              }.bind(this), false);
              img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
              if (this._elementHelper.append) {
                this._elementHelper.append(img);
              } else {
                this._elementHelper.appendChild(img);
              }
              var ob = {
                img,
                assetData
              };
              return ob;
            }
            function createImgData(assetData) {
              var path = getAssetsPath(assetData, this.assetsPath, this.path);
              var img = createTag("img");
              img.crossOrigin = "anonymous";
              img.addEventListener("load", this._imageLoaded, false);
              img.addEventListener("error", function() {
                ob.img = proxyImage;
                this._imageLoaded();
              }.bind(this), false);
              img.src = path;
              var ob = {
                img,
                assetData
              };
              return ob;
            }
            function createFootageData(data) {
              var ob = {
                assetData: data
              };
              var path = getAssetsPath(data, this.assetsPath, this.path);
              dataManager.loadData(path, function(footageData) {
                ob.img = footageData;
                this._footageLoaded();
              }.bind(this), function() {
                ob.img = {};
                this._footageLoaded();
              }.bind(this));
              return ob;
            }
            function loadAssets(assets, cb) {
              this.imagesLoadedCb = cb;
              var i2;
              var len = assets.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (!assets[i2].layers) {
                  if (!assets[i2].t || assets[i2].t === "seq") {
                    this.totalImages += 1;
                    this.images.push(this._createImageData(assets[i2]));
                  } else if (assets[i2].t === 3) {
                    this.totalFootages += 1;
                    this.images.push(this.createFootageData(assets[i2]));
                  }
                }
              }
            }
            function setPath(path) {
              this.path = path || "";
            }
            function setAssetsPath(path) {
              this.assetsPath = path || "";
            }
            function getAsset(assetData) {
              var i2 = 0;
              var len = this.images.length;
              while (i2 < len) {
                if (this.images[i2].assetData === assetData) {
                  return this.images[i2].img;
                }
                i2 += 1;
              }
              return null;
            }
            function destroy() {
              this.imagesLoadedCb = null;
              this.images.length = 0;
            }
            function loadedImages() {
              return this.totalImages === this.loadedAssets;
            }
            function loadedFootages() {
              return this.totalFootages === this.loadedFootagesCount;
            }
            function setCacheType(type, elementHelper) {
              if (type === "svg") {
                this._elementHelper = elementHelper;
                this._createImageData = this.createImageData.bind(this);
              } else {
                this._createImageData = this.createImgData.bind(this);
              }
            }
            function ImagePreloaderFactory() {
              this._imageLoaded = imageLoaded.bind(this);
              this._footageLoaded = footageLoaded.bind(this);
              this.testImageLoaded = testImageLoaded.bind(this);
              this.createFootageData = createFootageData.bind(this);
              this.assetsPath = "";
              this.path = "";
              this.totalImages = 0;
              this.totalFootages = 0;
              this.loadedAssets = 0;
              this.loadedFootagesCount = 0;
              this.imagesLoadedCb = null;
              this.images = [];
            }
            ImagePreloaderFactory.prototype = {
              loadAssets,
              setAssetsPath,
              setPath,
              loadedImages,
              loadedFootages,
              destroy,
              getAsset,
              createImgData,
              createImageData,
              imageLoaded,
              footageLoaded,
              setCacheType
            };
            return ImagePreloaderFactory;
          }();
          var featureSupport = function() {
            var ob = {
              maskType: true
            };
            if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
              ob.maskType = false;
            }
            return ob;
          }();
          var filtersFactory = function() {
            var ob = {};
            ob.createFilter = createFilter;
            ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
            function createFilter(filId, skipCoordinates) {
              var fil = createNS("filter");
              fil.setAttribute("id", filId);
              if (skipCoordinates !== true) {
                fil.setAttribute("filterUnits", "objectBoundingBox");
                fil.setAttribute("x", "0%");
                fil.setAttribute("y", "0%");
                fil.setAttribute("width", "100%");
                fil.setAttribute("height", "100%");
              }
              return fil;
            }
            function createAlphaToLuminanceFilter() {
              var feColorMatrix = createNS("feColorMatrix");
              feColorMatrix.setAttribute("type", "matrix");
              feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
              feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
              return feColorMatrix;
            }
            return ob;
          }();
          function TextAnimatorProperty(textData, renderType, elem) {
            this._isFirstFrame = true;
            this._hasMaskedPath = false;
            this._frameId = -1;
            this._textData = textData;
            this._renderType = renderType;
            this._elem = elem;
            this._animatorsData = createSizedArray(this._textData.a.length);
            this._pathData = {};
            this._moreOptions = {
              alignment: {}
            };
            this.renderedLetters = [];
            this.lettersChangedFlag = false;
            this.initDynamicPropertyContainer(elem);
          }
          TextAnimatorProperty.prototype.searchProperties = function() {
            var i2;
            var len = this._textData.a.length;
            var animatorProps;
            var getProp = PropertyFactory.getProp;
            for (i2 = 0; i2 < len; i2 += 1) {
              animatorProps = this._textData.a[i2];
              this._animatorsData[i2] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
            }
            if (this._textData.p && "m" in this._textData.p) {
              this._pathData = {
                a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
              };
              this._hasMaskedPath = true;
            } else {
              this._hasMaskedPath = false;
            }
            this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
          };
          TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
            this.lettersChangedFlag = lettersChangedFlag;
            if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
              return;
            }
            this._isFirstFrame = false;
            var alignment = this._moreOptions.alignment.v;
            var animators = this._animatorsData;
            var textData = this._textData;
            var matrixHelper = this.mHelper;
            var renderType = this._renderType;
            var renderedLettersCount = this.renderedLetters.length;
            var xPos;
            var yPos;
            var i2;
            var len;
            var letters = documentData.l;
            var pathInfo;
            var currentLength;
            var currentPoint;
            var segmentLength;
            var flag;
            var pointInd;
            var segmentInd;
            var prevPoint;
            var points;
            var segments;
            var partialLength;
            var totalLength;
            var perc;
            var tanAngle;
            var mask;
            if (this._hasMaskedPath) {
              mask = this._pathData.m;
              if (!this._pathData.n || this._pathData._mdf) {
                var paths = mask.v;
                if (this._pathData.r.v) {
                  paths = paths.reverse();
                }
                pathInfo = {
                  tLength: 0,
                  segments: []
                };
                len = paths._length - 1;
                var bezierData;
                totalLength = 0;
                for (i2 = 0; i2 < len; i2 += 1) {
                  bezierData = bez.buildBezierData(paths.v[i2], paths.v[i2 + 1], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[i2 + 1][0] - paths.v[i2 + 1][0], paths.i[i2 + 1][1] - paths.v[i2 + 1][1]]);
                  pathInfo.tLength += bezierData.segmentLength;
                  pathInfo.segments.push(bezierData);
                  totalLength += bezierData.segmentLength;
                }
                i2 = len;
                if (mask.v.c) {
                  bezierData = bez.buildBezierData(paths.v[i2], paths.v[0], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
                  pathInfo.tLength += bezierData.segmentLength;
                  pathInfo.segments.push(bezierData);
                  totalLength += bezierData.segmentLength;
                }
                this._pathData.pi = pathInfo;
              }
              pathInfo = this._pathData.pi;
              currentLength = this._pathData.f.v;
              segmentInd = 0;
              pointInd = 1;
              segmentLength = 0;
              flag = true;
              segments = pathInfo.segments;
              if (currentLength < 0 && mask.v.c) {
                if (pathInfo.tLength < Math.abs(currentLength)) {
                  currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                }
                segmentInd = segments.length - 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
                while (currentLength < 0) {
                  currentLength += points[pointInd].partialLength;
                  pointInd -= 1;
                  if (pointInd < 0) {
                    segmentInd -= 1;
                    points = segments[segmentInd].points;
                    pointInd = points.length - 1;
                  }
                }
              }
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
            }
            len = letters.length;
            xPos = 0;
            yPos = 0;
            var yOff = documentData.finalSize * 1.2 * 0.714;
            var firstLine = true;
            var animatorProps;
            var animatorSelector;
            var j;
            var jLen;
            var letterValue;
            jLen = animators.length;
            var mult;
            var ind = -1;
            var offf;
            var xPathPos;
            var yPathPos;
            var initPathPos = currentLength;
            var initSegmentInd = segmentInd;
            var initPointInd = pointInd;
            var currentLine = -1;
            var elemOpacity;
            var sc;
            var sw;
            var fc;
            var k;
            var letterSw;
            var letterSc;
            var letterFc;
            var letterM = "";
            var letterP = this.defaultPropsArray;
            var letterO;
            if (documentData.j === 2 || documentData.j === 1) {
              var animatorJustifyOffset = 0;
              var animatorFirstCharOffset = 0;
              var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
              var lastIndex = 0;
              var isNewLine = true;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (letters[i2].n) {
                  if (animatorJustifyOffset) {
                    animatorJustifyOffset += animatorFirstCharOffset;
                  }
                  while (lastIndex < i2) {
                    letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                    lastIndex += 1;
                  }
                  animatorJustifyOffset = 0;
                  isNewLine = true;
                } else {
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.t.propType) {
                      if (isNewLine && documentData.j === 2) {
                        animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                      }
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                      if (mult.length) {
                        animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                      } else {
                        animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                      }
                    }
                  }
                  isNewLine = false;
                }
              }
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }
              while (lastIndex < i2) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              matrixHelper.reset();
              elemOpacity = 1;
              if (letters[i2].n) {
                xPos = 0;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                currentLength = initPathPos;
                firstLine = false;
                if (this._hasMaskedPath) {
                  segmentInd = initSegmentInd;
                  pointInd = initPointInd;
                  points = segments[segmentInd].points;
                  prevPoint = points[pointInd - 1];
                  currentPoint = points[pointInd];
                  partialLength = currentPoint.partialLength;
                  segmentLength = 0;
                }
                letterM = "";
                letterFc = "";
                letterSw = "";
                letterO = "";
                letterP = this.defaultPropsArray;
              } else {
                if (this._hasMaskedPath) {
                  if (currentLine !== letters[i2].line) {
                    switch (documentData.j) {
                      case 1:
                        currentLength += totalLength - documentData.lineWidths[letters[i2].line];
                        break;
                      case 2:
                        currentLength += (totalLength - documentData.lineWidths[letters[i2].line]) / 2;
                        break;
                      default:
                        break;
                    }
                    currentLine = letters[i2].line;
                  }
                  if (ind !== letters[i2].ind) {
                    if (letters[ind]) {
                      currentLength += letters[ind].extra;
                    }
                    currentLength += letters[i2].an / 2;
                    ind = letters[i2].ind;
                  }
                  currentLength += alignment[0] * letters[i2].an * 5e-3;
                  var animatorOffset = 0;
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.p.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                      if (mult.length) {
                        animatorOffset += animatorProps.p.v[0] * mult[0];
                      } else {
                        animatorOffset += animatorProps.p.v[0] * mult;
                      }
                    }
                    if (animatorProps.a.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                      if (mult.length) {
                        animatorOffset += animatorProps.a.v[0] * mult[0];
                      } else {
                        animatorOffset += animatorProps.a.v[0] * mult;
                      }
                    }
                  }
                  flag = true;
                  if (this._pathData.a.v) {
                    currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                    currentLength += this._pathData.f.v;
                  }
                  while (flag) {
                    if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                      perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                      xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                      yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                      matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                      flag = false;
                    } else if (points) {
                      segmentLength += currentPoint.partialLength;
                      pointInd += 1;
                      if (pointInd >= points.length) {
                        pointInd = 0;
                        segmentInd += 1;
                        if (!segments[segmentInd]) {
                          if (mask.v.c) {
                            pointInd = 0;
                            segmentInd = 0;
                            points = segments[segmentInd].points;
                          } else {
                            segmentLength -= currentPoint.partialLength;
                            points = null;
                          }
                        } else {
                          points = segments[segmentInd].points;
                        }
                      }
                      if (points) {
                        prevPoint = currentPoint;
                        currentPoint = points[pointInd];
                        partialLength = currentPoint.partialLength;
                      }
                    }
                  }
                  offf = letters[i2].an / 2 - letters[i2].add;
                  matrixHelper.translate(-offf, 0, 0);
                } else {
                  offf = letters[i2].an / 2 - letters[i2].add;
                  matrixHelper.translate(-offf, 0, 0);
                  matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
                }
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.t.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (xPos !== 0 || documentData.j !== 0) {
                      if (this._hasMaskedPath) {
                        if (mult.length) {
                          currentLength += animatorProps.t.v * mult[0];
                        } else {
                          currentLength += animatorProps.t.v * mult;
                        }
                      } else if (mult.length) {
                        xPos += animatorProps.t.v * mult[0];
                      } else {
                        xPos += animatorProps.t.v * mult;
                      }
                    }
                  }
                }
                if (documentData.strokeWidthAnim) {
                  sw = documentData.sw || 0;
                }
                if (documentData.strokeColorAnim) {
                  if (documentData.sc) {
                    sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                  } else {
                    sc = [0, 0, 0];
                  }
                }
                if (documentData.fillColorAnim && documentData.fc) {
                  fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
                }
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.a.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (mult.length) {
                      matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                    } else {
                      matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                    }
                  }
                }
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.s.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (mult.length) {
                      matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                    } else {
                      matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                    }
                  }
                }
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (animatorProps.sk.propType) {
                    if (mult.length) {
                      matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                    } else {
                      matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                    }
                  }
                  if (animatorProps.r.propType) {
                    if (mult.length) {
                      matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                    } else {
                      matrixHelper.rotateZ(-animatorProps.r.v * mult);
                    }
                  }
                  if (animatorProps.ry.propType) {
                    if (mult.length) {
                      matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                    } else {
                      matrixHelper.rotateY(animatorProps.ry.v * mult);
                    }
                  }
                  if (animatorProps.rx.propType) {
                    if (mult.length) {
                      matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                    } else {
                      matrixHelper.rotateX(animatorProps.rx.v * mult);
                    }
                  }
                  if (animatorProps.o.propType) {
                    if (mult.length) {
                      elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                    } else {
                      elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                    }
                  }
                  if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                    if (mult.length) {
                      sw += animatorProps.sw.v * mult[0];
                    } else {
                      sw += animatorProps.sw.v * mult;
                    }
                  }
                  if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                    for (k = 0; k < 3; k += 1) {
                      if (mult.length) {
                        sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                      } else {
                        sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                      }
                    }
                  }
                  if (documentData.fillColorAnim && documentData.fc) {
                    if (animatorProps.fc.propType) {
                      for (k = 0; k < 3; k += 1) {
                        if (mult.length) {
                          fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                        } else {
                          fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                        }
                      }
                    }
                    if (animatorProps.fh.propType) {
                      if (mult.length) {
                        fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                      } else {
                        fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                      }
                    }
                    if (animatorProps.fs.propType) {
                      if (mult.length) {
                        fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                      } else {
                        fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                      }
                    }
                    if (animatorProps.fb.propType) {
                      if (mult.length) {
                        fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                      } else {
                        fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                      }
                    }
                  }
                }
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.p.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (this._hasMaskedPath) {
                      if (mult.length) {
                        matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                      } else {
                        matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                      }
                    } else if (mult.length) {
                      matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                    } else {
                      matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                    }
                  }
                }
                if (documentData.strokeWidthAnim) {
                  letterSw = sw < 0 ? 0 : sw;
                }
                if (documentData.strokeColorAnim) {
                  letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
                }
                if (documentData.fillColorAnim && documentData.fc) {
                  letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
                }
                if (this._hasMaskedPath) {
                  matrixHelper.translate(0, -documentData.ls);
                  matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                  if (this._pathData.p.v) {
                    tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                    var rot = Math.atan(tanAngle) * 180 / Math.PI;
                    if (currentPoint.point[0] < prevPoint.point[0]) {
                      rot += 180;
                    }
                    matrixHelper.rotate(-rot * Math.PI / 180);
                  }
                  matrixHelper.translate(xPathPos, yPathPos, 0);
                  currentLength -= alignment[0] * letters[i2].an * 5e-3;
                  if (letters[i2 + 1] && ind !== letters[i2 + 1].ind) {
                    currentLength += letters[i2].an / 2;
                    currentLength += documentData.tr * 1e-3 * documentData.finalSize;
                  }
                } else {
                  matrixHelper.translate(xPos, yPos, 0);
                  if (documentData.ps) {
                    matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                  }
                  switch (documentData.j) {
                    case 1:
                      matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]), 0, 0);
                      break;
                    case 2:
                      matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]) / 2, 0, 0);
                      break;
                    default:
                      break;
                  }
                  matrixHelper.translate(0, -documentData.ls);
                  matrixHelper.translate(offf, 0, 0);
                  matrixHelper.translate(alignment[0] * letters[i2].an * 5e-3, alignment[1] * yOff * 0.01, 0);
                  xPos += letters[i2].l + documentData.tr * 1e-3 * documentData.finalSize;
                }
                if (renderType === "html") {
                  letterM = matrixHelper.toCSS();
                } else if (renderType === "svg") {
                  letterM = matrixHelper.to2dCSS();
                } else {
                  letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
                }
                letterO = elemOpacity;
              }
              if (renderedLettersCount <= i2) {
                letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
                this.renderedLetters.push(letterValue);
                renderedLettersCount += 1;
                this.lettersChangedFlag = true;
              } else {
                letterValue = this.renderedLetters[i2];
                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
              }
            }
          };
          TextAnimatorProperty.prototype.getValue = function() {
            if (this._elem.globalData.frameId === this._frameId) {
              return;
            }
            this._frameId = this._elem.globalData.frameId;
            this.iterateDynamicProperties();
          };
          TextAnimatorProperty.prototype.mHelper = new Matrix();
          TextAnimatorProperty.prototype.defaultPropsArray = [];
          extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
          function TextAnimatorDataProperty(elem, animatorProps, container) {
            var defaultData = { propType: false };
            var getProp = PropertyFactory.getProp;
            var textAnimatorAnimatables = animatorProps.a;
            this.a = {
              r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
              rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
              ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
              sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
              sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
              s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
              a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
              o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
              p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
              sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
              sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
              fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
              fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
              fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
              fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
              t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
            };
            this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
            this.s.t = animatorProps.s.t;
          }
          function LetterProps(o, sw, sc, fc, m, p) {
            this.o = o;
            this.sw = sw;
            this.sc = sc;
            this.fc = fc;
            this.m = m;
            this.p = p;
            this._mdf = {
              o: true,
              sw: !!sw,
              sc: !!sc,
              fc: !!fc,
              m: true,
              p: true
            };
          }
          LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
            this._mdf.o = false;
            this._mdf.sw = false;
            this._mdf.sc = false;
            this._mdf.fc = false;
            this._mdf.m = false;
            this._mdf.p = false;
            var updated = false;
            if (this.o !== o) {
              this.o = o;
              this._mdf.o = true;
              updated = true;
            }
            if (this.sw !== sw) {
              this.sw = sw;
              this._mdf.sw = true;
              updated = true;
            }
            if (this.sc !== sc) {
              this.sc = sc;
              this._mdf.sc = true;
              updated = true;
            }
            if (this.fc !== fc) {
              this.fc = fc;
              this._mdf.fc = true;
              updated = true;
            }
            if (this.m !== m) {
              this.m = m;
              this._mdf.m = true;
              updated = true;
            }
            if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
              this.p = p;
              this._mdf.p = true;
              updated = true;
            }
            return updated;
          };
          function TextProperty(elem, data) {
            this._frameId = initialDefaultFrame;
            this.pv = "";
            this.v = "";
            this.kf = false;
            this._isFirstFrame = true;
            this._mdf = false;
            this.data = data;
            this.elem = elem;
            this.comp = this.elem.comp;
            this.keysIndex = 0;
            this.canResize = false;
            this.minimumFontSize = 1;
            this.effectsSequence = [];
            this.currentData = {
              ascent: 0,
              boxWidth: this.defaultBoxWidth,
              f: "",
              fStyle: "",
              fWeight: "",
              fc: "",
              j: "",
              justifyOffset: "",
              l: [],
              lh: 0,
              lineWidths: [],
              ls: "",
              of: "",
              s: "",
              sc: "",
              sw: 0,
              t: 0,
              tr: 0,
              sz: 0,
              ps: null,
              fillColorAnim: false,
              strokeColorAnim: false,
              strokeWidthAnim: false,
              yOffset: 0,
              finalSize: 0,
              finalText: [],
              finalLineHeight: 0,
              __complete: false
            };
            this.copyData(this.currentData, this.data.d.k[0].s);
            if (!this.searchProperty()) {
              this.completeTextData(this.currentData);
            }
          }
          TextProperty.prototype.defaultBoxWidth = [0, 0];
          TextProperty.prototype.copyData = function(obj, data) {
            for (var s in data) {
              if (Object.prototype.hasOwnProperty.call(data, s)) {
                obj[s] = data[s];
              }
            }
            return obj;
          };
          TextProperty.prototype.setCurrentData = function(data) {
            if (!data.__complete) {
              this.completeTextData(data);
            }
            this.currentData = data;
            this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
            this._mdf = true;
          };
          TextProperty.prototype.searchProperty = function() {
            return this.searchKeyframes();
          };
          TextProperty.prototype.searchKeyframes = function() {
            this.kf = this.data.d.k.length > 1;
            if (this.kf) {
              this.addEffect(this.getKeyframeValue.bind(this));
            }
            return this.kf;
          };
          TextProperty.prototype.addEffect = function(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.elem.addDynamicProperty(this);
          };
          TextProperty.prototype.getValue = function(_finalValue) {
            if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
              return;
            }
            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
            var currentValue = this.currentData;
            var currentIndex = this.keysIndex;
            if (this.lock) {
              this.setCurrentData(this.currentData);
              return;
            }
            this.lock = true;
            this._mdf = false;
            var i2;
            var len = this.effectsSequence.length;
            var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (currentIndex !== this.keysIndex) {
                finalValue = this.effectsSequence[i2](finalValue, finalValue.t);
              } else {
                finalValue = this.effectsSequence[i2](this.currentData, finalValue.t);
              }
            }
            if (currentValue !== finalValue) {
              this.setCurrentData(finalValue);
            }
            this.v = this.currentData;
            this.pv = this.v;
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          };
          TextProperty.prototype.getKeyframeValue = function() {
            var textKeys = this.data.d.k;
            var frameNum = this.elem.comp.renderedFrame;
            var i2 = 0;
            var len = textKeys.length;
            while (i2 <= len - 1) {
              if (i2 === len - 1 || textKeys[i2 + 1].t > frameNum) {
                break;
              }
              i2 += 1;
            }
            if (this.keysIndex !== i2) {
              this.keysIndex = i2;
            }
            return this.data.d.k[this.keysIndex].s;
          };
          TextProperty.prototype.buildFinalText = function(text2) {
            var charactersArray = [];
            var i2 = 0;
            var len = text2.length;
            var charCode;
            var secondCharCode;
            var shouldCombine = false;
            while (i2 < len) {
              charCode = text2.charCodeAt(i2);
              if (FontManager.isCombinedCharacter(charCode)) {
                charactersArray[charactersArray.length - 1] += text2.charAt(i2);
              } else if (charCode >= 55296 && charCode <= 56319) {
                secondCharCode = text2.charCodeAt(i2 + 1);
                if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                  if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
                    charactersArray[charactersArray.length - 1] += text2.substr(i2, 2);
                    shouldCombine = false;
                  } else {
                    charactersArray.push(text2.substr(i2, 2));
                  }
                  i2 += 1;
                } else {
                  charactersArray.push(text2.charAt(i2));
                }
              } else if (charCode > 56319) {
                secondCharCode = text2.charCodeAt(i2 + 1);
                if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
                  shouldCombine = true;
                  charactersArray[charactersArray.length - 1] += text2.substr(i2, 2);
                  i2 += 1;
                } else {
                  charactersArray.push(text2.charAt(i2));
                }
              } else if (FontManager.isZeroWidthJoiner(charCode)) {
                charactersArray[charactersArray.length - 1] += text2.charAt(i2);
                shouldCombine = true;
              } else {
                charactersArray.push(text2.charAt(i2));
              }
              i2 += 1;
            }
            return charactersArray;
          };
          TextProperty.prototype.completeTextData = function(documentData) {
            documentData.__complete = true;
            var fontManager = this.elem.globalData.fontManager;
            var data = this.data;
            var letters = [];
            var i2;
            var len;
            var newLineFlag;
            var index3 = 0;
            var val;
            var anchorGrouping = data.m.g;
            var currentSize = 0;
            var currentPos = 0;
            var currentLine = 0;
            var lineWidths = [];
            var lineWidth = 0;
            var maxLineWidth = 0;
            var j;
            var jLen;
            var fontData = fontManager.getFontByName(documentData.f);
            var charData;
            var cLength = 0;
            var fontProps = getFontProperties(fontData);
            documentData.fWeight = fontProps.weight;
            documentData.fStyle = fontProps.style;
            documentData.finalSize = documentData.s;
            documentData.finalText = this.buildFinalText(documentData.t);
            len = documentData.finalText.length;
            documentData.finalLineHeight = documentData.lh;
            var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
            var charCode;
            if (documentData.sz) {
              var flag = true;
              var boxWidth = documentData.sz[0];
              var boxHeight = documentData.sz[1];
              var currentHeight;
              var finalText;
              while (flag) {
                finalText = this.buildFinalText(documentData.t);
                currentHeight = 0;
                lineWidth = 0;
                len = finalText.length;
                trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
                var lastSpaceIndex = -1;
                for (i2 = 0; i2 < len; i2 += 1) {
                  charCode = finalText[i2].charCodeAt(0);
                  newLineFlag = false;
                  if (finalText[i2] === " ") {
                    lastSpaceIndex = i2;
                  } else if (charCode === 13 || charCode === 3) {
                    lineWidth = 0;
                    newLineFlag = true;
                    currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                  }
                  if (fontManager.chars) {
                    charData = fontManager.getCharData(finalText[i2], fontData.fStyle, fontData.fFamily);
                    cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                  } else {
                    cLength = fontManager.measureText(finalText[i2], documentData.f, documentData.finalSize);
                  }
                  if (lineWidth + cLength > boxWidth && finalText[i2] !== " ") {
                    if (lastSpaceIndex === -1) {
                      len += 1;
                    } else {
                      i2 = lastSpaceIndex;
                    }
                    currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                    finalText.splice(i2, lastSpaceIndex === i2 ? 1 : 0, "\r");
                    lastSpaceIndex = -1;
                    lineWidth = 0;
                  } else {
                    lineWidth += cLength;
                    lineWidth += trackingOffset;
                  }
                }
                currentHeight += fontData.ascent * documentData.finalSize / 100;
                if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                  documentData.finalSize -= 1;
                  documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
                } else {
                  documentData.finalText = finalText;
                  len = documentData.finalText.length;
                  flag = false;
                }
              }
            }
            lineWidth = -trackingOffset;
            cLength = 0;
            var uncollapsedSpaces = 0;
            var currentChar;
            for (i2 = 0; i2 < len; i2 += 1) {
              newLineFlag = false;
              currentChar = documentData.finalText[i2];
              charCode = currentChar.charCodeAt(0);
              if (charCode === 13 || charCode === 3) {
                uncollapsedSpaces = 0;
                lineWidths.push(lineWidth);
                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                lineWidth = -2 * trackingOffset;
                val = "";
                newLineFlag = true;
                currentLine += 1;
              } else {
                val = currentChar;
              }
              if (fontManager.chars) {
                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
              }
              if (currentChar === " ") {
                uncollapsedSpaces += cLength + trackingOffset;
              } else {
                lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                uncollapsedSpaces = 0;
              }
              letters.push({
                l: cLength,
                an: cLength,
                add: currentSize,
                n: newLineFlag,
                anIndexes: [],
                val,
                line: currentLine,
                animatorJustifyOffset: 0
              });
              if (anchorGrouping == 2) {
                currentSize += cLength;
                if (val === "" || val === " " || i2 === len - 1) {
                  if (val === "" || val === " ") {
                    currentSize -= cLength;
                  }
                  while (currentPos <= i2) {
                    letters[currentPos].an = currentSize;
                    letters[currentPos].ind = index3;
                    letters[currentPos].extra = cLength;
                    currentPos += 1;
                  }
                  index3 += 1;
                  currentSize = 0;
                }
              } else if (anchorGrouping == 3) {
                currentSize += cLength;
                if (val === "" || i2 === len - 1) {
                  if (val === "") {
                    currentSize -= cLength;
                  }
                  while (currentPos <= i2) {
                    letters[currentPos].an = currentSize;
                    letters[currentPos].ind = index3;
                    letters[currentPos].extra = cLength;
                    currentPos += 1;
                  }
                  currentSize = 0;
                  index3 += 1;
                }
              } else {
                letters[index3].ind = index3;
                letters[index3].extra = 0;
                index3 += 1;
              }
            }
            documentData.l = letters;
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidths.push(lineWidth);
            if (documentData.sz) {
              documentData.boxWidth = documentData.sz[0];
              documentData.justifyOffset = 0;
            } else {
              documentData.boxWidth = maxLineWidth;
              switch (documentData.j) {
                case 1:
                  documentData.justifyOffset = -documentData.boxWidth;
                  break;
                case 2:
                  documentData.justifyOffset = -documentData.boxWidth / 2;
                  break;
                default:
                  documentData.justifyOffset = 0;
              }
            }
            documentData.lineWidths = lineWidths;
            var animators = data.a;
            var animatorData;
            var letterData;
            jLen = animators.length;
            var based;
            var ind;
            var indexes = [];
            for (j = 0; j < jLen; j += 1) {
              animatorData = animators[j];
              if (animatorData.a.sc) {
                documentData.strokeColorAnim = true;
              }
              if (animatorData.a.sw) {
                documentData.strokeWidthAnim = true;
              }
              if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
                documentData.fillColorAnim = true;
              }
              ind = 0;
              based = animatorData.s.b;
              for (i2 = 0; i2 < len; i2 += 1) {
                letterData = letters[i2];
                letterData.anIndexes[j] = ind;
                if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i2 == len - 1) || based == 4 && (letterData.n || i2 == len - 1)) {
                  if (animatorData.s.rn === 1) {
                    indexes.push(ind);
                  }
                  ind += 1;
                }
              }
              data.a[j].s.totalChars = ind;
              var currentInd = -1;
              var newInd;
              if (animatorData.s.rn === 1) {
                for (i2 = 0; i2 < len; i2 += 1) {
                  letterData = letters[i2];
                  if (currentInd != letterData.anIndexes[j]) {
                    currentInd = letterData.anIndexes[j];
                    newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                  }
                  letterData.anIndexes[j] = newInd;
                }
              }
            }
            documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
            documentData.ls = documentData.ls || 0;
            documentData.ascent = fontData.ascent * documentData.finalSize / 100;
          };
          TextProperty.prototype.updateDocumentData = function(newData, index3) {
            index3 = index3 === void 0 ? this.keysIndex : index3;
            var dData = this.copyData({}, this.data.d.k[index3].s);
            dData = this.copyData(dData, newData);
            this.data.d.k[index3].s = dData;
            this.recalculate(index3);
            this.elem.addDynamicProperty(this);
          };
          TextProperty.prototype.recalculate = function(index3) {
            var dData = this.data.d.k[index3].s;
            dData.__complete = false;
            this.keysIndex = 0;
            this._isFirstFrame = true;
            this.getValue(dData);
          };
          TextProperty.prototype.canResizeFont = function(_canResize) {
            this.canResize = _canResize;
            this.recalculate(this.keysIndex);
            this.elem.addDynamicProperty(this);
          };
          TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
            this.minimumFontSize = Math.floor(_fontValue) || 1;
            this.recalculate(this.keysIndex);
            this.elem.addDynamicProperty(this);
          };
          var TextSelectorProp = function() {
            var max = Math.max;
            var min = Math.min;
            var floor = Math.floor;
            function TextSelectorPropFactory(elem, data) {
              this._currentTextLength = -1;
              this.k = false;
              this.data = data;
              this.elem = elem;
              this.comp = elem.comp;
              this.finalS = 0;
              this.finalE = 0;
              this.initDynamicPropertyContainer(elem);
              this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
              if ("e" in data) {
                this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
              } else {
                this.e = { v: 100 };
              }
              this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
              this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
              this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
              this.sm = PropertyFactory.getProp(elem, data.sm || { k: 100 }, 0, 0, this);
              this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
              if (!this.dynamicProperties.length) {
                this.getValue();
              }
            }
            TextSelectorPropFactory.prototype = {
              getMult: function(ind) {
                if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                  this.getValue();
                }
                var x1 = 0;
                var y1 = 0;
                var x2 = 1;
                var y2 = 1;
                if (this.ne.v > 0) {
                  x1 = this.ne.v / 100;
                } else {
                  y1 = -this.ne.v / 100;
                }
                if (this.xe.v > 0) {
                  x2 = 1 - this.xe.v / 100;
                } else {
                  y2 = 1 + this.xe.v / 100;
                }
                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
                var mult = 0;
                var s = this.finalS;
                var e = this.finalE;
                var type = this.data.sh;
                if (type === 2) {
                  if (e === s) {
                    mult = ind >= e ? 1 : 0;
                  } else {
                    mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                  }
                  mult = easer(mult);
                } else if (type === 3) {
                  if (e === s) {
                    mult = ind >= e ? 0 : 1;
                  } else {
                    mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                  }
                  mult = easer(mult);
                } else if (type === 4) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    if (mult < 0.5) {
                      mult *= 2;
                    } else {
                      mult = 1 - 2 * (mult - 0.5);
                    }
                  }
                  mult = easer(mult);
                } else if (type === 5) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    var tot = e - s;
                    ind = min(max(0, ind + 0.5 - s), e - s);
                    var x = -tot / 2 + ind;
                    var a = tot / 2;
                    mult = Math.sqrt(1 - x * x / (a * a));
                  }
                  mult = easer(mult);
                } else if (type === 6) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    ind = min(max(0, ind + 0.5 - s), e - s);
                    mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2;
                  }
                  mult = easer(mult);
                } else {
                  if (ind >= floor(s)) {
                    if (ind - s < 0) {
                      mult = max(0, min(min(e, 1) - (s - ind), 1));
                    } else {
                      mult = max(0, min(e - ind, 1));
                    }
                  }
                  mult = easer(mult);
                }
                if (this.sm.v !== 100) {
                  var smoothness = this.sm.v * 0.01;
                  if (smoothness === 0) {
                    smoothness = 1e-8;
                  }
                  var threshold = 0.5 - smoothness * 0.5;
                  if (mult < threshold) {
                    mult = 0;
                  } else {
                    mult = (mult - threshold) / smoothness;
                    if (mult > 1) {
                      mult = 1;
                    }
                  }
                }
                return mult * this.a.v;
              },
              getValue: function(newCharsFlag) {
                this.iterateDynamicProperties();
                this._mdf = newCharsFlag || this._mdf;
                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
                if (newCharsFlag && this.data.r === 2) {
                  this.e.v = this._currentTextLength;
                }
                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                var o = this.o.v / divisor;
                var s = this.s.v / divisor + o;
                var e = this.e.v / divisor + o;
                if (s > e) {
                  var _s = s;
                  s = e;
                  e = _s;
                }
                this.finalS = s;
                this.finalE = e;
              }
            };
            extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
            function getTextSelectorProp(elem, data, arr) {
              return new TextSelectorPropFactory(elem, data, arr);
            }
            return {
              getTextSelectorProp
            };
          }();
          var poolFactory = function() {
            return function(initialLength, _create, _release) {
              var _length = 0;
              var _maxLength = initialLength;
              var pool = createSizedArray(_maxLength);
              var ob = {
                newElement,
                release
              };
              function newElement() {
                var element;
                if (_length) {
                  _length -= 1;
                  element = pool[_length];
                } else {
                  element = _create();
                }
                return element;
              }
              function release(element) {
                if (_length === _maxLength) {
                  pool = pooling.double(pool);
                  _maxLength *= 2;
                }
                if (_release) {
                  _release(element);
                }
                pool[_length] = element;
                _length += 1;
              }
              return ob;
            };
          }();
          var pooling = function() {
            function double(arr) {
              return arr.concat(createSizedArray(arr.length));
            }
            return {
              double
            };
          }();
          var pointPool = function() {
            function create() {
              return createTypedArray("float32", 2);
            }
            return poolFactory(8, create);
          }();
          var shapePool = function() {
            function create() {
              return new ShapePath2();
            }
            function release(shapePath) {
              var len = shapePath._length;
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                pointPool.release(shapePath.v[i2]);
                pointPool.release(shapePath.i[i2]);
                pointPool.release(shapePath.o[i2]);
                shapePath.v[i2] = null;
                shapePath.i[i2] = null;
                shapePath.o[i2] = null;
              }
              shapePath._length = 0;
              shapePath.c = false;
            }
            function clone(shape) {
              var cloned = factory.newElement();
              var i2;
              var len = shape._length === void 0 ? shape.v.length : shape._length;
              cloned.setLength(len);
              cloned.c = shape.c;
              for (i2 = 0; i2 < len; i2 += 1) {
                cloned.setTripleAt(shape.v[i2][0], shape.v[i2][1], shape.o[i2][0], shape.o[i2][1], shape.i[i2][0], shape.i[i2][1], i2);
              }
              return cloned;
            }
            var factory = poolFactory(4, create, release);
            factory.clone = clone;
            return factory;
          }();
          var shapeCollectionPool = function() {
            var ob = {
              newShapeCollection,
              release
            };
            var _length = 0;
            var _maxLength = 4;
            var pool = createSizedArray(_maxLength);
            function newShapeCollection() {
              var shapeCollection;
              if (_length) {
                _length -= 1;
                shapeCollection = pool[_length];
              } else {
                shapeCollection = new ShapeCollection();
              }
              return shapeCollection;
            }
            function release(shapeCollection) {
              var i2;
              var len = shapeCollection._length;
              for (i2 = 0; i2 < len; i2 += 1) {
                shapePool.release(shapeCollection.shapes[i2]);
              }
              shapeCollection._length = 0;
              if (_length === _maxLength) {
                pool = pooling.double(pool);
                _maxLength *= 2;
              }
              pool[_length] = shapeCollection;
              _length += 1;
            }
            return ob;
          }();
          var segmentsLengthPool = function() {
            function create() {
              return {
                lengths: [],
                totalLength: 0
              };
            }
            function release(element) {
              var i2;
              var len = element.lengths.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                bezierLengthPool.release(element.lengths[i2]);
              }
              element.lengths.length = 0;
            }
            return poolFactory(8, create, release);
          }();
          var bezierLengthPool = function() {
            function create() {
              return {
                addedLength: 0,
                percents: createTypedArray("float32", defaultCurveSegments),
                lengths: createTypedArray("float32", defaultCurveSegments)
              };
            }
            return poolFactory(8, create);
          }();
          var markerParser = function() {
            function parsePayloadLines(payload) {
              var lines = payload.split("\r\n");
              var keys = {};
              var line;
              var keysCount = 0;
              for (var i2 = 0; i2 < lines.length; i2 += 1) {
                line = lines[i2].split(":");
                if (line.length === 2) {
                  keys[line[0]] = line[1].trim();
                  keysCount += 1;
                }
              }
              if (keysCount === 0) {
                throw new Error();
              }
              return keys;
            }
            return function(_markers) {
              var markers = [];
              for (var i2 = 0; i2 < _markers.length; i2 += 1) {
                var _marker = _markers[i2];
                var markerData = {
                  time: _marker.tm,
                  duration: _marker.dr
                };
                try {
                  markerData.payload = JSON.parse(_markers[i2].cm);
                } catch (_) {
                  try {
                    markerData.payload = parsePayloadLines(_markers[i2].cm);
                  } catch (__) {
                    markerData.payload = {
                      name: _markers[i2]
                    };
                  }
                }
                markers.push(markerData);
              }
              return markers;
            };
          }();
          function BaseRenderer() {
          }
          BaseRenderer.prototype.checkLayers = function(num) {
            var i2;
            var len = this.layers.length;
            var data;
            this.completeLayers = true;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              if (!this.elements[i2]) {
                data = this.layers[i2];
                if (data.ip - data.st <= num - this.layers[i2].st && data.op - data.st > num - this.layers[i2].st) {
                  this.buildItem(i2);
                }
              }
              this.completeLayers = this.elements[i2] ? this.completeLayers : false;
            }
            this.checkPendingElements();
          };
          BaseRenderer.prototype.createItem = function(layer) {
            switch (layer.ty) {
              case 2:
                return this.createImage(layer);
              case 0:
                return this.createComp(layer);
              case 1:
                return this.createSolid(layer);
              case 3:
                return this.createNull(layer);
              case 4:
                return this.createShape(layer);
              case 5:
                return this.createText(layer);
              case 6:
                return this.createAudio(layer);
              case 13:
                return this.createCamera(layer);
              case 15:
                return this.createFootage(layer);
              default:
                return this.createNull(layer);
            }
          };
          BaseRenderer.prototype.createCamera = function() {
            throw new Error("You're using a 3d camera. Try the html renderer.");
          };
          BaseRenderer.prototype.createAudio = function(data) {
            return new AudioElement(data, this.globalData, this);
          };
          BaseRenderer.prototype.createFootage = function(data) {
            return new FootageElement(data, this.globalData, this);
          };
          BaseRenderer.prototype.buildAllItems = function() {
            var i2;
            var len = this.layers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.buildItem(i2);
            }
            this.checkPendingElements();
          };
          BaseRenderer.prototype.includeLayers = function(newLayers) {
            this.completeLayers = false;
            var i2;
            var len = newLayers.length;
            var j;
            var jLen = this.layers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              j = 0;
              while (j < jLen) {
                if (this.layers[j].id === newLayers[i2].id) {
                  this.layers[j] = newLayers[i2];
                  break;
                }
                j += 1;
              }
            }
          };
          BaseRenderer.prototype.setProjectInterface = function(pInterface) {
            this.globalData.projectInterface = pInterface;
          };
          BaseRenderer.prototype.initItems = function() {
            if (!this.globalData.progressiveLoad) {
              this.buildAllItems();
            }
          };
          BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
            var elements = this.elements;
            var layers = this.layers;
            var i2 = 0;
            var len = layers.length;
            while (i2 < len) {
              if (layers[i2].ind == parentName) {
                if (!elements[i2] || elements[i2] === true) {
                  this.buildItem(i2);
                  this.addPendingElement(element);
                } else {
                  hierarchy.push(elements[i2]);
                  elements[i2].setAsParent();
                  if (layers[i2].parent !== void 0) {
                    this.buildElementParenting(element, layers[i2].parent, hierarchy);
                  } else {
                    element.setHierarchy(hierarchy);
                  }
                }
              }
              i2 += 1;
            }
          };
          BaseRenderer.prototype.addPendingElement = function(element) {
            this.pendingElements.push(element);
          };
          BaseRenderer.prototype.searchExtraCompositions = function(assets) {
            var i2;
            var len = assets.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (assets[i2].xt) {
                var comp = this.createComp(assets[i2]);
                comp.initExpressions();
                this.globalData.projectInterface.registerComposition(comp);
              }
            }
          };
          BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
            this.globalData.fontManager = new FontManager();
            this.globalData.fontManager.addChars(animData.chars);
            this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
            this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
            this.globalData.imageLoader = this.animationItem.imagePreloader;
            this.globalData.audioController = this.animationItem.audioController;
            this.globalData.frameId = 0;
            this.globalData.frameRate = animData.fr;
            this.globalData.nm = animData.nm;
            this.globalData.compSize = {
              w: animData.w,
              h: animData.h
            };
          };
          function SVGRenderer(animationItem, config3) {
            this.animationItem = animationItem;
            this.layers = null;
            this.renderedFrame = -1;
            this.svgElement = createNS("svg");
            var ariaLabel = "";
            if (config3 && config3.title) {
              var titleElement = createNS("title");
              var titleId = createElementID();
              titleElement.setAttribute("id", titleId);
              titleElement.textContent = config3.title;
              this.svgElement.appendChild(titleElement);
              ariaLabel += titleId;
            }
            if (config3 && config3.description) {
              var descElement = createNS("desc");
              var descId = createElementID();
              descElement.setAttribute("id", descId);
              descElement.textContent = config3.description;
              this.svgElement.appendChild(descElement);
              ariaLabel += " " + descId;
            }
            if (ariaLabel) {
              this.svgElement.setAttribute("aria-labelledby", ariaLabel);
            }
            var defs = createNS("defs");
            this.svgElement.appendChild(defs);
            var maskElement = createNS("g");
            this.svgElement.appendChild(maskElement);
            this.layerElement = maskElement;
            this.renderConfig = {
              preserveAspectRatio: config3 && config3.preserveAspectRatio || "xMidYMid meet",
              imagePreserveAspectRatio: config3 && config3.imagePreserveAspectRatio || "xMidYMid slice",
              contentVisibility: config3 && config3.contentVisibility || "visible",
              progressiveLoad: config3 && config3.progressiveLoad || false,
              hideOnTransparent: !(config3 && config3.hideOnTransparent === false),
              viewBoxOnly: config3 && config3.viewBoxOnly || false,
              viewBoxSize: config3 && config3.viewBoxSize || false,
              className: config3 && config3.className || "",
              id: config3 && config3.id || "",
              focusable: config3 && config3.focusable,
              filterSize: {
                width: config3 && config3.filterSize && config3.filterSize.width || "100%",
                height: config3 && config3.filterSize && config3.filterSize.height || "100%",
                x: config3 && config3.filterSize && config3.filterSize.x || "0%",
                y: config3 && config3.filterSize && config3.filterSize.y || "0%"
              }
            };
            this.globalData = {
              _mdf: false,
              frameNum: -1,
              defs,
              renderConfig: this.renderConfig
            };
            this.elements = [];
            this.pendingElements = [];
            this.destroyed = false;
            this.rendererType = "svg";
          }
          extendPrototype([BaseRenderer], SVGRenderer);
          SVGRenderer.prototype.createNull = function(data) {
            return new NullElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.createShape = function(data) {
            return new SVGShapeElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.createText = function(data) {
            return new SVGTextLottieElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.createImage = function(data) {
            return new IImageElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.createComp = function(data) {
            return new SVGCompElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.createSolid = function(data) {
            return new ISolidElement(data, this.globalData, this);
          };
          SVGRenderer.prototype.configAnimation = function(animData) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            if (this.renderConfig.viewBoxSize) {
              this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
            } else {
              this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
            }
            if (!this.renderConfig.viewBoxOnly) {
              this.svgElement.setAttribute("width", animData.w);
              this.svgElement.setAttribute("height", animData.h);
              this.svgElement.style.width = "100%";
              this.svgElement.style.height = "100%";
              this.svgElement.style.transform = "translate3d(0,0,0)";
              this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
            }
            if (this.renderConfig.className) {
              this.svgElement.setAttribute("class", this.renderConfig.className);
            }
            if (this.renderConfig.id) {
              this.svgElement.setAttribute("id", this.renderConfig.id);
            }
            if (this.renderConfig.focusable !== void 0) {
              this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
            }
            this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
            this.animationItem.wrapper.appendChild(this.svgElement);
            var defs = this.globalData.defs;
            this.setupGlobalData(animData, defs);
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
            this.data = animData;
            var maskElement = createNS("clipPath");
            var rect = createNS("rect");
            rect.setAttribute("width", animData.w);
            rect.setAttribute("height", animData.h);
            rect.setAttribute("x", 0);
            rect.setAttribute("y", 0);
            var maskId = createElementID();
            maskElement.setAttribute("id", maskId);
            maskElement.appendChild(rect);
            this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + maskId + ")");
            defs.appendChild(maskElement);
            this.layers = animData.layers;
            this.elements = createSizedArray(animData.layers.length);
          };
          SVGRenderer.prototype.destroy = function() {
            if (this.animationItem.wrapper) {
              this.animationItem.wrapper.innerText = "";
            }
            this.layerElement = null;
            this.globalData.defs = null;
            var i2;
            var len = this.layers ? this.layers.length : 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.elements[i2]) {
                this.elements[i2].destroy();
              }
            }
            this.elements.length = 0;
            this.destroyed = true;
            this.animationItem = null;
          };
          SVGRenderer.prototype.updateContainerSize = function() {
          };
          SVGRenderer.prototype.buildItem = function(pos) {
            var elements = this.elements;
            if (elements[pos] || this.layers[pos].ty === 99) {
              return;
            }
            elements[pos] = true;
            var element = this.createItem(this.layers[pos]);
            elements[pos] = element;
            if (expressionsPlugin) {
              if (this.layers[pos].ty === 0) {
                this.globalData.projectInterface.registerComposition(element);
              }
              element.initExpressions();
            }
            this.appendElementInPos(element, pos);
            if (this.layers[pos].tt) {
              if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
                this.buildItem(pos - 1);
                this.addPendingElement(element);
              } else {
                element.setMatte(elements[pos - 1].layerId);
              }
            }
          };
          SVGRenderer.prototype.checkPendingElements = function() {
            while (this.pendingElements.length) {
              var element = this.pendingElements.pop();
              element.checkParenting();
              if (element.data.tt) {
                var i2 = 0;
                var len = this.elements.length;
                while (i2 < len) {
                  if (this.elements[i2] === element) {
                    element.setMatte(this.elements[i2 - 1].layerId);
                    break;
                  }
                  i2 += 1;
                }
              }
            }
          };
          SVGRenderer.prototype.renderFrame = function(num) {
            if (this.renderedFrame === num || this.destroyed) {
              return;
            }
            if (num === null) {
              num = this.renderedFrame;
            } else {
              this.renderedFrame = num;
            }
            this.globalData.frameNum = num;
            this.globalData.frameId += 1;
            this.globalData.projectInterface.currentFrame = num;
            this.globalData._mdf = false;
            var i2;
            var len = this.layers.length;
            if (!this.completeLayers) {
              this.checkLayers(num);
            }
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].prepareFrame(num - this.layers[i2].st);
              }
            }
            if (this.globalData._mdf) {
              for (i2 = 0; i2 < len; i2 += 1) {
                if (this.completeLayers || this.elements[i2]) {
                  this.elements[i2].renderFrame();
                }
              }
            }
          };
          SVGRenderer.prototype.appendElementInPos = function(element, pos) {
            var newElement = element.getBaseElement();
            if (!newElement) {
              return;
            }
            var i2 = 0;
            var nextElement;
            while (i2 < pos) {
              if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement()) {
                nextElement = this.elements[i2].getBaseElement();
              }
              i2 += 1;
            }
            if (nextElement) {
              this.layerElement.insertBefore(newElement, nextElement);
            } else {
              this.layerElement.appendChild(newElement);
            }
          };
          SVGRenderer.prototype.hide = function() {
            this.layerElement.style.display = "none";
          };
          SVGRenderer.prototype.show = function() {
            this.layerElement.style.display = "block";
          };
          function MaskElement(data, element, globalData) {
            this.data = data;
            this.element = element;
            this.globalData = globalData;
            this.storedData = [];
            this.masksProperties = this.data.masksProperties || [];
            this.maskElement = null;
            var defs = this.globalData.defs;
            var i2;
            var len = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(len);
            this.solidPath = "";
            var path;
            var properties = this.masksProperties;
            var count = 0;
            var currentMasks = [];
            var j;
            var jLen;
            var layerId = createElementID();
            var rect;
            var expansor;
            var feMorph;
            var x;
            var maskType = "clipPath";
            var maskRef = "clip-path";
            for (i2 = 0; i2 < len; i2 += 1) {
              if (properties[i2].mode !== "a" && properties[i2].mode !== "n" || properties[i2].inv || properties[i2].o.k !== 100 || properties[i2].o.x) {
                maskType = "mask";
                maskRef = "mask";
              }
              if ((properties[i2].mode === "s" || properties[i2].mode === "i") && count === 0) {
                rect = createNS("rect");
                rect.setAttribute("fill", "#ffffff");
                rect.setAttribute("width", this.element.comp.data.w || 0);
                rect.setAttribute("height", this.element.comp.data.h || 0);
                currentMasks.push(rect);
              } else {
                rect = null;
              }
              path = createNS("path");
              if (properties[i2].mode === "n") {
                this.viewData[i2] = {
                  op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                  prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                  elem: path,
                  lastPath: ""
                };
                defs.appendChild(path);
              } else {
                count += 1;
                path.setAttribute("fill", properties[i2].mode === "s" ? "#000000" : "#ffffff");
                path.setAttribute("clip-rule", "nonzero");
                var filterID;
                if (properties[i2].x.k !== 0) {
                  maskType = "mask";
                  maskRef = "mask";
                  x = PropertyFactory.getProp(this.element, properties[i2].x, 0, null, this.element);
                  filterID = createElementID();
                  expansor = createNS("filter");
                  expansor.setAttribute("id", filterID);
                  feMorph = createNS("feMorphology");
                  feMorph.setAttribute("operator", "erode");
                  feMorph.setAttribute("in", "SourceGraphic");
                  feMorph.setAttribute("radius", "0");
                  expansor.appendChild(feMorph);
                  defs.appendChild(expansor);
                  path.setAttribute("stroke", properties[i2].mode === "s" ? "#000000" : "#ffffff");
                } else {
                  feMorph = null;
                  x = null;
                }
                this.storedData[i2] = {
                  elem: path,
                  x,
                  expan: feMorph,
                  lastPath: "",
                  lastOperator: "",
                  filterId: filterID,
                  lastRadius: 0
                };
                if (properties[i2].mode === "i") {
                  jLen = currentMasks.length;
                  var g = createNS("g");
                  for (j = 0; j < jLen; j += 1) {
                    g.appendChild(currentMasks[j]);
                  }
                  var mask = createNS("mask");
                  mask.setAttribute("mask-type", "alpha");
                  mask.setAttribute("id", layerId + "_" + count);
                  mask.appendChild(path);
                  defs.appendChild(mask);
                  g.setAttribute("mask", "url(" + locationHref + "#" + layerId + "_" + count + ")");
                  currentMasks.length = 0;
                  currentMasks.push(g);
                } else {
                  currentMasks.push(path);
                }
                if (properties[i2].inv && !this.solidPath) {
                  this.solidPath = this.createLayerSolidPath();
                }
                this.viewData[i2] = {
                  elem: path,
                  lastPath: "",
                  op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                  prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                  invRect: rect
                };
                if (!this.viewData[i2].prop.k) {
                  this.drawPath(properties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
                }
              }
            }
            this.maskElement = createNS(maskType);
            len = currentMasks.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.maskElement.appendChild(currentMasks[i2]);
            }
            if (count > 0) {
              this.maskElement.setAttribute("id", layerId);
              this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
              defs.appendChild(this.maskElement);
            }
            if (this.viewData.length) {
              this.element.addRenderableComponent(this);
            }
          }
          MaskElement.prototype.getMaskProperty = function(pos) {
            return this.viewData[pos].prop;
          };
          MaskElement.prototype.renderFrame = function(isFirstFrame) {
            var finalMat = this.element.finalTransform.mat;
            var i2;
            var len = this.masksProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.viewData[i2].prop._mdf || isFirstFrame) {
                this.drawPath(this.masksProperties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
              }
              if (this.viewData[i2].op._mdf || isFirstFrame) {
                this.viewData[i2].elem.setAttribute("fill-opacity", this.viewData[i2].op.v);
              }
              if (this.masksProperties[i2].mode !== "n") {
                if (this.viewData[i2].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
                  this.viewData[i2].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
                }
                if (this.storedData[i2].x && (this.storedData[i2].x._mdf || isFirstFrame)) {
                  var feMorph = this.storedData[i2].expan;
                  if (this.storedData[i2].x.v < 0) {
                    if (this.storedData[i2].lastOperator !== "erode") {
                      this.storedData[i2].lastOperator = "erode";
                      this.storedData[i2].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[i2].filterId + ")");
                    }
                    feMorph.setAttribute("radius", -this.storedData[i2].x.v);
                  } else {
                    if (this.storedData[i2].lastOperator !== "dilate") {
                      this.storedData[i2].lastOperator = "dilate";
                      this.storedData[i2].elem.setAttribute("filter", null);
                    }
                    this.storedData[i2].elem.setAttribute("stroke-width", this.storedData[i2].x.v * 2);
                  }
                }
              }
            }
          };
          MaskElement.prototype.getMaskelement = function() {
            return this.maskElement;
          };
          MaskElement.prototype.createLayerSolidPath = function() {
            var path = "M0,0 ";
            path += " h" + this.globalData.compSize.w;
            path += " v" + this.globalData.compSize.h;
            path += " h-" + this.globalData.compSize.w;
            path += " v-" + this.globalData.compSize.h + " ";
            return path;
          };
          MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
            var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
            var i2;
            var len;
            len = pathNodes._length;
            for (i2 = 1; i2 < len; i2 += 1) {
              pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[i2][0] + "," + pathNodes.i[i2][1] + " " + pathNodes.v[i2][0] + "," + pathNodes.v[i2][1];
            }
            if (pathNodes.c && len > 1) {
              pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
            }
            if (viewData.lastPath !== pathString) {
              var pathShapeValue = "";
              if (viewData.elem) {
                if (pathNodes.c) {
                  pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
                }
                viewData.elem.setAttribute("d", pathShapeValue);
              }
              viewData.lastPath = pathString;
            }
          };
          MaskElement.prototype.destroy = function() {
            this.element = null;
            this.globalData = null;
            this.maskElement = null;
            this.data = null;
            this.masksProperties = null;
          };
          function HierarchyElement() {
          }
          HierarchyElement.prototype = {
            initHierarchy: function() {
              this.hierarchy = [];
              this._isParent = false;
              this.checkParenting();
            },
            setHierarchy: function(hierarchy) {
              this.hierarchy = hierarchy;
            },
            setAsParent: function() {
              this._isParent = true;
            },
            checkParenting: function() {
              if (this.data.parent !== void 0) {
                this.comp.buildElementParenting(this, this.data.parent, []);
              }
            }
          };
          function FrameElement() {
          }
          FrameElement.prototype = {
            initFrame: function() {
              this._isFirstFrame = false;
              this.dynamicProperties = [];
              this._mdf = false;
            },
            prepareProperties: function(num, isVisible) {
              var i2;
              var len = this.dynamicProperties.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (isVisible || this._isParent && this.dynamicProperties[i2].propType === "transform") {
                  this.dynamicProperties[i2].getValue();
                  if (this.dynamicProperties[i2]._mdf) {
                    this.globalData._mdf = true;
                    this._mdf = true;
                  }
                }
              }
            },
            addDynamicProperty: function(prop) {
              if (this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
              }
            }
          };
          function TransformElement() {
          }
          TransformElement.prototype = {
            initTransform: function() {
              this.finalTransform = {
                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
                _matMdf: false,
                _opMdf: false,
                mat: new Matrix()
              };
              if (this.data.ao) {
                this.finalTransform.mProp.autoOriented = true;
              }
              if (this.data.ty !== 11) {
              }
            },
            renderTransform: function() {
              this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
              this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
              if (this.hierarchy) {
                var mat;
                var finalMat = this.finalTransform.mat;
                var i2 = 0;
                var len = this.hierarchy.length;
                if (!this.finalTransform._matMdf) {
                  while (i2 < len) {
                    if (this.hierarchy[i2].finalTransform.mProp._mdf) {
                      this.finalTransform._matMdf = true;
                      break;
                    }
                    i2 += 1;
                  }
                }
                if (this.finalTransform._matMdf) {
                  mat = this.finalTransform.mProp.v.props;
                  finalMat.cloneFromProps(mat);
                  for (i2 = 0; i2 < len; i2 += 1) {
                    mat = this.hierarchy[i2].finalTransform.mProp.v.props;
                    finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
                  }
                }
              }
            },
            globalToLocal: function(pt) {
              var transforms = [];
              transforms.push(this.finalTransform);
              var flag = true;
              var comp = this.comp;
              while (flag) {
                if (comp.finalTransform) {
                  if (comp.data.hasMask) {
                    transforms.splice(0, 0, comp.finalTransform);
                  }
                  comp = comp.comp;
                } else {
                  flag = false;
                }
              }
              var i2;
              var len = transforms.length;
              var ptNew;
              for (i2 = 0; i2 < len; i2 += 1) {
                ptNew = transforms[i2].mat.applyToPointArray(0, 0, 0);
                pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
              }
              return pt;
            },
            mHelper: new Matrix()
          };
          function RenderableElement() {
          }
          RenderableElement.prototype = {
            initRenderable: function() {
              this.isInRange = false;
              this.hidden = false;
              this.isTransparent = false;
              this.renderableComponents = [];
            },
            addRenderableComponent: function(component) {
              if (this.renderableComponents.indexOf(component) === -1) {
                this.renderableComponents.push(component);
              }
            },
            removeRenderableComponent: function(component) {
              if (this.renderableComponents.indexOf(component) !== -1) {
                this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
              }
            },
            prepareRenderableFrame: function(num) {
              this.checkLayerLimits(num);
            },
            checkTransparency: function() {
              if (this.finalTransform.mProp.o.v <= 0) {
                if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                  this.isTransparent = true;
                  this.hide();
                }
              } else if (this.isTransparent) {
                this.isTransparent = false;
                this.show();
              }
            },
            checkLayerLimits: function(num) {
              if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
                if (this.isInRange !== true) {
                  this.globalData._mdf = true;
                  this._mdf = true;
                  this.isInRange = true;
                  this.show();
                }
              } else if (this.isInRange !== false) {
                this.globalData._mdf = true;
                this.isInRange = false;
                this.hide();
              }
            },
            renderRenderable: function() {
              var i2;
              var len = this.renderableComponents.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.renderableComponents[i2].renderFrame(this._isFirstFrame);
              }
            },
            sourceRectAtTime: function() {
              return {
                top: 0,
                left: 0,
                width: 100,
                height: 100
              };
            },
            getLayerSize: function() {
              if (this.data.ty === 5) {
                return { w: this.data.textData.width, h: this.data.textData.height };
              }
              return { w: this.data.width, h: this.data.height };
            }
          };
          function RenderableDOMElement() {
          }
          (function() {
            var _prototype = {
              initElement: function(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
                this.initRenderable();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                this.createContent();
                this.hide();
              },
              hide: function() {
                if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                  var elem = this.baseElement || this.layerElement;
                  elem.style.display = "none";
                  this.hidden = true;
                }
              },
              show: function() {
                if (this.isInRange && !this.isTransparent) {
                  if (!this.data.hd) {
                    var elem = this.baseElement || this.layerElement;
                    elem.style.display = "block";
                  }
                  this.hidden = false;
                  this._isFirstFrame = true;
                }
              },
              renderFrame: function() {
                if (this.data.hd || this.hidden) {
                  return;
                }
                this.renderTransform();
                this.renderRenderable();
                this.renderElement();
                this.renderInnerContent();
                if (this._isFirstFrame) {
                  this._isFirstFrame = false;
                }
              },
              renderInnerContent: function() {
              },
              prepareFrame: function(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
                this.checkTransparency();
              },
              destroy: function() {
                this.innerElem = null;
                this.destroyBaseElement();
              }
            };
            extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
          })();
          function ProcessedElement(element, position) {
            this.elem = element;
            this.pos = position;
          }
          function SVGStyleData(data, level) {
            this.data = data;
            this.type = data.ty;
            this.d = "";
            this.lvl = level;
            this._mdf = false;
            this.closed = data.hd === true;
            this.pElem = createNS("path");
            this.msElem = null;
          }
          SVGStyleData.prototype.reset = function() {
            this.d = "";
            this._mdf = false;
          };
          function SVGShapeData(transformers, level, shape) {
            this.caches = [];
            this.styles = [];
            this.transformers = transformers;
            this.lStr = "";
            this.sh = shape;
            this.lvl = level;
            this._isAnimated = !!shape.k;
            var i2 = 0;
            var len = transformers.length;
            while (i2 < len) {
              if (transformers[i2].mProps.dynamicProperties.length) {
                this._isAnimated = true;
                break;
              }
              i2 += 1;
            }
          }
          SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = true;
          };
          function SVGTransformData(mProps, op, container) {
            this.transform = {
              mProps,
              op,
              container
            };
            this.elements = [];
            this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
          }
          function SVGStrokeStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
            this.d = new DashProperty(elem, data.d || {}, "svg", this);
            this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
            this.style = styleOb;
            this._isAnimated = !!this._isAnimated;
          }
          extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
          function SVGFillStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
            this.style = styleOb;
          }
          extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
          function SVGGradientFillStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.initGradientData(elem, data, styleOb);
          }
          SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
            this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
            this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
            this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
            this.g = new GradientProperty(elem, data.g, this);
            this.style = styleOb;
            this.stops = [];
            this.setGradientData(styleOb.pElem, data);
            this.setGradientOpacity(data, styleOb);
            this._isAnimated = !!this._isAnimated;
          };
          SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {
            var gradientId = createElementID();
            var gfill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
            gfill.setAttribute("id", gradientId);
            gfill.setAttribute("spreadMethod", "pad");
            gfill.setAttribute("gradientUnits", "userSpaceOnUse");
            var stops = [];
            var stop;
            var j;
            var jLen;
            jLen = data.g.p * 4;
            for (j = 0; j < jLen; j += 4) {
              stop = createNS("stop");
              gfill.appendChild(stop);
              stops.push(stop);
            }
            pathElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + locationHref + "#" + gradientId + ")");
            this.gf = gfill;
            this.cst = stops;
          };
          SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {
            if (this.g._hasOpacity && !this.g._collapsable) {
              var stop;
              var j;
              var jLen;
              var mask = createNS("mask");
              var maskElement = createNS("path");
              mask.appendChild(maskElement);
              var opacityId = createElementID();
              var maskId = createElementID();
              mask.setAttribute("id", maskId);
              var opFill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
              opFill.setAttribute("id", opacityId);
              opFill.setAttribute("spreadMethod", "pad");
              opFill.setAttribute("gradientUnits", "userSpaceOnUse");
              jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
              var stops = this.stops;
              for (j = data.g.p * 4; j < jLen; j += 2) {
                stop = createNS("stop");
                stop.setAttribute("stop-color", "rgb(255,255,255)");
                opFill.appendChild(stop);
                stops.push(stop);
              }
              maskElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + locationHref + "#" + opacityId + ")");
              if (data.ty === "gs") {
                maskElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
                maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
                if (data.lj === 1) {
                  maskElement.setAttribute("stroke-miterlimit", data.ml);
                }
              }
              this.of = opFill;
              this.ms = mask;
              this.ost = stops;
              this.maskId = maskId;
              styleOb.msElem = maskElement;
            }
          };
          extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
          function SVGGradientStrokeStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
            this.d = new DashProperty(elem, data.d || {}, "svg", this);
            this.initGradientData(elem, data, styleOb);
            this._isAnimated = !!this._isAnimated;
          }
          extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
          function ShapeGroupData() {
            this.it = [];
            this.prevViewData = [];
            this.gr = createNS("g");
          }
          var SVGElementsRenderer = function() {
            var _identityMatrix = new Matrix();
            var _matrixHelper = new Matrix();
            var ob = {
              createRenderFunction
            };
            function createRenderFunction(data) {
              switch (data.ty) {
                case "fl":
                  return renderFill;
                case "gf":
                  return renderGradient;
                case "gs":
                  return renderGradientStroke;
                case "st":
                  return renderStroke;
                case "sh":
                case "el":
                case "rc":
                case "sr":
                  return renderPath;
                case "tr":
                  return renderContentTransform;
                default:
                  return null;
              }
            }
            function renderContentTransform(styleData, itemData, isFirstFrame) {
              if (isFirstFrame || itemData.transform.op._mdf) {
                itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
              }
              if (isFirstFrame || itemData.transform.mProps._mdf) {
                itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
              }
            }
            function renderPath(styleData, itemData, isFirstFrame) {
              var j;
              var jLen;
              var pathStringTransformed;
              var redraw;
              var pathNodes;
              var l;
              var lLen = itemData.styles.length;
              var lvl = itemData.lvl;
              var paths;
              var mat;
              var props;
              var iterations;
              var k;
              for (l = 0; l < lLen; l += 1) {
                redraw = itemData.sh._mdf || isFirstFrame;
                if (itemData.styles[l].lvl < lvl) {
                  mat = _matrixHelper.reset();
                  iterations = lvl - itemData.styles[l].lvl;
                  k = itemData.transformers.length - 1;
                  while (!redraw && iterations > 0) {
                    redraw = itemData.transformers[k].mProps._mdf || redraw;
                    iterations -= 1;
                    k -= 1;
                  }
                  if (redraw) {
                    iterations = lvl - itemData.styles[l].lvl;
                    k = itemData.transformers.length - 1;
                    while (iterations > 0) {
                      props = itemData.transformers[k].mProps.v.props;
                      mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                      iterations -= 1;
                      k -= 1;
                    }
                  }
                } else {
                  mat = _identityMatrix;
                }
                paths = itemData.sh.paths;
                jLen = paths._length;
                if (redraw) {
                  pathStringTransformed = "";
                  for (j = 0; j < jLen; j += 1) {
                    pathNodes = paths.shapes[j];
                    if (pathNodes && pathNodes._length) {
                      pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                    }
                  }
                  itemData.caches[l] = pathStringTransformed;
                } else {
                  pathStringTransformed = itemData.caches[l];
                }
                itemData.styles[l].d += styleData.hd === true ? "" : pathStringTransformed;
                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
              }
            }
            function renderFill(styleData, itemData, isFirstFrame) {
              var styleElem = itemData.style;
              if (itemData.c._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
              }
              if (itemData.o._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
              }
            }
            function renderGradientStroke(styleData, itemData, isFirstFrame) {
              renderGradient(styleData, itemData, isFirstFrame);
              renderStroke(styleData, itemData, isFirstFrame);
            }
            function renderGradient(styleData, itemData, isFirstFrame) {
              var gfill = itemData.gf;
              var hasOpacity = itemData.g._hasOpacity;
              var pt1 = itemData.s.v;
              var pt2 = itemData.e.v;
              if (itemData.o._mdf || isFirstFrame) {
                var attr2 = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                itemData.style.pElem.setAttribute(attr2, itemData.o.v);
              }
              if (itemData.s._mdf || isFirstFrame) {
                var attr1 = styleData.t === 1 ? "x1" : "cx";
                var attr22 = attr1 === "x1" ? "y1" : "cy";
                gfill.setAttribute(attr1, pt1[0]);
                gfill.setAttribute(attr22, pt1[1]);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute(attr1, pt1[0]);
                  itemData.of.setAttribute(attr22, pt1[1]);
                }
              }
              var stops;
              var i2;
              var len;
              var stop;
              if (itemData.g._cmdf || isFirstFrame) {
                stops = itemData.cst;
                var cValues = itemData.g.c;
                len = stops.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  stop = stops[i2];
                  stop.setAttribute("offset", cValues[i2 * 4] + "%");
                  stop.setAttribute("stop-color", "rgb(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + ")");
                }
              }
              if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                var oValues = itemData.g.o;
                if (itemData.g._collapsable) {
                  stops = itemData.cst;
                } else {
                  stops = itemData.ost;
                }
                len = stops.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  stop = stops[i2];
                  if (!itemData.g._collapsable) {
                    stop.setAttribute("offset", oValues[i2 * 2] + "%");
                  }
                  stop.setAttribute("stop-opacity", oValues[i2 * 2 + 1]);
                }
              }
              if (styleData.t === 1) {
                if (itemData.e._mdf || isFirstFrame) {
                  gfill.setAttribute("x2", pt2[0]);
                  gfill.setAttribute("y2", pt2[1]);
                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("x2", pt2[0]);
                    itemData.of.setAttribute("y2", pt2[1]);
                  }
                }
              } else {
                var rad;
                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                  rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                  gfill.setAttribute("r", rad);
                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("r", rad);
                  }
                }
                if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                  if (!rad) {
                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                  }
                  var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                  var percent = itemData.h.v;
                  if (percent >= 1) {
                    percent = 0.99;
                  } else if (percent <= -1) {
                    percent = -0.99;
                  }
                  var dist = rad * percent;
                  var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                  var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                  gfill.setAttribute("fx", x);
                  gfill.setAttribute("fy", y);
                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("fx", x);
                    itemData.of.setAttribute("fy", y);
                  }
                }
              }
            }
            function renderStroke(styleData, itemData, isFirstFrame) {
              var styleElem = itemData.style;
              var d = itemData.d;
              if (d && (d._mdf || isFirstFrame) && d.dashStr) {
                styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
                styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
              }
              if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
                styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
              }
              if (itemData.o._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
              }
              if (itemData.w._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
                if (styleElem.msElem) {
                  styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
                }
              }
            }
            return ob;
          }();
          function ShapeTransformManager() {
            this.sequences = {};
            this.sequenceList = [];
            this.transform_key_count = 0;
          }
          ShapeTransformManager.prototype = {
            addTransformSequence: function(transforms) {
              var i2;
              var len = transforms.length;
              var key = "_";
              for (i2 = 0; i2 < len; i2 += 1) {
                key += transforms[i2].transform.key + "_";
              }
              var sequence = this.sequences[key];
              if (!sequence) {
                sequence = {
                  transforms: [].concat(transforms),
                  finalTransform: new Matrix(),
                  _mdf: false
                };
                this.sequences[key] = sequence;
                this.sequenceList.push(sequence);
              }
              return sequence;
            },
            processSequence: function(sequence, isFirstFrame) {
              var i2 = 0;
              var len = sequence.transforms.length;
              var _mdf = isFirstFrame;
              while (i2 < len && !isFirstFrame) {
                if (sequence.transforms[i2].transform.mProps._mdf) {
                  _mdf = true;
                  break;
                }
                i2 += 1;
              }
              if (_mdf) {
                var props;
                sequence.finalTransform.reset();
                for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                  props = sequence.transforms[i2].transform.mProps.v.props;
                  sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                }
              }
              sequence._mdf = _mdf;
            },
            processSequences: function(isFirstFrame) {
              var i2;
              var len = this.sequenceList.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.processSequence(this.sequenceList[i2], isFirstFrame);
              }
            },
            getNewKey: function() {
              this.transform_key_count += 1;
              return "_" + this.transform_key_count;
            }
          };
          function BaseElement() {
          }
          BaseElement.prototype = {
            checkMasks: function() {
              if (!this.data.hasMask) {
                return false;
              }
              var i2 = 0;
              var len = this.data.masksProperties.length;
              while (i2 < len) {
                if (this.data.masksProperties[i2].mode !== "n" && this.data.masksProperties[i2].cl !== false) {
                  return true;
                }
                i2 += 1;
              }
              return false;
            },
            initExpressions: function() {
              this.layerInterface = LayerExpressionInterface(this);
              if (this.data.hasMask && this.maskManager) {
                this.layerInterface.registerMaskInterface(this.maskManager);
              }
              var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
              this.layerInterface.registerEffectsInterface(effectsInterface);
              if (this.data.ty === 0 || this.data.xt) {
                this.compInterface = CompExpressionInterface(this);
              } else if (this.data.ty === 4) {
                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
                this.layerInterface.content = this.layerInterface.shapeInterface;
              } else if (this.data.ty === 5) {
                this.layerInterface.textInterface = TextExpressionInterface(this);
                this.layerInterface.text = this.layerInterface.textInterface;
              }
            },
            setBlendMode: function() {
              var blendModeValue = getBlendMode(this.data.bm);
              var elem = this.baseElement || this.layerElement;
              elem.style["mix-blend-mode"] = blendModeValue;
            },
            initBaseData: function(data, globalData, comp) {
              this.globalData = globalData;
              this.comp = comp;
              this.data = data;
              this.layerId = createElementID();
              if (!this.data.sr) {
                this.data.sr = 1;
              }
              this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
            },
            getType: function() {
              return this.type;
            },
            sourceRectAtTime: function() {
            }
          };
          function NullElement(data, globalData, comp) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initFrame();
            this.initTransform(data, globalData, comp);
            this.initHierarchy();
          }
          NullElement.prototype.prepareFrame = function(num) {
            this.prepareProperties(num, true);
          };
          NullElement.prototype.renderFrame = function() {
          };
          NullElement.prototype.getBaseElement = function() {
            return null;
          };
          NullElement.prototype.destroy = function() {
          };
          NullElement.prototype.sourceRectAtTime = function() {
          };
          NullElement.prototype.hide = function() {
          };
          extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
          function SVGBaseElement() {
          }
          SVGBaseElement.prototype = {
            initRendererElement: function() {
              this.layerElement = createNS("g");
            },
            createContainerElements: function() {
              this.matteElement = createNS("g");
              this.transformedElement = this.layerElement;
              this.maskedElement = this.layerElement;
              this._sizeChanged = false;
              var layerElementParent = null;
              var filId;
              var fil;
              var gg;
              if (this.data.td) {
                if (this.data.td == 3 || this.data.td == 1) {
                  var masker = createNS("mask");
                  masker.setAttribute("id", this.layerId);
                  masker.setAttribute("mask-type", this.data.td == 3 ? "luminance" : "alpha");
                  masker.appendChild(this.layerElement);
                  layerElementParent = masker;
                  this.globalData.defs.appendChild(masker);
                  if (!featureSupport.maskType && this.data.td == 1) {
                    masker.setAttribute("mask-type", "luminance");
                    filId = createElementID();
                    fil = filtersFactory.createFilter(filId);
                    this.globalData.defs.appendChild(fil);
                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                    gg = createNS("g");
                    gg.appendChild(this.layerElement);
                    layerElementParent = gg;
                    masker.appendChild(gg);
                    gg.setAttribute("filter", "url(" + locationHref + "#" + filId + ")");
                  }
                } else if (this.data.td == 2) {
                  var maskGroup = createNS("mask");
                  maskGroup.setAttribute("id", this.layerId);
                  maskGroup.setAttribute("mask-type", "alpha");
                  var maskGrouper = createNS("g");
                  maskGroup.appendChild(maskGrouper);
                  filId = createElementID();
                  fil = filtersFactory.createFilter(filId);
                  var feCTr = createNS("feComponentTransfer");
                  feCTr.setAttribute("in", "SourceGraphic");
                  fil.appendChild(feCTr);
                  var feFunc = createNS("feFuncA");
                  feFunc.setAttribute("type", "table");
                  feFunc.setAttribute("tableValues", "1.0 0.0");
                  feCTr.appendChild(feFunc);
                  this.globalData.defs.appendChild(fil);
                  var alphaRect = createNS("rect");
                  alphaRect.setAttribute("width", this.comp.data.w);
                  alphaRect.setAttribute("height", this.comp.data.h);
                  alphaRect.setAttribute("x", "0");
                  alphaRect.setAttribute("y", "0");
                  alphaRect.setAttribute("fill", "#ffffff");
                  alphaRect.setAttribute("opacity", "0");
                  maskGrouper.setAttribute("filter", "url(" + locationHref + "#" + filId + ")");
                  maskGrouper.appendChild(alphaRect);
                  maskGrouper.appendChild(this.layerElement);
                  layerElementParent = maskGrouper;
                  if (!featureSupport.maskType) {
                    maskGroup.setAttribute("mask-type", "luminance");
                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                    gg = createNS("g");
                    maskGrouper.appendChild(alphaRect);
                    gg.appendChild(this.layerElement);
                    layerElementParent = gg;
                    maskGrouper.appendChild(gg);
                  }
                  this.globalData.defs.appendChild(maskGroup);
                }
              } else if (this.data.tt) {
                this.matteElement.appendChild(this.layerElement);
                layerElementParent = this.matteElement;
                this.baseElement = this.matteElement;
              } else {
                this.baseElement = this.layerElement;
              }
              if (this.data.ln) {
                this.layerElement.setAttribute("id", this.data.ln);
              }
              if (this.data.cl) {
                this.layerElement.setAttribute("class", this.data.cl);
              }
              if (this.data.ty === 0 && !this.data.hd) {
                var cp = createNS("clipPath");
                var pt = createNS("path");
                pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                var clipId = createElementID();
                cp.setAttribute("id", clipId);
                cp.appendChild(pt);
                this.globalData.defs.appendChild(cp);
                if (this.checkMasks()) {
                  var cpGroup = createNS("g");
                  cpGroup.setAttribute("clip-path", "url(" + locationHref + "#" + clipId + ")");
                  cpGroup.appendChild(this.layerElement);
                  this.transformedElement = cpGroup;
                  if (layerElementParent) {
                    layerElementParent.appendChild(this.transformedElement);
                  } else {
                    this.baseElement = this.transformedElement;
                  }
                } else {
                  this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + clipId + ")");
                }
              }
              if (this.data.bm !== 0) {
                this.setBlendMode();
              }
            },
            renderElement: function() {
              if (this.finalTransform._matMdf) {
                this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS());
              }
              if (this.finalTransform._opMdf) {
                this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v);
              }
            },
            destroyBaseElement: function() {
              this.layerElement = null;
              this.matteElement = null;
              this.maskManager.destroy();
            },
            getBaseElement: function() {
              if (this.data.hd) {
                return null;
              }
              return this.baseElement;
            },
            createRenderableComponents: function() {
              this.maskManager = new MaskElement(this.data, this, this.globalData);
              this.renderableEffectsManager = new SVGEffects(this);
            },
            setMatte: function(id2) {
              if (!this.matteElement) {
                return;
              }
              this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id2 + ")");
            }
          };
          function IShapeElement() {
          }
          IShapeElement.prototype = {
            addShapeToModifiers: function(data) {
              var i2;
              var len = this.shapeModifiers.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.shapeModifiers[i2].addShape(data);
              }
            },
            isShapeInAnimatedModifiers: function(data) {
              var i2 = 0;
              var len = this.shapeModifiers.length;
              while (i2 < len) {
                if (this.shapeModifiers[i2].isAnimatedWithShape(data)) {
                  return true;
                }
              }
              return false;
            },
            renderModifiers: function() {
              if (!this.shapeModifiers.length) {
                return;
              }
              var i2;
              var len = this.shapes.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.shapes[i2].sh.reset();
              }
              len = this.shapeModifiers.length;
              var shouldBreakProcess;
              for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                shouldBreakProcess = this.shapeModifiers[i2].processShapes(this._isFirstFrame);
                if (shouldBreakProcess) {
                  break;
                }
              }
            },
            searchProcessedElement: function(elem) {
              var elements = this.processedElements;
              var i2 = 0;
              var len = elements.length;
              while (i2 < len) {
                if (elements[i2].elem === elem) {
                  return elements[i2].pos;
                }
                i2 += 1;
              }
              return 0;
            },
            addProcessedElement: function(elem, pos) {
              var elements = this.processedElements;
              var i2 = elements.length;
              while (i2) {
                i2 -= 1;
                if (elements[i2].elem === elem) {
                  elements[i2].pos = pos;
                  return;
                }
              }
              elements.push(new ProcessedElement(elem, pos));
            },
            prepareFrame: function(num) {
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
            }
          };
          function ITextElement() {
          }
          ITextElement.prototype.initElement = function(data, globalData, comp) {
            this.lettersChangedFlag = true;
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
            this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
            this.initTransform(data, globalData, comp);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
            this.textAnimator.searchProperties(this.dynamicProperties);
          };
          ITextElement.prototype.prepareFrame = function(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
              this.buildNewText();
              this.textProperty._isFirstFrame = false;
              this.textProperty._mdf = false;
            }
          };
          ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
            var j;
            var jLen = shapes.length;
            var pathNodes;
            var shapeStr = "";
            for (j = 0; j < jLen; j += 1) {
              pathNodes = shapes[j].ks.k;
              shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
            }
            return shapeStr;
          };
          ITextElement.prototype.updateDocumentData = function(newData, index3) {
            this.textProperty.updateDocumentData(newData, index3);
          };
          ITextElement.prototype.canResizeFont = function(_canResize) {
            this.textProperty.canResizeFont(_canResize);
          };
          ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
            this.textProperty.setMinimumFontSize(_fontSize);
          };
          ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
            if (documentData.ps) {
              matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
            }
            matrixHelper.translate(0, -documentData.ls, 0);
            switch (documentData.j) {
              case 1:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
                break;
              case 2:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
                break;
              default:
                break;
            }
            matrixHelper.translate(xPos, yPos, 0);
          };
          ITextElement.prototype.buildColor = function(colorData) {
            return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
          };
          ITextElement.prototype.emptyProp = new LetterProps();
          ITextElement.prototype.destroy = function() {
          };
          function ICompElement() {
          }
          extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
          ICompElement.prototype.initElement = function(data, globalData, comp) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initTransform(data, globalData, comp);
            this.initRenderable();
            this.initHierarchy();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            if (this.data.xt || !globalData.progressiveLoad) {
              this.buildAllItems();
            }
            this.hide();
          };
          ICompElement.prototype.prepareFrame = function(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            if (!this.isInRange && !this.data.xt) {
              return;
            }
            if (!this.tm._placeholder) {
              var timeRemapped = this.tm.v;
              if (timeRemapped === this.data.op) {
                timeRemapped = this.data.op - 1;
              }
              this.renderedFrame = timeRemapped;
            } else {
              this.renderedFrame = num / this.data.sr;
            }
            var i2;
            var len = this.elements.length;
            if (!this.completeLayers) {
              this.checkLayers(this.renderedFrame);
            }
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].prepareFrame(this.renderedFrame - this.layers[i2].st);
                if (this.elements[i2]._mdf) {
                  this._mdf = true;
                }
              }
            }
          };
          ICompElement.prototype.renderInnerContent = function() {
            var i2;
            var len = this.layers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].renderFrame();
              }
            }
          };
          ICompElement.prototype.setElements = function(elems) {
            this.elements = elems;
          };
          ICompElement.prototype.getElements = function() {
            return this.elements;
          };
          ICompElement.prototype.destroyElements = function() {
            var i2;
            var len = this.layers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.elements[i2]) {
                this.elements[i2].destroy();
              }
            }
          };
          ICompElement.prototype.destroy = function() {
            this.destroyElements();
            this.destroyBaseElement();
          };
          function IImageElement(data, globalData, comp) {
            this.assetData = globalData.getAssetData(data.refId);
            this.initElement(data, globalData, comp);
            this.sourceRect = {
              top: 0,
              left: 0,
              width: this.assetData.w,
              height: this.assetData.h
            };
          }
          extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
          IImageElement.prototype.createContent = function() {
            var assetPath = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image");
            this.innerElem.setAttribute("width", this.assetData.w + "px");
            this.innerElem.setAttribute("height", this.assetData.h + "px");
            this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
            this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
            this.layerElement.appendChild(this.innerElem);
          };
          IImageElement.prototype.sourceRectAtTime = function() {
            return this.sourceRect;
          };
          function ISolidElement(data, globalData, comp) {
            this.initElement(data, globalData, comp);
          }
          extendPrototype([IImageElement], ISolidElement);
          ISolidElement.prototype.createContent = function() {
            var rect = createNS("rect");
            rect.setAttribute("width", this.data.sw);
            rect.setAttribute("height", this.data.sh);
            rect.setAttribute("fill", this.data.sc);
            this.layerElement.appendChild(rect);
          };
          function AudioElement(data, globalData, comp) {
            this.initFrame();
            this.initRenderable();
            this.assetData = globalData.getAssetData(data.refId);
            this.initBaseData(data, globalData, comp);
            this._isPlaying = false;
            this._canPlay = false;
            var assetPath = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(assetPath);
            this._currentTime = 0;
            this.globalData.audioController.addAudio(this);
            this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
          }
          AudioElement.prototype.prepareFrame = function(num) {
            this.prepareRenderableFrame(num, true);
            this.prepareProperties(num, true);
            if (!this.tm._placeholder) {
              var timeRemapped = this.tm.v;
              this._currentTime = timeRemapped;
            } else {
              this._currentTime = num / this.data.sr;
            }
          };
          extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
          AudioElement.prototype.renderFrame = function() {
            if (this.isInRange && this._canPlay) {
              if (!this._isPlaying) {
                this.audio.play();
                this.audio.seek(this._currentTime / this.globalData.frameRate);
                this._isPlaying = true;
              } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
                this.audio.seek(this._currentTime / this.globalData.frameRate);
              }
            }
          };
          AudioElement.prototype.show = function() {
          };
          AudioElement.prototype.hide = function() {
            this.audio.pause();
            this._isPlaying = false;
          };
          AudioElement.prototype.pause = function() {
            this.audio.pause();
            this._isPlaying = false;
            this._canPlay = false;
          };
          AudioElement.prototype.resume = function() {
            this._canPlay = true;
          };
          AudioElement.prototype.setRate = function(rateValue) {
            this.audio.rate(rateValue);
          };
          AudioElement.prototype.volume = function(volumeValue) {
            this.audio.volume(volumeValue);
          };
          AudioElement.prototype.getBaseElement = function() {
            return null;
          };
          AudioElement.prototype.destroy = function() {
          };
          AudioElement.prototype.sourceRectAtTime = function() {
          };
          AudioElement.prototype.initExpressions = function() {
          };
          function SVGCompElement(data, globalData, comp) {
            this.layers = data.layers;
            this.supports3d = true;
            this.completeLayers = false;
            this.pendingElements = [];
            this.elements = this.layers ? createSizedArray(this.layers.length) : [];
            this.initElement(data, globalData, comp);
            this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
          }
          extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);
          function SVGTextLottieElement(data, globalData, comp) {
            this.textSpans = [];
            this.renderType = "svg";
            this.initElement(data, globalData, comp);
          }
          extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
          SVGTextLottieElement.prototype.createContent = function() {
            if (this.data.singleShape && !this.globalData.fontManager.chars) {
              this.textContainer = createNS("text");
            }
          };
          SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
            var i2 = 0;
            var len = textArray.length;
            var textContents = [];
            var currentTextContent = "";
            while (i2 < len) {
              if (textArray[i2] === String.fromCharCode(13) || textArray[i2] === String.fromCharCode(3)) {
                textContents.push(currentTextContent);
                currentTextContent = "";
              } else {
                currentTextContent += textArray[i2];
              }
              i2 += 1;
            }
            textContents.push(currentTextContent);
            return textContents;
          };
          SVGTextLottieElement.prototype.buildNewText = function() {
            var i2;
            var len;
            var documentData = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
            if (documentData.fc) {
              this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
            } else {
              this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
            }
            if (documentData.sc) {
              this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
              this.layerElement.setAttribute("stroke-width", documentData.sw);
            }
            this.layerElement.setAttribute("font-size", documentData.finalSize);
            var fontData = this.globalData.fontManager.getFontByName(documentData.f);
            if (fontData.fClass) {
              this.layerElement.setAttribute("class", fontData.fClass);
            } else {
              this.layerElement.setAttribute("font-family", fontData.fFamily);
              var fWeight = documentData.fWeight;
              var fStyle = documentData.fStyle;
              this.layerElement.setAttribute("font-style", fStyle);
              this.layerElement.setAttribute("font-weight", fWeight);
            }
            this.layerElement.setAttribute("aria-label", documentData.t);
            var letters = documentData.l || [];
            var usesGlyphs = !!this.globalData.fontManager.chars;
            len = letters.length;
            var tSpan;
            var matrixHelper = this.mHelper;
            var shapes;
            var shapeStr = "";
            var singleShape = this.data.singleShape;
            var xPos = 0;
            var yPos = 0;
            var firstLine = true;
            var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
            if (singleShape && !usesGlyphs && !documentData.sz) {
              var tElement = this.textContainer;
              var justify = "start";
              switch (documentData.j) {
                case 1:
                  justify = "end";
                  break;
                case 2:
                  justify = "middle";
                  break;
                default:
                  justify = "start";
                  break;
              }
              tElement.setAttribute("text-anchor", justify);
              tElement.setAttribute("letter-spacing", trackingOffset);
              var textContent = this.buildTextContents(documentData.finalText);
              len = textContent.length;
              yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                tSpan = this.textSpans[i2] || createNS("tspan");
                tSpan.textContent = textContent[i2];
                tSpan.setAttribute("x", 0);
                tSpan.setAttribute("y", yPos);
                tSpan.style.display = "inherit";
                tElement.appendChild(tSpan);
                this.textSpans[i2] = tSpan;
                yPos += documentData.finalLineHeight;
              }
              this.layerElement.appendChild(tElement);
            } else {
              var cachedSpansLength = this.textSpans.length;
              var shapeData;
              var charData;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (!usesGlyphs || !singleShape || i2 === 0) {
                  tSpan = cachedSpansLength > i2 ? this.textSpans[i2] : createNS(usesGlyphs ? "path" : "text");
                  if (cachedSpansLength <= i2) {
                    tSpan.setAttribute("stroke-linecap", "butt");
                    tSpan.setAttribute("stroke-linejoin", "round");
                    tSpan.setAttribute("stroke-miterlimit", "4");
                    this.textSpans[i2] = tSpan;
                    this.layerElement.appendChild(tSpan);
                  }
                  tSpan.style.display = "inherit";
                }
                matrixHelper.reset();
                matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                if (singleShape) {
                  if (letters[i2].n) {
                    xPos = -trackingOffset;
                    yPos += documentData.yOffset;
                    yPos += firstLine ? 1 : 0;
                    firstLine = false;
                  }
                  this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
                  xPos += letters[i2].l || 0;
                  xPos += trackingOffset;
                }
                if (usesGlyphs) {
                  charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                  shapeData = charData && charData.data || {};
                  shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
                  if (!singleShape) {
                    tSpan.setAttribute("d", this.createPathShape(matrixHelper, shapes));
                  } else {
                    shapeStr += this.createPathShape(matrixHelper, shapes);
                  }
                } else {
                  if (singleShape) {
                    tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                  }
                  tSpan.textContent = letters[i2].val;
                  tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                }
              }
              if (singleShape && tSpan) {
                tSpan.setAttribute("d", shapeStr);
              }
            }
            while (i2 < this.textSpans.length) {
              this.textSpans[i2].style.display = "none";
              i2 += 1;
            }
            this._sizeChanged = true;
          };
          SVGTextLottieElement.prototype.sourceRectAtTime = function() {
            this.prepareFrame(this.comp.renderedFrame - this.data.st);
            this.renderInnerContent();
            if (this._sizeChanged) {
              this._sizeChanged = false;
              var textBox = this.layerElement.getBBox();
              this.bbox = {
                top: textBox.y,
                left: textBox.x,
                width: textBox.width,
                height: textBox.height
              };
            }
            return this.bbox;
          };
          SVGTextLottieElement.prototype.renderInnerContent = function() {
            if (!this.data.singleShape) {
              this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
              if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                this._sizeChanged = true;
                var i2;
                var len;
                var renderedLetters = this.textAnimator.renderedLetters;
                var letters = this.textProperty.currentData.l;
                len = letters.length;
                var renderedLetter;
                var textSpan;
                for (i2 = 0; i2 < len; i2 += 1) {
                  if (!letters[i2].n) {
                    renderedLetter = renderedLetters[i2];
                    textSpan = this.textSpans[i2];
                    if (renderedLetter._mdf.m) {
                      textSpan.setAttribute("transform", renderedLetter.m);
                    }
                    if (renderedLetter._mdf.o) {
                      textSpan.setAttribute("opacity", renderedLetter.o);
                    }
                    if (renderedLetter._mdf.sw) {
                      textSpan.setAttribute("stroke-width", renderedLetter.sw);
                    }
                    if (renderedLetter._mdf.sc) {
                      textSpan.setAttribute("stroke", renderedLetter.sc);
                    }
                    if (renderedLetter._mdf.fc) {
                      textSpan.setAttribute("fill", renderedLetter.fc);
                    }
                  }
                }
              }
            }
          };
          function SVGShapeElement(data, globalData, comp) {
            this.shapes = [];
            this.shapesData = data.shapes;
            this.stylesList = [];
            this.shapeModifiers = [];
            this.itemsData = [];
            this.processedElements = [];
            this.animatedContents = [];
            this.initElement(data, globalData, comp);
            this.prevViewData = [];
          }
          extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
          SVGShapeElement.prototype.initSecondaryElement = function() {
          };
          SVGShapeElement.prototype.identityMatrix = new Matrix();
          SVGShapeElement.prototype.buildExpressionInterface = function() {
          };
          SVGShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
            this.filterUniqueShapes();
          };
          SVGShapeElement.prototype.filterUniqueShapes = function() {
            var i2;
            var len = this.shapes.length;
            var shape;
            var j;
            var jLen = this.stylesList.length;
            var style;
            var tempShapes = [];
            var areAnimated = false;
            for (j = 0; j < jLen; j += 1) {
              style = this.stylesList[j];
              areAnimated = false;
              tempShapes.length = 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                shape = this.shapes[i2];
                if (shape.styles.indexOf(style) !== -1) {
                  tempShapes.push(shape);
                  areAnimated = shape._isAnimated || areAnimated;
                }
              }
              if (tempShapes.length > 1 && areAnimated) {
                this.setShapesAsAnimated(tempShapes);
              }
            }
          };
          SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
            var i2;
            var len = shapes.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapes[i2].setAsAnimated();
            }
          };
          SVGShapeElement.prototype.createStyleElement = function(data, level) {
            var elementData;
            var styleOb = new SVGStyleData(data, level);
            var pathElement = styleOb.pElem;
            if (data.ty === "st") {
              elementData = new SVGStrokeStyleData(this, data, styleOb);
            } else if (data.ty === "fl") {
              elementData = new SVGFillStyleData(this, data, styleOb);
            } else if (data.ty === "gf" || data.ty === "gs") {
              var GradientConstructor = data.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
              elementData = new GradientConstructor(this, data, styleOb);
              this.globalData.defs.appendChild(elementData.gf);
              if (elementData.maskId) {
                this.globalData.defs.appendChild(elementData.ms);
                this.globalData.defs.appendChild(elementData.of);
                pathElement.setAttribute("mask", "url(" + locationHref + "#" + elementData.maskId + ")");
              }
            }
            if (data.ty === "st" || data.ty === "gs") {
              pathElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
              pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
              pathElement.setAttribute("fill-opacity", "0");
              if (data.lj === 1) {
                pathElement.setAttribute("stroke-miterlimit", data.ml);
              }
            }
            if (data.r === 2) {
              pathElement.setAttribute("fill-rule", "evenodd");
            }
            if (data.ln) {
              pathElement.setAttribute("id", data.ln);
            }
            if (data.cl) {
              pathElement.setAttribute("class", data.cl);
            }
            if (data.bm) {
              pathElement.style["mix-blend-mode"] = getBlendMode(data.bm);
            }
            this.stylesList.push(styleOb);
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };
          SVGShapeElement.prototype.createGroupElement = function(data) {
            var elementData = new ShapeGroupData();
            if (data.ln) {
              elementData.gr.setAttribute("id", data.ln);
            }
            if (data.cl) {
              elementData.gr.setAttribute("class", data.cl);
            }
            if (data.bm) {
              elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm);
            }
            return elementData;
          };
          SVGShapeElement.prototype.createTransformElement = function(data, container) {
            var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
            var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };
          SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
            var ty = 4;
            if (data.ty === "rc") {
              ty = 5;
            } else if (data.ty === "el") {
              ty = 6;
            } else if (data.ty === "sr") {
              ty = 7;
            }
            var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
            var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
            this.shapes.push(elementData);
            this.addShapeToModifiers(elementData);
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };
          SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
            var i2 = 0;
            var len = this.animatedContents.length;
            while (i2 < len) {
              if (this.animatedContents[i2].element === element) {
                return;
              }
              i2 += 1;
            }
            this.animatedContents.push({
              fn: SVGElementsRenderer.createRenderFunction(data),
              element,
              data
            });
          };
          SVGShapeElement.prototype.setElementStyles = function(elementData) {
            var arr = elementData.styles;
            var j;
            var jLen = this.stylesList.length;
            for (j = 0; j < jLen; j += 1) {
              if (!this.stylesList[j].closed) {
                arr.push(this.stylesList[j]);
              }
            }
          };
          SVGShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = true;
            var i2;
            var len = this.itemsData.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.prevViewData[i2] = this.itemsData[i2];
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
            this.filterUniqueShapes();
            len = this.dynamicProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.dynamicProperties[i2].getValue();
            }
            this.renderModifiers();
          };
          SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render4) {
            var ownTransformers = [].concat(transformers);
            var i2;
            var len = arr.length - 1;
            var j;
            var jLen;
            var ownStyles = [];
            var ownModifiers = [];
            var currentTransform;
            var modifier2;
            var processedPos;
            for (i2 = len; i2 >= 0; i2 -= 1) {
              processedPos = this.searchProcessedElement(arr[i2]);
              if (!processedPos) {
                arr[i2]._render = render4;
              } else {
                itemsData[i2] = prevViewData[processedPos - 1];
              }
              if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs") {
                if (!processedPos) {
                  itemsData[i2] = this.createStyleElement(arr[i2], level);
                } else {
                  itemsData[i2].style.closed = false;
                }
                if (arr[i2]._render) {
                  if (itemsData[i2].style.pElem.parentNode !== container) {
                    container.appendChild(itemsData[i2].style.pElem);
                  }
                }
                ownStyles.push(itemsData[i2].style);
              } else if (arr[i2].ty === "gr") {
                if (!processedPos) {
                  itemsData[i2] = this.createGroupElement(arr[i2]);
                } else {
                  jLen = itemsData[i2].it.length;
                  for (j = 0; j < jLen; j += 1) {
                    itemsData[i2].prevViewData[j] = itemsData[i2].it[j];
                  }
                }
                this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, itemsData[i2].gr, level + 1, ownTransformers, render4);
                if (arr[i2]._render) {
                  if (itemsData[i2].gr.parentNode !== container) {
                    container.appendChild(itemsData[i2].gr);
                  }
                }
              } else if (arr[i2].ty === "tr") {
                if (!processedPos) {
                  itemsData[i2] = this.createTransformElement(arr[i2], container);
                }
                currentTransform = itemsData[i2].transform;
                ownTransformers.push(currentTransform);
              } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
                if (!processedPos) {
                  itemsData[i2] = this.createShapeElement(arr[i2], ownTransformers, level);
                }
                this.setElementStyles(itemsData[i2]);
              } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "ms" || arr[i2].ty === "pb") {
                if (!processedPos) {
                  modifier2 = ShapeModifiers.getModifier(arr[i2].ty);
                  modifier2.init(this, arr[i2]);
                  itemsData[i2] = modifier2;
                  this.shapeModifiers.push(modifier2);
                } else {
                  modifier2 = itemsData[i2];
                  modifier2.closed = false;
                }
                ownModifiers.push(modifier2);
              } else if (arr[i2].ty === "rp") {
                if (!processedPos) {
                  modifier2 = ShapeModifiers.getModifier(arr[i2].ty);
                  itemsData[i2] = modifier2;
                  modifier2.init(this, arr, i2, itemsData);
                  this.shapeModifiers.push(modifier2);
                  render4 = false;
                } else {
                  modifier2 = itemsData[i2];
                  modifier2.closed = true;
                }
                ownModifiers.push(modifier2);
              }
              this.addProcessedElement(arr[i2], i2 + 1);
            }
            len = ownStyles.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              ownStyles[i2].closed = true;
            }
            len = ownModifiers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              ownModifiers[i2].closed = true;
            }
          };
          SVGShapeElement.prototype.renderInnerContent = function() {
            this.renderModifiers();
            var i2;
            var len = this.stylesList.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.stylesList[i2].reset();
            }
            this.renderShape();
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.stylesList[i2]._mdf || this._isFirstFrame) {
                if (this.stylesList[i2].msElem) {
                  this.stylesList[i2].msElem.setAttribute("d", this.stylesList[i2].d);
                  this.stylesList[i2].d = "M0 0" + this.stylesList[i2].d;
                }
                this.stylesList[i2].pElem.setAttribute("d", this.stylesList[i2].d || "M0 0");
              }
            }
          };
          SVGShapeElement.prototype.renderShape = function() {
            var i2;
            var len = this.animatedContents.length;
            var animatedContent;
            for (i2 = 0; i2 < len; i2 += 1) {
              animatedContent = this.animatedContents[i2];
              if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
                animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
              }
            }
          };
          SVGShapeElement.prototype.destroy = function() {
            this.destroyBaseElement();
            this.shapesData = null;
            this.itemsData = null;
          };
          function SVGTintFilter(filter2, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
            feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
            feColorMatrix.setAttribute("result", "f1");
            filter2.appendChild(feColorMatrix);
            feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
            feColorMatrix.setAttribute("result", "f2");
            filter2.appendChild(feColorMatrix);
            this.matrixFilter = feColorMatrix;
            if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
              var feMerge = createNS("feMerge");
              filter2.appendChild(feMerge);
              var feMergeNode;
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", "SourceGraphic");
              feMerge.appendChild(feMergeNode);
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", "f2");
              feMerge.appendChild(feMergeNode);
            }
          }
          SVGTintFilter.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var colorBlack = this.filterManager.effectElements[0].p.v;
              var colorWhite = this.filterManager.effectElements[1].p.v;
              var opacity = this.filterManager.effectElements[2].p.v / 100;
              this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 " + opacity + " 0");
            }
          };
          function SVGFillFilter(filter2, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
            filter2.appendChild(feColorMatrix);
            this.matrixFilter = feColorMatrix;
          }
          SVGFillFilter.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var color = this.filterManager.effectElements[2].p.v;
              var opacity = this.filterManager.effectElements[6].p.v;
              this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
            }
          };
          function SVGGaussianBlurEffect(filter2, filterManager) {
            filter2.setAttribute("x", "-100%");
            filter2.setAttribute("y", "-100%");
            filter2.setAttribute("width", "300%");
            filter2.setAttribute("height", "300%");
            this.filterManager = filterManager;
            var feGaussianBlur = createNS("feGaussianBlur");
            filter2.appendChild(feGaussianBlur);
            this.feGaussianBlur = feGaussianBlur;
          }
          SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var kBlurrinessToSigma = 0.3;
              var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
              var dimensions = this.filterManager.effectElements[1].p.v;
              var sigmaX = dimensions == 3 ? 0 : sigma;
              var sigmaY = dimensions == 2 ? 0 : sigma;
              this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
              var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
              this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
            }
          };
          function SVGStrokeEffect(elem, filterManager) {
            this.initialized = false;
            this.filterManager = filterManager;
            this.elem = elem;
            this.paths = [];
          }
          SVGStrokeEffect.prototype.initialize = function() {
            var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            var path;
            var groupPath;
            var i2;
            var len;
            if (this.filterManager.effectElements[1].p.v === 1) {
              len = this.elem.maskManager.masksProperties.length;
              i2 = 0;
            } else {
              i2 = this.filterManager.effectElements[0].p.v - 1;
              len = i2 + 1;
            }
            groupPath = createNS("g");
            groupPath.setAttribute("fill", "none");
            groupPath.setAttribute("stroke-linecap", "round");
            groupPath.setAttribute("stroke-dashoffset", 1);
            for (i2; i2 < len; i2 += 1) {
              path = createNS("path");
              groupPath.appendChild(path);
              this.paths.push({ p: path, m: i2 });
            }
            if (this.filterManager.effectElements[10].p.v === 3) {
              var mask = createNS("mask");
              var id2 = createElementID();
              mask.setAttribute("id", id2);
              mask.setAttribute("mask-type", "alpha");
              mask.appendChild(groupPath);
              this.elem.globalData.defs.appendChild(mask);
              var g = createNS("g");
              g.setAttribute("mask", "url(" + locationHref + "#" + id2 + ")");
              while (elemChildren[0]) {
                g.appendChild(elemChildren[0]);
              }
              this.elem.layerElement.appendChild(g);
              this.masker = mask;
              groupPath.setAttribute("stroke", "#fff");
            } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
              if (this.filterManager.effectElements[10].p.v === 2) {
                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                while (elemChildren.length) {
                  this.elem.layerElement.removeChild(elemChildren[0]);
                }
              }
              this.elem.layerElement.appendChild(groupPath);
              this.elem.layerElement.removeAttribute("mask");
              groupPath.setAttribute("stroke", "#fff");
            }
            this.initialized = true;
            this.pathMasker = groupPath;
          };
          SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
            if (!this.initialized) {
              this.initialize();
            }
            var i2;
            var len = this.paths.length;
            var mask;
            var path;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.paths[i2].m !== -1) {
                mask = this.elem.maskManager.viewData[this.paths[i2].m];
                path = this.paths[i2].p;
                if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
                  path.setAttribute("d", mask.lastPath);
                }
                if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
                  var dasharrayValue;
                  if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                    var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                    var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                    var l = path.getTotalLength();
                    dasharrayValue = "0 0 0 " + l * s + " ";
                    var lineLength = l * (e - s);
                    var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                    var units = Math.floor(lineLength / segment);
                    var j;
                    for (j = 0; j < units; j += 1) {
                      dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                    }
                    dasharrayValue += "0 " + l * 10 + " 0 0";
                  } else {
                    dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                  }
                  path.setAttribute("stroke-dasharray", dasharrayValue);
                }
              }
            }
            if (forceRender || this.filterManager.effectElements[4].p._mdf) {
              this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
            }
            if (forceRender || this.filterManager.effectElements[6].p._mdf) {
              this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
            }
            if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
              if (forceRender || this.filterManager.effectElements[3].p._mdf) {
                var color = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
              }
            }
          };
          function SVGTritoneFilter(filter2, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
            feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
            feColorMatrix.setAttribute("result", "f1");
            filter2.appendChild(feColorMatrix);
            var feComponentTransfer = createNS("feComponentTransfer");
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter2.appendChild(feComponentTransfer);
            this.matrixFilter = feComponentTransfer;
            var feFuncR = createNS("feFuncR");
            feFuncR.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncR);
            this.feFuncR = feFuncR;
            var feFuncG = createNS("feFuncG");
            feFuncG.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncG);
            this.feFuncG = feFuncG;
            var feFuncB = createNS("feFuncB");
            feFuncB.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncB);
            this.feFuncB = feFuncB;
          }
          SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var color1 = this.filterManager.effectElements[0].p.v;
              var color2 = this.filterManager.effectElements[1].p.v;
              var color3 = this.filterManager.effectElements[2].p.v;
              var tableR = color3[0] + " " + color2[0] + " " + color1[0];
              var tableG = color3[1] + " " + color2[1] + " " + color1[1];
              var tableB = color3[2] + " " + color2[2] + " " + color1[2];
              this.feFuncR.setAttribute("tableValues", tableR);
              this.feFuncG.setAttribute("tableValues", tableG);
              this.feFuncB.setAttribute("tableValues", tableB);
            }
          };
          function SVGProLevelsFilter(filter2, filterManager) {
            this.filterManager = filterManager;
            var effectElements = this.filterManager.effectElements;
            var feComponentTransfer = createNS("feComponentTransfer");
            if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
              this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
            }
            if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
              this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
            }
            if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
              this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
            }
            if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
              this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
            }
            if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
              feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
              filter2.appendChild(feComponentTransfer);
              feComponentTransfer = createNS("feComponentTransfer");
            }
            if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
              feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
              filter2.appendChild(feComponentTransfer);
              this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
              this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
              this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
            }
          }
          SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
            var feFunc = createNS(type);
            feFunc.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFunc);
            return feFunc;
          };
          SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
            var cnt = 0;
            var segments = 256;
            var perc;
            var min = Math.min(inputBlack, inputWhite);
            var max = Math.max(inputBlack, inputWhite);
            var table = Array.call(null, { length: segments });
            var colorValue;
            var pos = 0;
            var outputDelta = outputWhite - outputBlack;
            var inputDelta = inputWhite - inputBlack;
            while (cnt <= 256) {
              perc = cnt / 256;
              if (perc <= min) {
                colorValue = inputDelta < 0 ? outputWhite : outputBlack;
              } else if (perc >= max) {
                colorValue = inputDelta < 0 ? outputBlack : outputWhite;
              } else {
                colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
              }
              table[pos] = colorValue;
              pos += 1;
              cnt += 256 / (segments - 1);
            }
            return table.join(" ");
          };
          SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var val;
              var effectElements = this.filterManager.effectElements;
              if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
                val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
                this.feFuncRComposed.setAttribute("tableValues", val);
                this.feFuncGComposed.setAttribute("tableValues", val);
                this.feFuncBComposed.setAttribute("tableValues", val);
              }
              if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
                val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
                this.feFuncR.setAttribute("tableValues", val);
              }
              if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
                val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
                this.feFuncG.setAttribute("tableValues", val);
              }
              if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
                val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
                this.feFuncB.setAttribute("tableValues", val);
              }
              if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
                val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
                this.feFuncA.setAttribute("tableValues", val);
              }
            }
          };
          function SVGDropShadowEffect(filter2, filterManager) {
            var filterSize = filterManager.container.globalData.renderConfig.filterSize;
            filter2.setAttribute("x", filterSize.x);
            filter2.setAttribute("y", filterSize.y);
            filter2.setAttribute("width", filterSize.width);
            filter2.setAttribute("height", filterSize.height);
            this.filterManager = filterManager;
            var feGaussianBlur = createNS("feGaussianBlur");
            feGaussianBlur.setAttribute("in", "SourceAlpha");
            feGaussianBlur.setAttribute("result", "drop_shadow_1");
            feGaussianBlur.setAttribute("stdDeviation", "0");
            this.feGaussianBlur = feGaussianBlur;
            filter2.appendChild(feGaussianBlur);
            var feOffset = createNS("feOffset");
            feOffset.setAttribute("dx", "25");
            feOffset.setAttribute("dy", "0");
            feOffset.setAttribute("in", "drop_shadow_1");
            feOffset.setAttribute("result", "drop_shadow_2");
            this.feOffset = feOffset;
            filter2.appendChild(feOffset);
            var feFlood = createNS("feFlood");
            feFlood.setAttribute("flood-color", "#00ff00");
            feFlood.setAttribute("flood-opacity", "1");
            feFlood.setAttribute("result", "drop_shadow_3");
            this.feFlood = feFlood;
            filter2.appendChild(feFlood);
            var feComposite = createNS("feComposite");
            feComposite.setAttribute("in", "drop_shadow_3");
            feComposite.setAttribute("in2", "drop_shadow_2");
            feComposite.setAttribute("operator", "in");
            feComposite.setAttribute("result", "drop_shadow_4");
            filter2.appendChild(feComposite);
            var feMerge = createNS("feMerge");
            filter2.appendChild(feMerge);
            var feMergeNode;
            feMergeNode = createNS("feMergeNode");
            feMerge.appendChild(feMergeNode);
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", "SourceGraphic");
            this.feMergeNode = feMergeNode;
            this.feMerge = feMerge;
            this.originalNodeAdded = false;
            feMerge.appendChild(feMergeNode);
          }
          SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
            if (forceRender || this.filterManager._mdf) {
              if (forceRender || this.filterManager.effectElements[4].p._mdf) {
                this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
              }
              if (forceRender || this.filterManager.effectElements[0].p._mdf) {
                var col = this.filterManager.effectElements[0].p.v;
                this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
              }
              if (forceRender || this.filterManager.effectElements[1].p._mdf) {
                this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
              }
              if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                var distance = this.filterManager.effectElements[3].p.v;
                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                var x = distance * Math.cos(angle);
                var y = distance * Math.sin(angle);
                this.feOffset.setAttribute("dx", x);
                this.feOffset.setAttribute("dy", y);
              }
            }
          };
          var _svgMatteSymbols = [];
          function SVGMatte3Effect(filterElem, filterManager, elem) {
            this.initialized = false;
            this.filterManager = filterManager;
            this.filterElem = filterElem;
            this.elem = elem;
            elem.matteElement = createNS("g");
            elem.matteElement.appendChild(elem.layerElement);
            elem.matteElement.appendChild(elem.transformedElement);
            elem.baseElement = elem.matteElement;
          }
          SVGMatte3Effect.prototype.findSymbol = function(mask) {
            var i2 = 0;
            var len = _svgMatteSymbols.length;
            while (i2 < len) {
              if (_svgMatteSymbols[i2] === mask) {
                return _svgMatteSymbols[i2];
              }
              i2 += 1;
            }
            return null;
          };
          SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
            var parentNode = mask.layerElement.parentNode;
            if (!parentNode) {
              return;
            }
            var children2 = parentNode.children;
            var i2 = 0;
            var len = children2.length;
            while (i2 < len) {
              if (children2[i2] === mask.layerElement) {
                break;
              }
              i2 += 1;
            }
            var nextChild;
            if (i2 <= len - 2) {
              nextChild = children2[i2 + 1];
            }
            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);
            if (nextChild) {
              parentNode.insertBefore(useElem, nextChild);
            } else {
              parentNode.appendChild(useElem);
            }
          };
          SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
            if (!this.findSymbol(mask)) {
              var symbolId = createElementID();
              var masker = createNS("mask");
              masker.setAttribute("id", mask.layerId);
              masker.setAttribute("mask-type", "alpha");
              _svgMatteSymbols.push(mask);
              var defs = elem.globalData.defs;
              defs.appendChild(masker);
              var symbol = createNS("symbol");
              symbol.setAttribute("id", symbolId);
              this.replaceInParent(mask, symbolId);
              symbol.appendChild(mask.layerElement);
              defs.appendChild(symbol);
              var useElem = createNS("use");
              useElem.setAttribute("href", "#" + symbolId);
              masker.appendChild(useElem);
              mask.data.hd = false;
              mask.show();
            }
            elem.setMatte(mask.layerId);
          };
          SVGMatte3Effect.prototype.initialize = function() {
            var ind = this.filterManager.effectElements[0].p.v;
            var elements = this.elem.comp.elements;
            var i2 = 0;
            var len = elements.length;
            while (i2 < len) {
              if (elements[i2] && elements[i2].data.ind === ind) {
                this.setElementAsMask(this.elem, elements[i2]);
              }
              i2 += 1;
            }
            this.initialized = true;
          };
          SVGMatte3Effect.prototype.renderFrame = function() {
            if (!this.initialized) {
              this.initialize();
            }
          };
          function SVGEffects() {
          }
          var animationManager = function() {
            var moduleOb = {};
            var registeredAnimations = [];
            var initTime = 0;
            var len = 0;
            var playingAnimationsNum = 0;
            var _stopped = true;
            var _isFrozen = false;
            function removeElement(ev) {
              var i2 = 0;
              var animItem = ev.target;
              while (i2 < len) {
                if (registeredAnimations[i2].animation === animItem) {
                  registeredAnimations.splice(i2, 1);
                  i2 -= 1;
                  len -= 1;
                  if (!animItem.isPaused) {
                    subtractPlayingCount();
                  }
                }
                i2 += 1;
              }
            }
            function registerAnimation(element, animationData2) {
              if (!element) {
                return null;
              }
              var i2 = 0;
              while (i2 < len) {
                if (registeredAnimations[i2].elem === element && registeredAnimations[i2].elem !== null) {
                  return registeredAnimations[i2].animation;
                }
                i2 += 1;
              }
              var animItem = new AnimationItem();
              setupAnimation(animItem, element);
              animItem.setData(element, animationData2);
              return animItem;
            }
            function getRegisteredAnimations() {
              var i2;
              var lenAnims = registeredAnimations.length;
              var animations = [];
              for (i2 = 0; i2 < lenAnims; i2 += 1) {
                animations.push(registeredAnimations[i2].animation);
              }
              return animations;
            }
            function addPlayingCount() {
              playingAnimationsNum += 1;
              activate();
            }
            function subtractPlayingCount() {
              playingAnimationsNum -= 1;
            }
            function setupAnimation(animItem, element) {
              animItem.addEventListener("destroy", removeElement);
              animItem.addEventListener("_active", addPlayingCount);
              animItem.addEventListener("_idle", subtractPlayingCount);
              registeredAnimations.push({ elem: element, animation: animItem });
              len += 1;
            }
            function loadAnimation2(params) {
              var animItem = new AnimationItem();
              setupAnimation(animItem, null);
              animItem.setParams(params);
              return animItem;
            }
            function setSpeed(val, animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.setSpeed(val, animation);
              }
            }
            function setDirection(val, animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.setDirection(val, animation);
              }
            }
            function play(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.play(animation);
              }
            }
            function resume(nowTime) {
              var elapsedTime = nowTime - initTime;
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.advanceTime(elapsedTime);
              }
              initTime = nowTime;
              if (playingAnimationsNum && !_isFrozen) {
                window2.requestAnimationFrame(resume);
              } else {
                _stopped = true;
              }
            }
            function first(nowTime) {
              initTime = nowTime;
              window2.requestAnimationFrame(resume);
            }
            function pause(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.pause(animation);
              }
            }
            function goToAndStop(value, isFrame, animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.goToAndStop(value, isFrame, animation);
              }
            }
            function stop(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.stop(animation);
              }
            }
            function togglePause(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.togglePause(animation);
              }
            }
            function destroy(animation) {
              var i2;
              for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                registeredAnimations[i2].animation.destroy(animation);
              }
            }
            function searchAnimations2(animationData2, standalone2, renderer2) {
              var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
              var i2;
              var lenAnims = animElements.length;
              for (i2 = 0; i2 < lenAnims; i2 += 1) {
                if (renderer2) {
                  animElements[i2].setAttribute("data-bm-type", renderer2);
                }
                registerAnimation(animElements[i2], animationData2);
              }
              if (standalone2 && lenAnims === 0) {
                if (!renderer2) {
                  renderer2 = "svg";
                }
                var body2 = document.getElementsByTagName("body")[0];
                body2.innerText = "";
                var div = createTag("div");
                div.style.width = "100%";
                div.style.height = "100%";
                div.setAttribute("data-bm-type", renderer2);
                body2.appendChild(div);
                registerAnimation(div, animationData2);
              }
            }
            function resize2() {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.resize();
              }
            }
            function activate() {
              if (!_isFrozen && playingAnimationsNum) {
                if (_stopped) {
                  window2.requestAnimationFrame(first);
                  _stopped = false;
                }
              }
            }
            function freeze() {
              _isFrozen = true;
            }
            function unfreeze() {
              _isFrozen = false;
              activate();
            }
            function setVolume(val, animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.setVolume(val, animation);
              }
            }
            function mute(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.mute(animation);
              }
            }
            function unmute(animation) {
              var i2;
              for (i2 = 0; i2 < len; i2 += 1) {
                registeredAnimations[i2].animation.unmute(animation);
              }
            }
            moduleOb.registerAnimation = registerAnimation;
            moduleOb.loadAnimation = loadAnimation2;
            moduleOb.setSpeed = setSpeed;
            moduleOb.setDirection = setDirection;
            moduleOb.play = play;
            moduleOb.pause = pause;
            moduleOb.stop = stop;
            moduleOb.togglePause = togglePause;
            moduleOb.searchAnimations = searchAnimations2;
            moduleOb.resize = resize2;
            moduleOb.goToAndStop = goToAndStop;
            moduleOb.destroy = destroy;
            moduleOb.freeze = freeze;
            moduleOb.unfreeze = unfreeze;
            moduleOb.setVolume = setVolume;
            moduleOb.mute = mute;
            moduleOb.unmute = unmute;
            moduleOb.getRegisteredAnimations = getRegisteredAnimations;
            return moduleOb;
          }();
          var AnimationItem = function() {
            this._cbs = [];
            this.name = "";
            this.path = "";
            this.isLoaded = false;
            this.currentFrame = 0;
            this.currentRawFrame = 0;
            this.firstFrame = 0;
            this.totalFrames = 0;
            this.frameRate = 0;
            this.frameMult = 0;
            this.playSpeed = 1;
            this.playDirection = 1;
            this.playCount = 0;
            this.animationData = {};
            this.assets = [];
            this.isPaused = true;
            this.autoplay = false;
            this.loop = true;
            this.renderer = null;
            this.animationID = createElementID();
            this.assetsPath = "";
            this.timeCompleted = 0;
            this.segmentPos = 0;
            this.isSubframeEnabled = subframeEnabled;
            this.segments = [];
            this._idle = true;
            this._completedLoop = false;
            this.projectInterface = ProjectInterface();
            this.imagePreloader = new ImagePreloader();
            this.audioController = audioControllerFactory();
            this.markers = [];
            this.configAnimation = this.configAnimation.bind(this);
            this.onSetupError = this.onSetupError.bind(this);
            this.onSegmentComplete = this.onSegmentComplete.bind(this);
          };
          extendPrototype([BaseEvent], AnimationItem);
          AnimationItem.prototype.setParams = function(params) {
            if (params.wrapper || params.container) {
              this.wrapper = params.wrapper || params.container;
            }
            var animType = "svg";
            if (params.animType) {
              animType = params.animType;
            } else if (params.renderer) {
              animType = params.renderer;
            }
            switch (animType) {
              case "canvas":
                this.renderer = new CanvasRenderer(this, params.rendererSettings);
                break;
              case "svg":
                this.renderer = new SVGRenderer(this, params.rendererSettings);
                break;
              default:
                this.renderer = new HybridRenderer(this, params.rendererSettings);
                break;
            }
            this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
            this.renderer.setProjectInterface(this.projectInterface);
            this.animType = animType;
            if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
              this.loop = true;
            } else if (params.loop === false) {
              this.loop = false;
            } else {
              this.loop = parseInt(params.loop, 10);
            }
            this.autoplay = "autoplay" in params ? params.autoplay : true;
            this.name = params.name ? params.name : "";
            this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
            this.assetsPath = params.assetsPath;
            this.initialSegment = params.initialSegment;
            if (params.audioFactory) {
              this.audioController.setAudioFactory(params.audioFactory);
            }
            if (params.animationData) {
              this.setupAnimation(params.animationData);
            } else if (params.path) {
              if (params.path.lastIndexOf("\\") !== -1) {
                this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
              } else {
                this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
              }
              this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
              this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
              dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
            }
          };
          AnimationItem.prototype.onSetupError = function() {
            this.trigger("data_failed");
          };
          AnimationItem.prototype.setupAnimation = function(data) {
            dataManager.completeAnimation(data, this.configAnimation);
          };
          AnimationItem.prototype.setData = function(wrapper, animationData2) {
            if (animationData2) {
              if (typeof animationData2 !== "object") {
                animationData2 = JSON.parse(animationData2);
              }
            }
            var params = {
              wrapper,
              animationData: animationData2
            };
            var wrapperAttributes = wrapper.attributes;
            params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
            params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : "canvas";
            var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
            if (loop === "false") {
              params.loop = false;
            } else if (loop === "true") {
              params.loop = true;
            } else if (loop !== "") {
              params.loop = parseInt(loop, 10);
            }
            var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
            params.autoplay = autoplay !== "false";
            params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
            var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
            if (prerender === "false") {
              params.prerender = false;
            }
            this.setParams(params);
          };
          AnimationItem.prototype.includeLayers = function(data) {
            if (data.op > this.animationData.op) {
              this.animationData.op = data.op;
              this.totalFrames = Math.floor(data.op - this.animationData.ip);
            }
            var layers = this.animationData.layers;
            var i2;
            var len = layers.length;
            var newLayers = data.layers;
            var j;
            var jLen = newLayers.length;
            for (j = 0; j < jLen; j += 1) {
              i2 = 0;
              while (i2 < len) {
                if (layers[i2].id === newLayers[j].id) {
                  layers[i2] = newLayers[j];
                  break;
                }
                i2 += 1;
              }
            }
            if (data.chars || data.fonts) {
              this.renderer.globalData.fontManager.addChars(data.chars);
              this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
            }
            if (data.assets) {
              len = data.assets.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.animationData.assets.push(data.assets[i2]);
              }
            }
            this.animationData.__complete = false;
            dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
          };
          AnimationItem.prototype.onSegmentComplete = function(data) {
            this.animationData = data;
            if (expressionsPlugin) {
              expressionsPlugin.initExpressions(this);
            }
            this.loadNextSegment();
          };
          AnimationItem.prototype.loadNextSegment = function() {
            var segments = this.animationData.segments;
            if (!segments || segments.length === 0 || !this.autoloadSegments) {
              this.trigger("data_ready");
              this.timeCompleted = this.totalFrames;
              return;
            }
            var segment = segments.shift();
            this.timeCompleted = segment.time * this.frameRate;
            var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1;
            dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
              this.trigger("data_failed");
            }.bind(this));
          };
          AnimationItem.prototype.loadSegments = function() {
            var segments = this.animationData.segments;
            if (!segments) {
              this.timeCompleted = this.totalFrames;
            }
            this.loadNextSegment();
          };
          AnimationItem.prototype.imagesLoaded = function() {
            this.trigger("loaded_images");
            this.checkLoaded();
          };
          AnimationItem.prototype.preloadImages = function() {
            this.imagePreloader.setAssetsPath(this.assetsPath);
            this.imagePreloader.setPath(this.path);
            this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
          };
          AnimationItem.prototype.configAnimation = function(animData) {
            if (!this.renderer) {
              return;
            }
            try {
              this.animationData = animData;
              if (this.initialSegment) {
                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
                this.firstFrame = Math.round(this.initialSegment[0]);
              } else {
                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
                this.firstFrame = Math.round(this.animationData.ip);
              }
              this.renderer.configAnimation(animData);
              if (!animData.assets) {
                animData.assets = [];
              }
              this.assets = this.animationData.assets;
              this.frameRate = this.animationData.fr;
              this.frameMult = this.animationData.fr / 1e3;
              this.renderer.searchExtraCompositions(animData.assets);
              this.markers = markerParser(animData.markers || []);
              this.trigger("config_ready");
              this.preloadImages();
              this.loadSegments();
              this.updaFrameModifier();
              this.waitForFontsLoaded();
              if (this.isPaused) {
                this.audioController.pause();
              }
            } catch (error) {
              this.triggerConfigError(error);
            }
          };
          AnimationItem.prototype.waitForFontsLoaded = function() {
            if (!this.renderer) {
              return;
            }
            if (this.renderer.globalData.fontManager.isLoaded) {
              this.checkLoaded();
            } else {
              setTimeout(this.waitForFontsLoaded.bind(this), 20);
            }
          };
          AnimationItem.prototype.checkLoaded = function() {
            if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
              this.isLoaded = true;
              if (expressionsPlugin) {
                expressionsPlugin.initExpressions(this);
              }
              this.renderer.initItems();
              setTimeout(function() {
                this.trigger("DOMLoaded");
              }.bind(this), 0);
              this.gotoFrame();
              if (this.autoplay) {
                this.play();
              }
            }
          };
          AnimationItem.prototype.resize = function() {
            this.renderer.updateContainerSize();
          };
          AnimationItem.prototype.setSubframe = function(flag) {
            this.isSubframeEnabled = !!flag;
          };
          AnimationItem.prototype.gotoFrame = function() {
            this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
            if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
              this.currentFrame = this.timeCompleted;
            }
            this.trigger("enterFrame");
            this.renderFrame();
            this.trigger("drawnFrame");
          };
          AnimationItem.prototype.renderFrame = function() {
            if (this.isLoaded === false || !this.renderer) {
              return;
            }
            try {
              this.renderer.renderFrame(this.currentFrame + this.firstFrame);
            } catch (error) {
              this.triggerRenderFrameError(error);
            }
          };
          AnimationItem.prototype.play = function(name) {
            if (name && this.name !== name) {
              return;
            }
            if (this.isPaused === true) {
              this.isPaused = false;
              this.audioController.resume();
              if (this._idle) {
                this._idle = false;
                this.trigger("_active");
              }
            }
          };
          AnimationItem.prototype.pause = function(name) {
            if (name && this.name !== name) {
              return;
            }
            if (this.isPaused === false) {
              this.isPaused = true;
              this._idle = true;
              this.trigger("_idle");
              this.audioController.pause();
            }
          };
          AnimationItem.prototype.togglePause = function(name) {
            if (name && this.name !== name) {
              return;
            }
            if (this.isPaused === true) {
              this.play();
            } else {
              this.pause();
            }
          };
          AnimationItem.prototype.stop = function(name) {
            if (name && this.name !== name) {
              return;
            }
            this.pause();
            this.playCount = 0;
            this._completedLoop = false;
            this.setCurrentRawFrameValue(0);
          };
          AnimationItem.prototype.getMarkerData = function(markerName) {
            var marker;
            for (var i2 = 0; i2 < this.markers.length; i2 += 1) {
              marker = this.markers[i2];
              if (marker.payload && marker.payload.name === markerName) {
                return marker;
              }
            }
            return null;
          };
          AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {
            if (name && this.name !== name) {
              return;
            }
            var numValue = Number(value);
            if (isNaN(numValue)) {
              var marker = this.getMarkerData(value);
              if (marker) {
                this.goToAndStop(marker.time, true);
              }
            } else if (isFrame) {
              this.setCurrentRawFrameValue(value);
            } else {
              this.setCurrentRawFrameValue(value * this.frameModifier);
            }
            this.pause();
          };
          AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {
            if (name && this.name !== name) {
              return;
            }
            var numValue = Number(value);
            if (isNaN(numValue)) {
              var marker = this.getMarkerData(value);
              if (marker) {
                if (!marker.duration) {
                  this.goToAndStop(marker.time, true);
                } else {
                  this.playSegments([marker.time, marker.time + marker.duration], true);
                }
              }
            } else {
              this.goToAndStop(numValue, isFrame, name);
            }
            this.play();
          };
          AnimationItem.prototype.advanceTime = function(value) {
            if (this.isPaused === true || this.isLoaded === false) {
              return;
            }
            var nextValue = this.currentRawFrame + value * this.frameModifier;
            var _isComplete = false;
            if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
              if (!this.loop || this.playCount === this.loop) {
                if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                  _isComplete = true;
                  nextValue = this.totalFrames - 1;
                }
              } else if (nextValue >= this.totalFrames) {
                this.playCount += 1;
                if (!this.checkSegments(nextValue % this.totalFrames)) {
                  this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                  this._completedLoop = true;
                  this.trigger("loopComplete");
                }
              } else {
                this.setCurrentRawFrameValue(nextValue);
              }
            } else if (nextValue < 0) {
              if (!this.checkSegments(nextValue % this.totalFrames)) {
                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                  this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                  if (!this._completedLoop) {
                    this._completedLoop = true;
                  } else {
                    this.trigger("loopComplete");
                  }
                } else {
                  _isComplete = true;
                  nextValue = 0;
                }
              }
            } else {
              this.setCurrentRawFrameValue(nextValue);
            }
            if (_isComplete) {
              this.setCurrentRawFrameValue(nextValue);
              this.pause();
              this.trigger("complete");
            }
          };
          AnimationItem.prototype.adjustSegment = function(arr, offset2) {
            this.playCount = 0;
            if (arr[1] < arr[0]) {
              if (this.frameModifier > 0) {
                if (this.playSpeed < 0) {
                  this.setSpeed(-this.playSpeed);
                } else {
                  this.setDirection(-1);
                }
              }
              this.totalFrames = arr[0] - arr[1];
              this.timeCompleted = this.totalFrames;
              this.firstFrame = arr[1];
              this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset2);
            } else if (arr[1] > arr[0]) {
              if (this.frameModifier < 0) {
                if (this.playSpeed < 0) {
                  this.setSpeed(-this.playSpeed);
                } else {
                  this.setDirection(1);
                }
              }
              this.totalFrames = arr[1] - arr[0];
              this.timeCompleted = this.totalFrames;
              this.firstFrame = arr[0];
              this.setCurrentRawFrameValue(1e-3 + offset2);
            }
            this.trigger("segmentStart");
          };
          AnimationItem.prototype.setSegment = function(init6, end) {
            var pendingFrame = -1;
            if (this.isPaused) {
              if (this.currentRawFrame + this.firstFrame < init6) {
                pendingFrame = init6;
              } else if (this.currentRawFrame + this.firstFrame > end) {
                pendingFrame = end - init6;
              }
            }
            this.firstFrame = init6;
            this.totalFrames = end - init6;
            this.timeCompleted = this.totalFrames;
            if (pendingFrame !== -1) {
              this.goToAndStop(pendingFrame, true);
            }
          };
          AnimationItem.prototype.playSegments = function(arr, forceFlag) {
            if (forceFlag) {
              this.segments.length = 0;
            }
            if (typeof arr[0] === "object") {
              var i2;
              var len = arr.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.segments.push(arr[i2]);
              }
            } else {
              this.segments.push(arr);
            }
            if (this.segments.length && forceFlag) {
              this.adjustSegment(this.segments.shift(), 0);
            }
            if (this.isPaused) {
              this.play();
            }
          };
          AnimationItem.prototype.resetSegments = function(forceFlag) {
            this.segments.length = 0;
            this.segments.push([this.animationData.ip, this.animationData.op]);
            if (forceFlag) {
              this.checkSegments(0);
            }
          };
          AnimationItem.prototype.checkSegments = function(offset2) {
            if (this.segments.length) {
              this.adjustSegment(this.segments.shift(), offset2);
              return true;
            }
            return false;
          };
          AnimationItem.prototype.destroy = function(name) {
            if (name && this.name !== name || !this.renderer) {
              return;
            }
            this.renderer.destroy();
            this.imagePreloader.destroy();
            this.trigger("destroy");
            this._cbs = null;
            this.onEnterFrame = null;
            this.onLoopComplete = null;
            this.onComplete = null;
            this.onSegmentStart = null;
            this.onDestroy = null;
            this.renderer = null;
            this.renderer = null;
            this.imagePreloader = null;
            this.projectInterface = null;
          };
          AnimationItem.prototype.setCurrentRawFrameValue = function(value) {
            this.currentRawFrame = value;
            this.gotoFrame();
          };
          AnimationItem.prototype.setSpeed = function(val) {
            this.playSpeed = val;
            this.updaFrameModifier();
          };
          AnimationItem.prototype.setDirection = function(val) {
            this.playDirection = val < 0 ? -1 : 1;
            this.updaFrameModifier();
          };
          AnimationItem.prototype.setVolume = function(val, name) {
            if (name && this.name !== name) {
              return;
            }
            this.audioController.setVolume(val);
          };
          AnimationItem.prototype.getVolume = function() {
            return this.audioController.getVolume();
          };
          AnimationItem.prototype.mute = function(name) {
            if (name && this.name !== name) {
              return;
            }
            this.audioController.mute();
          };
          AnimationItem.prototype.unmute = function(name) {
            if (name && this.name !== name) {
              return;
            }
            this.audioController.unmute();
          };
          AnimationItem.prototype.updaFrameModifier = function() {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
            this.audioController.setRate(this.playSpeed * this.playDirection);
          };
          AnimationItem.prototype.getPath = function() {
            return this.path;
          };
          AnimationItem.prototype.getAssetsPath = function(assetData) {
            var path = "";
            if (assetData.e) {
              path = assetData.p;
            } else if (this.assetsPath) {
              var imagePath = assetData.p;
              if (imagePath.indexOf("images/") !== -1) {
                imagePath = imagePath.split("/")[1];
              }
              path = this.assetsPath + imagePath;
            } else {
              path = this.path;
              path += assetData.u ? assetData.u : "";
              path += assetData.p;
            }
            return path;
          };
          AnimationItem.prototype.getAssetData = function(id2) {
            var i2 = 0;
            var len = this.assets.length;
            while (i2 < len) {
              if (id2 === this.assets[i2].id) {
                return this.assets[i2];
              }
              i2 += 1;
            }
            return null;
          };
          AnimationItem.prototype.hide = function() {
            this.renderer.hide();
          };
          AnimationItem.prototype.show = function() {
            this.renderer.show();
          };
          AnimationItem.prototype.getDuration = function(isFrame) {
            return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
          };
          AnimationItem.prototype.trigger = function(name) {
            if (this._cbs && this._cbs[name]) {
              switch (name) {
                case "enterFrame":
                case "drawnFrame":
                  this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                  break;
                case "loopComplete":
                  this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                  break;
                case "complete":
                  this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                  break;
                case "segmentStart":
                  this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                  break;
                case "destroy":
                  this.triggerEvent(name, new BMDestroyEvent(name, this));
                  break;
                default:
                  this.triggerEvent(name);
              }
            }
            if (name === "enterFrame" && this.onEnterFrame) {
              this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
            }
            if (name === "loopComplete" && this.onLoopComplete) {
              this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
            }
            if (name === "complete" && this.onComplete) {
              this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
            }
            if (name === "segmentStart" && this.onSegmentStart) {
              this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
            }
            if (name === "destroy" && this.onDestroy) {
              this.onDestroy.call(this, new BMDestroyEvent(name, this));
            }
          };
          AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
            var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
            this.triggerEvent("error", error);
            if (this.onError) {
              this.onError.call(this, error);
            }
          };
          AnimationItem.prototype.triggerConfigError = function(nativeError) {
            var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
            this.triggerEvent("error", error);
            if (this.onError) {
              this.onError.call(this, error);
            }
          };
          function EffectsManager() {
            this.effectElements = [];
          }
          var lottie = {};
          function setLocationHref(href) {
            locationHref = href;
          }
          function searchAnimations() {
            if (standalone === true) {
              animationManager.searchAnimations(animationData, standalone, renderer);
            } else {
              animationManager.searchAnimations();
            }
          }
          function setSubframeRendering(flag) {
            subframeEnabled = flag;
          }
          function setIDPrefix(prefix) {
            idPrefix = prefix;
          }
          function loadAnimation(params) {
            if (standalone === true) {
              params.animationData = JSON.parse(animationData);
            }
            return animationManager.loadAnimation(params);
          }
          function setQuality(value) {
            if (typeof value === "string") {
              switch (value) {
                case "high":
                  defaultCurveSegments = 200;
                  break;
                default:
                case "medium":
                  defaultCurveSegments = 50;
                  break;
                case "low":
                  defaultCurveSegments = 10;
                  break;
              }
            } else if (!isNaN(value) && value > 1) {
              defaultCurveSegments = value;
            }
            if (defaultCurveSegments >= 50) {
              roundValues(false);
            } else {
              roundValues(true);
            }
          }
          function inBrowser() {
            return typeof navigator !== "undefined";
          }
          function installPlugin(type, plugin) {
            if (type === "expressions") {
              expressionsPlugin = plugin;
            }
          }
          function getFactory(name) {
            switch (name) {
              case "propertyFactory":
                return PropertyFactory;
              case "shapePropertyFactory":
                return ShapePropertyFactory;
              case "matrix":
                return Matrix;
              default:
                return null;
            }
          }
          lottie.play = animationManager.play;
          lottie.pause = animationManager.pause;
          lottie.setLocationHref = setLocationHref;
          lottie.togglePause = animationManager.togglePause;
          lottie.setSpeed = animationManager.setSpeed;
          lottie.setDirection = animationManager.setDirection;
          lottie.stop = animationManager.stop;
          lottie.searchAnimations = searchAnimations;
          lottie.registerAnimation = animationManager.registerAnimation;
          lottie.loadAnimation = loadAnimation;
          lottie.setSubframeRendering = setSubframeRendering;
          lottie.resize = animationManager.resize;
          lottie.goToAndStop = animationManager.goToAndStop;
          lottie.destroy = animationManager.destroy;
          lottie.setQuality = setQuality;
          lottie.inBrowser = inBrowser;
          lottie.installPlugin = installPlugin;
          lottie.freeze = animationManager.freeze;
          lottie.unfreeze = animationManager.unfreeze;
          lottie.setVolume = animationManager.setVolume;
          lottie.mute = animationManager.mute;
          lottie.unmute = animationManager.unmute;
          lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
          lottie.useWebWorker = function(flag) {
            _useWebWorker = flag;
          };
          lottie.setIDPrefix = setIDPrefix;
          lottie.__getFactory = getFactory;
          lottie.version = "5.8.1";
          function checkReady() {
            if (document.readyState === "complete") {
              clearInterval(readyStateCheckInterval);
              searchAnimations();
            }
          }
          function getQueryVariable(variable) {
            var vars = queryString.split("&");
            for (var i2 = 0; i2 < vars.length; i2 += 1) {
              var pair = vars[i2].split("=");
              if (decodeURIComponent(pair[0]) == variable) {
                return decodeURIComponent(pair[1]);
              }
            }
            return null;
          }
          var standalone = "__[STANDALONE]__";
          var animationData = "__[ANIMATIONDATA]__";
          var renderer = "";
          var queryString;
          if (standalone) {
            var scripts = document.getElementsByTagName("script");
            var index2 = scripts.length - 1;
            var myScript = scripts[index2] || {
              src: ""
            };
            queryString = myScript.src.replace(/^[^\?]+\??/, "");
            renderer = getQueryVariable("renderer");
          }
          var readyStateCheckInterval = setInterval(checkReady, 100);
          return lottie;
        });
      }
    });
  
    // node_modules/tweakpane/dist/tweakpane.js
    var require_tweakpane = __commonJS({
      "node_modules/tweakpane/dist/tweakpane.js"(exports2, module2) {
        (function(global2, factory) {
          typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Tweakpane = {}));
        })(exports2, function(exports3) {
          "use strict";
          class Semver {
            constructor(text2) {
              const [core, prerelease] = text2.split("-");
              const coreComps = core.split(".");
              this.major = parseInt(coreComps[0], 10);
              this.minor = parseInt(coreComps[1], 10);
              this.patch = parseInt(coreComps[2], 10);
              this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
            }
            toString() {
              const core = [this.major, this.minor, this.patch].join(".");
              return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
            }
          }
          class BladeApi {
            constructor(controller) {
              this.controller_ = controller;
            }
            get disabled() {
              return this.controller_.viewProps.get("disabled");
            }
            set disabled(disabled) {
              this.controller_.viewProps.set("disabled", disabled);
            }
            get hidden() {
              return this.controller_.viewProps.get("hidden");
            }
            set hidden(hidden) {
              this.controller_.viewProps.set("hidden", hidden);
            }
            dispose() {
              this.controller_.viewProps.set("disposed", true);
            }
          }
          class TpEvent {
            constructor(target) {
              this.target = target;
            }
          }
          class TpChangeEvent extends TpEvent {
            constructor(target, value, presetKey, last) {
              super(target);
              this.value = value;
              this.presetKey = presetKey;
              this.last = last !== null && last !== void 0 ? last : true;
            }
          }
          class TpUpdateEvent extends TpEvent {
            constructor(target, value, presetKey) {
              super(target);
              this.value = value;
              this.presetKey = presetKey;
            }
          }
          class TpFoldEvent extends TpEvent {
            constructor(target, expanded) {
              super(target);
              this.expanded = expanded;
            }
          }
          function forceCast(v) {
            return v;
          }
          function isEmpty(value) {
            return value === null || value === void 0;
          }
          function deepEqualsArray(a1, a2) {
            if (a1.length !== a2.length) {
              return false;
            }
            for (let i2 = 0; i2 < a1.length; i2++) {
              if (a1[i2] !== a2[i2]) {
                return false;
              }
            }
            return true;
          }
          const CREATE_MESSAGE_MAP = {
            alreadydisposed: () => "View has been already disposed",
            invalidparams: (context3) => `Invalid parameters for '${context3.name}'`,
            nomatchingcontroller: (context3) => `No matching controller for '${context3.key}'`,
            nomatchingview: (context3) => `No matching view for '${JSON.stringify(context3.params)}'`,
            notbindable: () => `Value is not bindable`,
            propertynotfound: (context3) => `Property '${context3.name}' not found`,
            shouldneverhappen: () => "This error should never happen"
          };
          class TpError {
            constructor(config3) {
              var _a;
              this.message = (_a = CREATE_MESSAGE_MAP[config3.type](forceCast(config3.context))) !== null && _a !== void 0 ? _a : "Unexpected error";
              this.name = this.constructor.name;
              this.stack = new Error(this.message).stack;
              this.type = config3.type;
            }
            static alreadyDisposed() {
              return new TpError({ type: "alreadydisposed" });
            }
            static notBindable() {
              return new TpError({
                type: "notbindable"
              });
            }
            static propertyNotFound(name) {
              return new TpError({
                type: "propertynotfound",
                context: {
                  name
                }
              });
            }
            static shouldNeverHappen() {
              return new TpError({ type: "shouldneverhappen" });
            }
          }
          class BindingTarget {
            constructor(obj, key, opt_id) {
              this.obj_ = obj;
              this.key_ = key;
              this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
            }
            static isBindable(obj) {
              if (obj === null) {
                return false;
              }
              if (typeof obj !== "object") {
                return false;
              }
              return true;
            }
            get key() {
              return this.key_;
            }
            get presetKey() {
              return this.presetKey_;
            }
            read() {
              return this.obj_[this.key_];
            }
            write(value) {
              this.obj_[this.key_] = value;
            }
            writeProperty(name, value) {
              const valueObj = this.read();
              if (!BindingTarget.isBindable(valueObj)) {
                throw TpError.notBindable();
              }
              if (!(name in valueObj)) {
                throw TpError.propertyNotFound(name);
              }
              valueObj[name] = value;
            }
          }
          class ButtonApi extends BladeApi {
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            get title() {
              var _a;
              return (_a = this.controller_.valueController.props.get("title")) !== null && _a !== void 0 ? _a : "";
            }
            set title(title) {
              this.controller_.valueController.props.set("title", title);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              const emitter = this.controller_.valueController.emitter;
              emitter.on(eventName, () => {
                bh(new TpEvent(this));
              });
              return this;
            }
          }
          class Emitter {
            constructor() {
              this.observers_ = {};
            }
            on(eventName, handler) {
              let observers = this.observers_[eventName];
              if (!observers) {
                observers = this.observers_[eventName] = [];
              }
              observers.push({
                handler
              });
              return this;
            }
            off(eventName, handler) {
              const observers = this.observers_[eventName];
              if (observers) {
                this.observers_[eventName] = observers.filter((observer) => {
                  return observer.handler !== handler;
                });
              }
              return this;
            }
            emit(eventName, event2) {
              const observers = this.observers_[eventName];
              if (!observers) {
                return;
              }
              observers.forEach((observer) => {
                observer.handler(event2);
              });
            }
          }
          const PREFIX = "tp";
          function ClassName(viewName) {
            const fn = (opt_elementName, opt_modifier) => {
              return [
                PREFIX,
                "-",
                viewName,
                "v",
                opt_elementName ? `_${opt_elementName}` : "",
                opt_modifier ? `-${opt_modifier}` : ""
              ].join("");
            };
            return fn;
          }
          function compose(h1, h2) {
            return (input) => h2(h1(input));
          }
          function extractValue(ev) {
            return ev.rawValue;
          }
          function bindValue(value, applyValue) {
            value.emitter.on("change", compose(extractValue, applyValue));
            applyValue(value.rawValue);
          }
          function bindValueMap(valueMap, key, applyValue) {
            bindValue(valueMap.value(key), applyValue);
          }
          function applyClass(elem, className2, active) {
            if (active) {
              elem.classList.add(className2);
            } else {
              elem.classList.remove(className2);
            }
          }
          function valueToClassName(elem, className2) {
            return (value) => {
              applyClass(elem, className2, value);
            };
          }
          function bindValueToTextContent(value, elem) {
            bindValue(value, (text2) => {
              elem.textContent = text2 !== null && text2 !== void 0 ? text2 : "";
            });
          }
          const className$q = ClassName("btn");
          class ButtonView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$q());
              config3.viewProps.bindClassModifiers(this.element);
              const buttonElem = doc.createElement("button");
              buttonElem.classList.add(className$q("b"));
              config3.viewProps.bindDisabled(buttonElem);
              this.element.appendChild(buttonElem);
              this.buttonElement = buttonElem;
              const titleElem = doc.createElement("div");
              titleElem.classList.add(className$q("t"));
              bindValueToTextContent(config3.props.value("title"), titleElem);
              this.buttonElement.appendChild(titleElem);
            }
          }
          class ButtonController {
            constructor(doc, config3) {
              this.emitter = new Emitter();
              this.onClick_ = this.onClick_.bind(this);
              this.props = config3.props;
              this.viewProps = config3.viewProps;
              this.view = new ButtonView(doc, {
                props: this.props,
                viewProps: this.viewProps
              });
              this.view.buttonElement.addEventListener("click", this.onClick_);
            }
            onClick_() {
              this.emitter.emit("click", {
                sender: this
              });
            }
          }
          class BoundValue {
            constructor(initialValue, config3) {
              var _a;
              this.constraint_ = config3 === null || config3 === void 0 ? void 0 : config3.constraint;
              this.equals_ = (_a = config3 === null || config3 === void 0 ? void 0 : config3.equals) !== null && _a !== void 0 ? _a : (v1, v2) => v1 === v2;
              this.emitter = new Emitter();
              this.rawValue_ = initialValue;
            }
            get constraint() {
              return this.constraint_;
            }
            get rawValue() {
              return this.rawValue_;
            }
            set rawValue(rawValue) {
              this.setRawValue(rawValue, {
                forceEmit: false,
                last: true
              });
            }
            setRawValue(rawValue, options) {
              const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true
              };
              const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
              const changed = !this.equals_(this.rawValue_, constrainedValue);
              if (!changed && !opts.forceEmit) {
                return;
              }
              this.emitter.emit("beforechange", {
                sender: this
              });
              this.rawValue_ = constrainedValue;
              this.emitter.emit("change", {
                options: opts,
                rawValue: constrainedValue,
                sender: this
              });
            }
          }
          class PrimitiveValue {
            constructor(initialValue) {
              this.emitter = new Emitter();
              this.value_ = initialValue;
            }
            get rawValue() {
              return this.value_;
            }
            set rawValue(value) {
              this.setRawValue(value, {
                forceEmit: false,
                last: true
              });
            }
            setRawValue(value, options) {
              const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true
              };
              if (this.value_ === value && !opts.forceEmit) {
                return;
              }
              this.emitter.emit("beforechange", {
                sender: this
              });
              this.value_ = value;
              this.emitter.emit("change", {
                options: opts,
                rawValue: this.value_,
                sender: this
              });
            }
          }
          function createValue(initialValue, config3) {
            const constraint = config3 === null || config3 === void 0 ? void 0 : config3.constraint;
            const equals2 = config3 === null || config3 === void 0 ? void 0 : config3.equals;
            if (!constraint && !equals2) {
              return new PrimitiveValue(initialValue);
            }
            return new BoundValue(initialValue, config3);
          }
          class ValueMap {
            constructor(valueMap) {
              this.emitter = new Emitter();
              this.valMap_ = valueMap;
              for (const key in this.valMap_) {
                const v = this.valMap_[key];
                v.emitter.on("change", () => {
                  this.emitter.emit("change", {
                    key,
                    sender: this
                  });
                });
              }
            }
            static createCore(initialValue) {
              const keys = Object.keys(initialValue);
              return keys.reduce((o, key) => {
                return Object.assign(o, {
                  [key]: createValue(initialValue[key])
                });
              }, {});
            }
            static fromObject(initialValue) {
              const core = this.createCore(initialValue);
              return new ValueMap(core);
            }
            get(key) {
              return this.valMap_[key].rawValue;
            }
            set(key, value) {
              this.valMap_[key].rawValue = value;
            }
            value(key) {
              return this.valMap_[key];
            }
          }
          function parseObject(value, keyToParserMap) {
            const keys = Object.keys(keyToParserMap);
            const result = keys.reduce((tmp2, key) => {
              if (tmp2 === void 0) {
                return void 0;
              }
              const parser = keyToParserMap[key];
              const result2 = parser(value[key]);
              return result2.succeeded ? Object.assign(Object.assign({}, tmp2), { [key]: result2.value }) : void 0;
            }, {});
            return forceCast(result);
          }
          function parseArray(value, parseItem) {
            return value.reduce((tmp2, item) => {
              if (tmp2 === void 0) {
                return void 0;
              }
              const result = parseItem(item);
              if (!result.succeeded || result.value === void 0) {
                return void 0;
              }
              return [...tmp2, result.value];
            }, []);
          }
          function isObject3(value) {
            if (value === null) {
              return false;
            }
            return typeof value === "object";
          }
          function createParamsParserBuilder(parse) {
            return (optional) => (v) => {
              if (!optional && v === void 0) {
                return {
                  succeeded: false,
                  value: void 0
                };
              }
              if (optional && v === void 0) {
                return {
                  succeeded: true,
                  value: void 0
                };
              }
              const result = parse(v);
              return result !== void 0 ? {
                succeeded: true,
                value: result
              } : {
                succeeded: false,
                value: void 0
              };
            };
          }
          function createParamsParserBuilders(optional) {
            return {
              custom: (parse) => createParamsParserBuilder(parse)(optional),
              boolean: createParamsParserBuilder((v) => typeof v === "boolean" ? v : void 0)(optional),
              number: createParamsParserBuilder((v) => typeof v === "number" ? v : void 0)(optional),
              string: createParamsParserBuilder((v) => typeof v === "string" ? v : void 0)(optional),
              function: createParamsParserBuilder((v) => typeof v === "function" ? v : void 0)(optional),
              constant: (value) => createParamsParserBuilder((v) => v === value ? value : void 0)(optional),
              raw: createParamsParserBuilder((v) => v)(optional),
              object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject3(v)) {
                  return void 0;
                }
                return parseObject(v, keyToParserMap);
              })(optional),
              array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                  return void 0;
                }
                return parseArray(v, itemParser);
              })(optional)
            };
          }
          const ParamsParsers = {
            optional: createParamsParserBuilders(true),
            required: createParamsParserBuilders(false)
          };
          function parseParams(value, keyToParserMap) {
            const result = ParamsParsers.required.object(keyToParserMap)(value);
            return result.succeeded ? result.value : void 0;
          }
          function disposeElement(elem) {
            if (elem && elem.parentElement) {
              elem.parentElement.removeChild(elem);
            }
            return null;
          }
          function getAllBladePositions() {
            return ["veryfirst", "first", "last", "verylast"];
          }
          const className$p = ClassName("");
          const POS_TO_CLASS_NAME_MAP = {
            veryfirst: "vfst",
            first: "fst",
            last: "lst",
            verylast: "vlst"
          };
          class BladeController {
            constructor(config3) {
              this.parent_ = null;
              this.blade = config3.blade;
              this.view = config3.view;
              this.viewProps = config3.viewProps;
              const elem = this.view.element;
              this.blade.value("positions").emitter.on("change", () => {
                getAllBladePositions().forEach((pos) => {
                  elem.classList.remove(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
                });
                this.blade.get("positions").forEach((pos) => {
                  elem.classList.add(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
                });
              });
              this.viewProps.handleDispose(() => {
                disposeElement(elem);
              });
            }
            get parent() {
              return this.parent_;
            }
          }
          const SVG_NS = "http://www.w3.org/2000/svg";
          function forceReflow(element) {
            element.offsetHeight;
          }
          function disableTransitionTemporarily(element, callback) {
            const t = element.style.transition;
            element.style.transition = "none";
            callback();
            element.style.transition = t;
          }
          function supportsTouch(doc) {
            return doc.ontouchstart !== void 0;
          }
          function getGlobalObject() {
            return new Function("return this")();
          }
          function getWindowDocument() {
            const globalObj = forceCast(getGlobalObject());
            return globalObj.document;
          }
          function isBrowser() {
            return "document" in getGlobalObject();
          }
          function getCanvasContext(canvasElement) {
            return isBrowser() ? canvasElement.getContext("2d") : null;
          }
          const ICON_ID_TO_INNER_HTML_MAP = {
            check: '<path d="M2 8l4 4l8 -8"/>',
            dropdown: '<path d="M5 7h6l-3 3 z"/>',
            p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
          };
          function createSvgIconElement(document2, iconId) {
            const elem = document2.createElementNS(SVG_NS, "svg");
            elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
            return elem;
          }
          function insertElementAt(parentElement, element, index2) {
            parentElement.insertBefore(element, parentElement.children[index2]);
          }
          function removeElement(element) {
            if (element.parentElement) {
              element.parentElement.removeChild(element);
            }
          }
          function removeChildElements(element) {
            while (element.children.length > 0) {
              element.removeChild(element.children[0]);
            }
          }
          function removeChildNodes(element) {
            while (element.childNodes.length > 0) {
              element.removeChild(element.childNodes[0]);
            }
          }
          function findNextTarget(ev) {
            if (ev.relatedTarget) {
              return forceCast(ev.relatedTarget);
            }
            if ("explicitOriginalTarget" in ev) {
              return ev.explicitOriginalTarget;
            }
            return null;
          }
          const className$o = ClassName("lbl");
          function createLabelNode(doc, label) {
            const frag = doc.createDocumentFragment();
            const lineNodes = label.split("\n").map((line) => {
              return doc.createTextNode(line);
            });
            lineNodes.forEach((lineNode, index2) => {
              if (index2 > 0) {
                frag.appendChild(doc.createElement("br"));
              }
              frag.appendChild(lineNode);
            });
            return frag;
          }
          class LabelView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$o());
              config3.viewProps.bindClassModifiers(this.element);
              const labelElem = doc.createElement("div");
              labelElem.classList.add(className$o("l"));
              bindValueMap(config3.props, "label", (value) => {
                if (isEmpty(value)) {
                  this.element.classList.add(className$o(void 0, "nol"));
                } else {
                  this.element.classList.remove(className$o(void 0, "nol"));
                  removeChildNodes(labelElem);
                  labelElem.appendChild(createLabelNode(doc, value));
                }
              });
              this.element.appendChild(labelElem);
              this.labelElement = labelElem;
              const valueElem = doc.createElement("div");
              valueElem.classList.add(className$o("v"));
              this.element.appendChild(valueElem);
              this.valueElement = valueElem;
            }
          }
          class LabelController extends BladeController {
            constructor(doc, config3) {
              const viewProps = config3.valueController.viewProps;
              super(Object.assign(Object.assign({}, config3), { view: new LabelView(doc, {
                props: config3.props,
                viewProps
              }), viewProps }));
              this.props = config3.props;
              this.valueController = config3.valueController;
              this.view.valueElement.appendChild(this.valueController.view.element);
            }
          }
          const ButtonBladePlugin = {
            id: "button",
            type: "blade",
            accept(params) {
              const p = ParamsParsers;
              const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant("button"),
                label: p.optional.string
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              return new LabelController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                  label: args.params.label
                }),
                valueController: new ButtonController(args.document, {
                  props: ValueMap.fromObject({
                    title: args.params.title
                  }),
                  viewProps: args.viewProps
                })
              });
            },
            api(args) {
              if (!(args.controller instanceof LabelController)) {
                return null;
              }
              if (!(args.controller.valueController instanceof ButtonController)) {
                return null;
              }
              return new ButtonApi(args.controller);
            }
          };
          class ValueBladeController extends BladeController {
            constructor(config3) {
              super(config3);
              this.value = config3.value;
            }
          }
          function createBlade() {
            return new ValueMap({
              positions: createValue([], {
                equals: deepEqualsArray
              })
            });
          }
          class Foldable extends ValueMap {
            constructor(valueMap) {
              super(valueMap);
            }
            static create(expanded) {
              const coreObj = {
                completed: true,
                expanded,
                expandedHeight: null,
                shouldFixHeight: false,
                temporaryExpanded: null
              };
              const core = ValueMap.createCore(coreObj);
              return new Foldable(core);
            }
            get styleExpanded() {
              var _a;
              return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0 ? _a : this.get("expanded");
            }
            get styleHeight() {
              if (!this.styleExpanded) {
                return "0";
              }
              const exHeight = this.get("expandedHeight");
              if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
                return `${exHeight}px`;
              }
              return "auto";
            }
            bindExpandedClass(elem, expandedClassName) {
              bindValueMap(this, "expanded", () => {
                const expanded = this.styleExpanded;
                if (expanded) {
                  elem.classList.add(expandedClassName);
                } else {
                  elem.classList.remove(expandedClassName);
                }
              });
            }
          }
          function computeExpandedFolderHeight(folder, containerElement) {
            let height = 0;
            disableTransitionTemporarily(containerElement, () => {
              folder.set("expandedHeight", null);
              folder.set("temporaryExpanded", true);
              forceReflow(containerElement);
              height = containerElement.clientHeight;
              folder.set("temporaryExpanded", null);
              forceReflow(containerElement);
            });
            return height;
          }
          function applyHeight(foldable, elem) {
            elem.style.height = foldable.styleHeight;
          }
          function bindFoldable(foldable, elem) {
            foldable.value("expanded").emitter.on("beforechange", () => {
              foldable.set("completed", false);
              if (isEmpty(foldable.get("expandedHeight"))) {
                foldable.set("expandedHeight", computeExpandedFolderHeight(foldable, elem));
              }
              foldable.set("shouldFixHeight", true);
              forceReflow(elem);
            });
            foldable.emitter.on("change", () => {
              applyHeight(foldable, elem);
            });
            applyHeight(foldable, elem);
            elem.addEventListener("transitionend", (ev) => {
              if (ev.propertyName !== "height") {
                return;
              }
              foldable.set("shouldFixHeight", false);
              foldable.set("expandedHeight", null);
              foldable.set("completed", true);
            });
          }
          class RackLikeApi extends BladeApi {
            constructor(controller, rackApi) {
              super(controller);
              this.rackApi_ = rackApi;
            }
          }
          function addButtonAsBlade(api, params) {
            return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
          }
          function addFolderAsBlade(api, params) {
            return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
          }
          function addSeparatorAsBlade(api, opt_params) {
            const params = opt_params || {};
            return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
          }
          function addTabAsBlade(api, params) {
            return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
          }
          class NestedOrderedSet {
            constructor(extract) {
              this.emitter = new Emitter();
              this.items_ = [];
              this.cache_ = new Set();
              this.onSubListAdd_ = this.onSubListAdd_.bind(this);
              this.onSubListRemove_ = this.onSubListRemove_.bind(this);
              this.extract_ = extract;
            }
            get items() {
              return this.items_;
            }
            allItems() {
              return Array.from(this.cache_);
            }
            find(callback) {
              for (const item of this.allItems()) {
                if (callback(item)) {
                  return item;
                }
              }
              return null;
            }
            includes(item) {
              return this.cache_.has(item);
            }
            add(item, opt_index) {
              if (this.includes(item)) {
                throw TpError.shouldNeverHappen();
              }
              const index2 = opt_index !== void 0 ? opt_index : this.items_.length;
              this.items_.splice(index2, 0, item);
              this.cache_.add(item);
              const subList = this.extract_(item);
              if (subList) {
                subList.emitter.on("add", this.onSubListAdd_);
                subList.emitter.on("remove", this.onSubListRemove_);
                subList.allItems().forEach((item2) => {
                  this.cache_.add(item2);
                });
              }
              this.emitter.emit("add", {
                index: index2,
                item,
                root: this,
                target: this
              });
            }
            remove(item) {
              const index2 = this.items_.indexOf(item);
              if (index2 < 0) {
                return;
              }
              this.items_.splice(index2, 1);
              this.cache_.delete(item);
              const subList = this.extract_(item);
              if (subList) {
                subList.emitter.off("add", this.onSubListAdd_);
                subList.emitter.off("remove", this.onSubListRemove_);
              }
              this.emitter.emit("remove", {
                index: index2,
                item,
                root: this,
                target: this
              });
            }
            onSubListAdd_(ev) {
              this.cache_.add(ev.item);
              this.emitter.emit("add", {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target
              });
            }
            onSubListRemove_(ev) {
              this.cache_.delete(ev.item);
              this.emitter.emit("remove", {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target
              });
            }
          }
          class InputBindingApi extends BladeApi {
            constructor(controller) {
              super(controller);
              this.onBindingChange_ = this.onBindingChange_.bind(this);
              this.emitter_ = new Emitter();
              this.controller_.binding.emitter.on("change", this.onBindingChange_);
            }
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
            refresh() {
              this.controller_.binding.read();
            }
            onBindingChange_(ev) {
              const value = ev.sender.target.read();
              this.emitter_.emit("change", {
                event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
              });
            }
          }
          class InputBindingController extends LabelController {
            constructor(doc, config3) {
              super(doc, config3);
              this.binding = config3.binding;
            }
          }
          class MonitorBindingApi extends BladeApi {
            constructor(controller) {
              super(controller);
              this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
              this.emitter_ = new Emitter();
              this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
            }
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
            refresh() {
              this.controller_.binding.read();
            }
            onBindingUpdate_(ev) {
              const value = ev.sender.target.read();
              this.emitter_.emit("update", {
                event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
              });
            }
          }
          class MonitorBindingController extends LabelController {
            constructor(doc, config3) {
              super(doc, config3);
              this.binding = config3.binding;
              this.viewProps.bindDisabled(this.binding.ticker);
              this.viewProps.handleDispose(() => {
                this.binding.dispose();
              });
            }
          }
          function findSubBladeApiSet(api) {
            if (api instanceof RackApi) {
              return api["apiSet_"];
            }
            if (api instanceof RackLikeApi) {
              return api["rackApi_"]["apiSet_"];
            }
            return null;
          }
          function getApiByController(apiSet, controller) {
            const api = apiSet.find((api2) => api2.controller_ === controller);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          }
          function createBindingTarget(obj, key, opt_id) {
            if (!BindingTarget.isBindable(obj)) {
              throw TpError.notBindable();
            }
            return new BindingTarget(obj, key, opt_id);
          }
          class RackApi extends BladeApi {
            constructor(controller, pool) {
              super(controller);
              this.onRackAdd_ = this.onRackAdd_.bind(this);
              this.onRackRemove_ = this.onRackRemove_.bind(this);
              this.onRackInputChange_ = this.onRackInputChange_.bind(this);
              this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
              this.emitter_ = new Emitter();
              this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
              this.pool_ = pool;
              const rack = this.controller_.rack;
              rack.emitter.on("add", this.onRackAdd_);
              rack.emitter.on("remove", this.onRackRemove_);
              rack.emitter.on("inputchange", this.onRackInputChange_);
              rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
              rack.children.forEach((bc) => {
                this.setUpApi_(bc);
              });
            }
            get children() {
              return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
            }
            addInput(object, key, opt_params) {
              const params = opt_params || {};
              const doc = this.controller_.view.element.ownerDocument;
              const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
              const api = new InputBindingApi(bc);
              return this.add(api, params.index);
            }
            addMonitor(object, key, opt_params) {
              const params = opt_params || {};
              const doc = this.controller_.view.element.ownerDocument;
              const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
              const api = new MonitorBindingApi(bc);
              return forceCast(this.add(api, params.index));
            }
            addFolder(params) {
              return addFolderAsBlade(this, params);
            }
            addButton(params) {
              return addButtonAsBlade(this, params);
            }
            addSeparator(opt_params) {
              return addSeparatorAsBlade(this, opt_params);
            }
            addTab(params) {
              return addTabAsBlade(this, params);
            }
            add(api, opt_index) {
              this.controller_.rack.add(api.controller_, opt_index);
              const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
              if (gapi) {
                this.apiSet_.remove(gapi);
              }
              this.apiSet_.add(api);
              return api;
            }
            remove(api) {
              this.controller_.rack.remove(api.controller_);
            }
            addBlade(params) {
              const doc = this.controller_.view.element.ownerDocument;
              const bc = this.pool_.createBlade(doc, params);
              const api = this.pool_.createBladeApi(bc);
              return this.add(api, params.index);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
            setUpApi_(bc) {
              const api = this.apiSet_.find((api2) => api2.controller_ === bc);
              if (!api) {
                this.apiSet_.add(this.pool_.createBladeApi(bc));
              }
            }
            onRackAdd_(ev) {
              this.setUpApi_(ev.bladeController);
            }
            onRackRemove_(ev) {
              if (ev.isRoot) {
                const api = getApiByController(this.apiSet_, ev.bladeController);
                this.apiSet_.remove(api);
              }
            }
            onRackInputChange_(ev) {
              const bc = ev.bladeController;
              if (bc instanceof InputBindingController) {
                const api = getApiByController(this.apiSet_, bc);
                const binding = bc.binding;
                this.emitter_.emit("change", {
                  event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
                });
              } else if (bc instanceof ValueBladeController) {
                const api = getApiByController(this.apiSet_, bc);
                this.emitter_.emit("change", {
                  event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
                });
              }
            }
            onRackMonitorUpdate_(ev) {
              if (!(ev.bladeController instanceof MonitorBindingController)) {
                throw TpError.shouldNeverHappen();
              }
              const api = getApiByController(this.apiSet_, ev.bladeController);
              const binding = ev.bladeController.binding;
              this.emitter_.emit("update", {
                event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
              });
            }
          }
          class FolderApi extends RackLikeApi {
            constructor(controller, pool) {
              super(controller, new RackApi(controller.rackController, pool));
              this.emitter_ = new Emitter();
              this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
                this.emitter_.emit("fold", {
                  event: new TpFoldEvent(this, ev.sender.rawValue)
                });
              });
              this.rackApi_.on("change", (ev) => {
                this.emitter_.emit("change", {
                  event: ev
                });
              });
              this.rackApi_.on("update", (ev) => {
                this.emitter_.emit("update", {
                  event: ev
                });
              });
            }
            get expanded() {
              return this.controller_.foldable.get("expanded");
            }
            set expanded(expanded) {
              this.controller_.foldable.set("expanded", expanded);
            }
            get title() {
              return this.controller_.props.get("title");
            }
            set title(title) {
              this.controller_.props.set("title", title);
            }
            get children() {
              return this.rackApi_.children;
            }
            addInput(object, key, opt_params) {
              return this.rackApi_.addInput(object, key, opt_params);
            }
            addMonitor(object, key, opt_params) {
              return this.rackApi_.addMonitor(object, key, opt_params);
            }
            addFolder(params) {
              return this.rackApi_.addFolder(params);
            }
            addButton(params) {
              return this.rackApi_.addButton(params);
            }
            addSeparator(opt_params) {
              return this.rackApi_.addSeparator(opt_params);
            }
            addTab(params) {
              return this.rackApi_.addTab(params);
            }
            add(api, opt_index) {
              return this.rackApi_.add(api, opt_index);
            }
            remove(api) {
              this.rackApi_.remove(api);
            }
            addBlade(params) {
              return this.rackApi_.addBlade(params);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
          }
          class RackLikeController extends BladeController {
            constructor(config3) {
              super({
                blade: config3.blade,
                view: config3.view,
                viewProps: config3.rackController.viewProps
              });
              this.rackController = config3.rackController;
            }
          }
          class PlainView {
            constructor(doc, config3) {
              const className2 = ClassName(config3.viewName);
              this.element = doc.createElement("div");
              this.element.classList.add(className2());
              config3.viewProps.bindClassModifiers(this.element);
            }
          }
          function findInputBindingController(bcs, b) {
            for (let i2 = 0; i2 < bcs.length; i2++) {
              const bc = bcs[i2];
              if (bc instanceof InputBindingController && bc.binding === b) {
                return bc;
              }
            }
            return null;
          }
          function findMonitorBindingController(bcs, b) {
            for (let i2 = 0; i2 < bcs.length; i2++) {
              const bc = bcs[i2];
              if (bc instanceof MonitorBindingController && bc.binding === b) {
                return bc;
              }
            }
            return null;
          }
          function findValueBladeController(bcs, v) {
            for (let i2 = 0; i2 < bcs.length; i2++) {
              const bc = bcs[i2];
              if (bc instanceof ValueBladeController && bc.value === v) {
                return bc;
              }
            }
            return null;
          }
          function findSubRack(bc) {
            if (bc instanceof RackController) {
              return bc.rack;
            }
            if (bc instanceof RackLikeController) {
              return bc.rackController.rack;
            }
            return null;
          }
          function findSubBladeControllerSet(bc) {
            const rack = findSubRack(bc);
            return rack ? rack["bcSet_"] : null;
          }
          class BladeRack {
            constructor(blade) {
              var _a;
              this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
              this.onSetAdd_ = this.onSetAdd_.bind(this);
              this.onSetRemove_ = this.onSetRemove_.bind(this);
              this.onChildDispose_ = this.onChildDispose_.bind(this);
              this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
              this.onChildInputChange_ = this.onChildInputChange_.bind(this);
              this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
              this.onChildValueChange_ = this.onChildValueChange_.bind(this);
              this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
              this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
              this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
              this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
              this.emitter = new Emitter();
              this.blade_ = blade !== null && blade !== void 0 ? blade : null;
              (_a = this.blade_) === null || _a === void 0 ? void 0 : _a.value("positions").emitter.on("change", this.onBladePositionsChange_);
              this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
              this.bcSet_.emitter.on("add", this.onSetAdd_);
              this.bcSet_.emitter.on("remove", this.onSetRemove_);
            }
            get children() {
              return this.bcSet_.items;
            }
            add(bc, opt_index) {
              if (bc.parent) {
                bc.parent.remove(bc);
              }
              bc["parent_"] = this;
              this.bcSet_.add(bc, opt_index);
            }
            remove(bc) {
              bc["parent_"] = null;
              this.bcSet_.remove(bc);
            }
            find(controllerClass) {
              return forceCast(this.bcSet_.allItems().filter((bc) => {
                return bc instanceof controllerClass;
              }));
            }
            onSetAdd_(ev) {
              this.updatePositions_();
              const isRoot = ev.target === ev.root;
              this.emitter.emit("add", {
                bladeController: ev.item,
                index: ev.index,
                isRoot,
                sender: this
              });
              if (!isRoot) {
                return;
              }
              const bc = ev.item;
              bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
              bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
              bc.viewProps.handleDispose(this.onChildDispose_);
              if (bc instanceof InputBindingController) {
                bc.binding.emitter.on("change", this.onChildInputChange_);
              } else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
              } else if (bc instanceof ValueBladeController) {
                bc.value.emitter.on("change", this.onChildValueChange_);
              } else {
                const rack = findSubRack(bc);
                if (rack) {
                  const emitter = rack.emitter;
                  emitter.on("layout", this.onDescendantLayout_);
                  emitter.on("inputchange", this.onDescendantInputChange_);
                  emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
                }
              }
            }
            onSetRemove_(ev) {
              this.updatePositions_();
              const isRoot = ev.target === ev.root;
              this.emitter.emit("remove", {
                bladeController: ev.item,
                isRoot,
                sender: this
              });
              if (!isRoot) {
                return;
              }
              const bc = ev.item;
              if (bc instanceof InputBindingController) {
                bc.binding.emitter.off("change", this.onChildInputChange_);
              } else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
              } else if (bc instanceof ValueBladeController) {
                bc.value.emitter.off("change", this.onChildValueChange_);
              } else {
                const rack = findSubRack(bc);
                if (rack) {
                  const emitter = rack.emitter;
                  emitter.off("layout", this.onDescendantLayout_);
                  emitter.off("inputchange", this.onDescendantInputChange_);
                  emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
                }
              }
            }
            updatePositions_() {
              const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
              const firstVisibleItem = visibleItems[0];
              const lastVisibleItem = visibleItems[visibleItems.length - 1];
              this.bcSet_.items.forEach((bc) => {
                const ps = [];
                if (bc === firstVisibleItem) {
                  ps.push("first");
                  if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
                    ps.push("veryfirst");
                  }
                }
                if (bc === lastVisibleItem) {
                  ps.push("last");
                  if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
                    ps.push("verylast");
                  }
                }
                bc.blade.set("positions", ps);
              });
            }
            onChildPositionsChange_() {
              this.updatePositions_();
              this.emitter.emit("layout", {
                sender: this
              });
            }
            onChildViewPropsChange_(_ev) {
              this.updatePositions_();
              this.emitter.emit("layout", {
                sender: this
              });
            }
            onChildDispose_() {
              const disposedUcs = this.bcSet_.items.filter((bc) => {
                return bc.viewProps.get("disposed");
              });
              disposedUcs.forEach((bc) => {
                this.bcSet_.remove(bc);
              });
            }
            onChildInputChange_(ev) {
              const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
              if (!bc) {
                throw TpError.shouldNeverHappen();
              }
              this.emitter.emit("inputchange", {
                bladeController: bc,
                options: ev.options,
                sender: this
              });
            }
            onChildMonitorUpdate_(ev) {
              const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
              if (!bc) {
                throw TpError.shouldNeverHappen();
              }
              this.emitter.emit("monitorupdate", {
                bladeController: bc,
                sender: this
              });
            }
            onChildValueChange_(ev) {
              const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
              if (!bc) {
                throw TpError.shouldNeverHappen();
              }
              this.emitter.emit("inputchange", {
                bladeController: bc,
                options: ev.options,
                sender: this
              });
            }
            onDescendantLayout_(_) {
              this.updatePositions_();
              this.emitter.emit("layout", {
                sender: this
              });
            }
            onDescendantInputChange_(ev) {
              this.emitter.emit("inputchange", {
                bladeController: ev.bladeController,
                options: ev.options,
                sender: this
              });
            }
            onDescendantMonitorUpdate_(ev) {
              this.emitter.emit("monitorupdate", {
                bladeController: ev.bladeController,
                sender: this
              });
            }
            onBladePositionsChange_() {
              this.updatePositions_();
            }
          }
          class RackController extends BladeController {
            constructor(doc, config3) {
              super(Object.assign(Object.assign({}, config3), { view: new PlainView(doc, {
                viewName: "brk",
                viewProps: config3.viewProps
              }) }));
              this.onRackAdd_ = this.onRackAdd_.bind(this);
              this.onRackRemove_ = this.onRackRemove_.bind(this);
              const rack = new BladeRack(config3.root ? void 0 : config3.blade);
              rack.emitter.on("add", this.onRackAdd_);
              rack.emitter.on("remove", this.onRackRemove_);
              this.rack = rack;
              this.viewProps.handleDispose(() => {
                for (let i2 = this.rack.children.length - 1; i2 >= 0; i2--) {
                  const bc = this.rack.children[i2];
                  bc.viewProps.set("disposed", true);
                }
              });
            }
            onRackAdd_(ev) {
              if (!ev.isRoot) {
                return;
              }
              insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
            }
            onRackRemove_(ev) {
              if (!ev.isRoot) {
                return;
              }
              removeElement(ev.bladeController.view.element);
            }
          }
          const bladeContainerClassName = ClassName("cnt");
          class FolderView {
            constructor(doc, config3) {
              this.className_ = ClassName(config3.viewName || "fld");
              this.element = doc.createElement("div");
              this.element.classList.add(this.className_(), bladeContainerClassName());
              config3.viewProps.bindClassModifiers(this.element);
              this.foldable_ = config3.foldable;
              this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
              bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
              const buttonElem = doc.createElement("button");
              buttonElem.classList.add(this.className_("b"));
              bindValueMap(config3.props, "title", (title) => {
                if (isEmpty(title)) {
                  this.element.classList.add(this.className_(void 0, "not"));
                } else {
                  this.element.classList.remove(this.className_(void 0, "not"));
                }
              });
              config3.viewProps.bindDisabled(buttonElem);
              this.element.appendChild(buttonElem);
              this.buttonElement = buttonElem;
              const titleElem = doc.createElement("div");
              titleElem.classList.add(this.className_("t"));
              bindValueToTextContent(config3.props.value("title"), titleElem);
              this.buttonElement.appendChild(titleElem);
              this.titleElement = titleElem;
              const markElem = doc.createElement("div");
              markElem.classList.add(this.className_("m"));
              this.buttonElement.appendChild(markElem);
              const containerElem = config3.containerElement;
              containerElem.classList.add(this.className_("c"));
              this.element.appendChild(containerElem);
              this.containerElement = containerElem;
            }
          }
          class FolderController extends RackLikeController {
            constructor(doc, config3) {
              var _a;
              const foldable = Foldable.create((_a = config3.expanded) !== null && _a !== void 0 ? _a : true);
              const rc = new RackController(doc, {
                blade: config3.blade,
                root: config3.root,
                viewProps: config3.viewProps
              });
              super(Object.assign(Object.assign({}, config3), { rackController: rc, view: new FolderView(doc, {
                containerElement: rc.view.element,
                foldable,
                props: config3.props,
                viewName: config3.root ? "rot" : void 0,
                viewProps: config3.viewProps
              }) }));
              this.onTitleClick_ = this.onTitleClick_.bind(this);
              this.props = config3.props;
              this.foldable = foldable;
              bindFoldable(this.foldable, this.view.containerElement);
              this.view.buttonElement.addEventListener("click", this.onTitleClick_);
            }
            get document() {
              return this.view.element.ownerDocument;
            }
            onTitleClick_() {
              this.foldable.set("expanded", !this.foldable.get("expanded"));
            }
          }
          const FolderBladePlugin = {
            id: "folder",
            type: "blade",
            accept(params) {
              const p = ParamsParsers;
              const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant("folder"),
                expanded: p.optional.boolean
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              return new FolderController(args.document, {
                blade: args.blade,
                expanded: args.params.expanded,
                props: ValueMap.fromObject({
                  title: args.params.title
                }),
                viewProps: args.viewProps
              });
            },
            api(args) {
              if (!(args.controller instanceof FolderController)) {
                return null;
              }
              return new FolderApi(args.controller, args.pool);
            }
          };
          class LabeledValueController extends ValueBladeController {
            constructor(doc, config3) {
              const viewProps = config3.valueController.viewProps;
              super(Object.assign(Object.assign({}, config3), { value: config3.valueController.value, view: new LabelView(doc, {
                props: config3.props,
                viewProps
              }), viewProps }));
              this.props = config3.props;
              this.valueController = config3.valueController;
              this.view.valueElement.appendChild(this.valueController.view.element);
            }
          }
          class SeparatorApi extends BladeApi {
          }
          const className$n = ClassName("spr");
          class SeparatorView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$n());
              config3.viewProps.bindClassModifiers(this.element);
              const hrElem = doc.createElement("hr");
              hrElem.classList.add(className$n("r"));
              this.element.appendChild(hrElem);
            }
          }
          class SeparatorController extends BladeController {
            constructor(doc, config3) {
              super(Object.assign(Object.assign({}, config3), { view: new SeparatorView(doc, {
                viewProps: config3.viewProps
              }) }));
            }
          }
          const SeparatorBladePlugin = {
            id: "separator",
            type: "blade",
            accept(params) {
              const p = ParamsParsers;
              const result = parseParams(params, {
                view: p.required.constant("separator")
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              return new SeparatorController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps
              });
            },
            api(args) {
              if (!(args.controller instanceof SeparatorController)) {
                return null;
              }
              return new SeparatorApi(args.controller);
            }
          };
          const className$m = ClassName("");
          function valueToModifier(elem, modifier2) {
            return valueToClassName(elem, className$m(void 0, modifier2));
          }
          class ViewProps extends ValueMap {
            constructor(valueMap) {
              super(valueMap);
            }
            static create(opt_initialValue) {
              var _a, _b;
              const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
              const coreObj = {
                disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
                disposed: false,
                hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false
              };
              const core = ValueMap.createCore(coreObj);
              return new ViewProps(core);
            }
            bindClassModifiers(elem) {
              bindValueMap(this, "disabled", valueToModifier(elem, "disabled"));
              bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
            }
            bindDisabled(target) {
              bindValueMap(this, "disabled", (disabled) => {
                target.disabled = disabled;
              });
            }
            bindTabIndex(elem) {
              bindValueMap(this, "disabled", (disabled) => {
                elem.tabIndex = disabled ? -1 : 0;
              });
            }
            handleDispose(callback) {
              this.value("disposed").emitter.on("change", (disposed) => {
                if (disposed) {
                  callback();
                }
              });
            }
          }
          const className$l = ClassName("tbi");
          class TabItemView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$l());
              config3.viewProps.bindClassModifiers(this.element);
              bindValueMap(config3.props, "selected", (selected) => {
                if (selected) {
                  this.element.classList.add(className$l(void 0, "sel"));
                } else {
                  this.element.classList.remove(className$l(void 0, "sel"));
                }
              });
              const buttonElem = doc.createElement("button");
              buttonElem.classList.add(className$l("b"));
              config3.viewProps.bindDisabled(buttonElem);
              this.element.appendChild(buttonElem);
              this.buttonElement = buttonElem;
              const titleElem = doc.createElement("div");
              titleElem.classList.add(className$l("t"));
              bindValueToTextContent(config3.props.value("title"), titleElem);
              this.buttonElement.appendChild(titleElem);
              this.titleElement = titleElem;
            }
          }
          class TabItemController {
            constructor(doc, config3) {
              this.emitter = new Emitter();
              this.onClick_ = this.onClick_.bind(this);
              this.props = config3.props;
              this.viewProps = config3.viewProps;
              this.view = new TabItemView(doc, {
                props: config3.props,
                viewProps: config3.viewProps
              });
              this.view.buttonElement.addEventListener("click", this.onClick_);
            }
            onClick_() {
              this.emitter.emit("click", {
                sender: this
              });
            }
          }
          class TabPageController {
            constructor(doc, config3) {
              this.onItemClick_ = this.onItemClick_.bind(this);
              this.ic_ = new TabItemController(doc, {
                props: config3.itemProps,
                viewProps: ViewProps.create()
              });
              this.ic_.emitter.on("click", this.onItemClick_);
              this.cc_ = new RackController(doc, {
                blade: createBlade(),
                viewProps: ViewProps.create()
              });
              this.props = config3.props;
              bindValueMap(this.props, "selected", (selected) => {
                this.itemController.props.set("selected", selected);
                this.contentController.viewProps.set("hidden", !selected);
              });
            }
            get itemController() {
              return this.ic_;
            }
            get contentController() {
              return this.cc_;
            }
            onItemClick_() {
              this.props.set("selected", true);
            }
          }
          class TabPageApi {
            constructor(controller, contentRackApi) {
              this.controller_ = controller;
              this.rackApi_ = contentRackApi;
            }
            get title() {
              var _a;
              return (_a = this.controller_.itemController.props.get("title")) !== null && _a !== void 0 ? _a : "";
            }
            set title(title) {
              this.controller_.itemController.props.set("title", title);
            }
            get selected() {
              return this.controller_.props.get("selected");
            }
            set selected(selected) {
              this.controller_.props.set("selected", selected);
            }
            get children() {
              return this.rackApi_.children;
            }
            addButton(params) {
              return this.rackApi_.addButton(params);
            }
            addFolder(params) {
              return this.rackApi_.addFolder(params);
            }
            addSeparator(opt_params) {
              return this.rackApi_.addSeparator(opt_params);
            }
            addTab(params) {
              return this.rackApi_.addTab(params);
            }
            add(api, opt_index) {
              this.rackApi_.add(api, opt_index);
            }
            remove(api) {
              this.rackApi_.remove(api);
            }
            addInput(object, key, opt_params) {
              return this.rackApi_.addInput(object, key, opt_params);
            }
            addMonitor(object, key, opt_params) {
              return this.rackApi_.addMonitor(object, key, opt_params);
            }
            addBlade(params) {
              return this.rackApi_.addBlade(params);
            }
          }
          class TabApi extends RackLikeApi {
            constructor(controller, pool) {
              super(controller, new RackApi(controller.rackController, pool));
              this.onPageAdd_ = this.onPageAdd_.bind(this);
              this.onPageRemove_ = this.onPageRemove_.bind(this);
              this.emitter_ = new Emitter();
              this.pageApiMap_ = new Map();
              this.rackApi_.on("change", (ev) => {
                this.emitter_.emit("change", {
                  event: ev
                });
              });
              this.rackApi_.on("update", (ev) => {
                this.emitter_.emit("update", {
                  event: ev
                });
              });
              this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
              this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
              this.controller_.pageSet.items.forEach((pc) => {
                this.setUpPageApi_(pc);
              });
            }
            get pages() {
              return this.controller_.pageSet.items.map((pc) => {
                const api = this.pageApiMap_.get(pc);
                if (!api) {
                  throw TpError.shouldNeverHappen();
                }
                return api;
              });
            }
            addPage(params) {
              const doc = this.controller_.view.element.ownerDocument;
              const pc = new TabPageController(doc, {
                itemProps: ValueMap.fromObject({
                  selected: false,
                  title: params.title
                }),
                props: ValueMap.fromObject({
                  selected: false
                })
              });
              this.controller_.add(pc, params.index);
              const api = this.pageApiMap_.get(pc);
              if (!api) {
                throw TpError.shouldNeverHappen();
              }
              return api;
            }
            removePage(index2) {
              this.controller_.remove(index2);
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
            setUpPageApi_(pc) {
              const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
              if (!rackApi) {
                throw TpError.shouldNeverHappen();
              }
              const api = new TabPageApi(pc, rackApi);
              this.pageApiMap_.set(pc, api);
            }
            onPageAdd_(ev) {
              this.setUpPageApi_(ev.item);
            }
            onPageRemove_(ev) {
              const api = this.pageApiMap_.get(ev.item);
              if (!api) {
                throw TpError.shouldNeverHappen();
              }
              this.pageApiMap_.delete(ev.item);
            }
          }
          const className$k = ClassName("tab");
          class TabView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$k(), bladeContainerClassName());
              config3.viewProps.bindClassModifiers(this.element);
              bindValue(config3.empty, valueToClassName(this.element, className$k(void 0, "nop")));
              const itemsElem = doc.createElement("div");
              itemsElem.classList.add(className$k("i"));
              this.element.appendChild(itemsElem);
              this.itemsElement = itemsElem;
              const contentsElem = config3.contentsElement;
              contentsElem.classList.add(className$k("c"));
              this.element.appendChild(contentsElem);
              this.contentsElement = contentsElem;
            }
          }
          class TabController extends RackLikeController {
            constructor(doc, config3) {
              const cr = new RackController(doc, {
                blade: config3.blade,
                viewProps: config3.viewProps
              });
              const empty = createValue(true);
              super({
                blade: config3.blade,
                rackController: cr,
                view: new TabView(doc, {
                  contentsElement: cr.view.element,
                  empty,
                  viewProps: config3.viewProps
                })
              });
              this.onPageAdd_ = this.onPageAdd_.bind(this);
              this.onPageRemove_ = this.onPageRemove_.bind(this);
              this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this);
              this.pageSet_ = new NestedOrderedSet(() => null);
              this.pageSet_.emitter.on("add", this.onPageAdd_);
              this.pageSet_.emitter.on("remove", this.onPageRemove_);
              this.empty_ = empty;
              this.applyPages_();
            }
            get pageSet() {
              return this.pageSet_;
            }
            add(pc, opt_index) {
              this.pageSet_.add(pc, opt_index !== null && opt_index !== void 0 ? opt_index : this.pageSet_.items.length);
            }
            remove(index2) {
              this.pageSet_.remove(this.pageSet_.items[index2]);
            }
            applyPages_() {
              this.keepSelection_();
              this.empty_.rawValue = this.pageSet_.items.length === 0;
            }
            onPageAdd_(ev) {
              const pc = ev.item;
              insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
              this.rackController.rack.add(pc.contentController, ev.index);
              pc.props.value("selected").emitter.on("change", this.onPageSelectedChange_);
              this.applyPages_();
            }
            onPageRemove_(ev) {
              const pc = ev.item;
              removeElement(pc.itemController.view.element);
              this.rackController.rack.remove(pc.contentController);
              pc.props.value("selected").emitter.off("change", this.onPageSelectedChange_);
              this.applyPages_();
            }
            keepSelection_() {
              if (this.pageSet_.items.length === 0) {
                return;
              }
              const firstSelIndex = this.pageSet_.items.findIndex((pc) => pc.props.get("selected"));
              if (firstSelIndex < 0) {
                this.pageSet_.items.forEach((pc, i2) => {
                  pc.props.set("selected", i2 === 0);
                });
              } else {
                this.pageSet_.items.forEach((pc, i2) => {
                  pc.props.set("selected", i2 === firstSelIndex);
                });
              }
            }
            onPageSelectedChange_(ev) {
              if (ev.rawValue) {
                const index2 = this.pageSet_.items.findIndex((pc) => pc.props.value("selected") === ev.sender);
                this.pageSet_.items.forEach((pc, i2) => {
                  pc.props.set("selected", i2 === index2);
                });
              } else {
                this.keepSelection_();
              }
            }
          }
          const TabBladePlugin = {
            id: "tab",
            type: "blade",
            accept(params) {
              const p = ParamsParsers;
              const result = parseParams(params, {
                pages: p.required.array(p.required.object({ title: p.required.string })),
                view: p.required.constant("tab")
              });
              if (!result || result.pages.length === 0) {
                return null;
              }
              return { params: result };
            },
            controller(args) {
              const c = new TabController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps
              });
              args.params.pages.forEach((p) => {
                const pc = new TabPageController(args.document, {
                  itemProps: ValueMap.fromObject({
                    selected: false,
                    title: p.title
                  }),
                  props: ValueMap.fromObject({
                    selected: false
                  })
                });
                c.add(pc);
              });
              return c;
            },
            api(args) {
              if (!(args.controller instanceof TabController)) {
                return null;
              }
              return new TabApi(args.controller, args.pool);
            }
          };
          function createBladeController(plugin, args) {
            const ac = plugin.accept(args.params);
            if (!ac) {
              return null;
            }
            const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
            const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
            return plugin.controller({
              blade: createBlade(),
              document: args.document,
              params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
              viewProps: ViewProps.create({
                disabled,
                hidden
              })
            });
          }
          class ManualTicker {
            constructor() {
              this.disabled = false;
              this.emitter = new Emitter();
            }
            dispose() {
            }
            tick() {
              if (this.disabled) {
                return;
              }
              this.emitter.emit("tick", {
                sender: this
              });
            }
          }
          class IntervalTicker {
            constructor(doc, interval) {
              this.disabled_ = false;
              this.timerId_ = null;
              this.onTick_ = this.onTick_.bind(this);
              this.doc_ = doc;
              this.emitter = new Emitter();
              this.interval_ = interval;
              this.setTimer_();
            }
            get disabled() {
              return this.disabled_;
            }
            set disabled(inactive) {
              this.disabled_ = inactive;
              if (this.disabled_) {
                this.clearTimer_();
              } else {
                this.setTimer_();
              }
            }
            dispose() {
              this.clearTimer_();
            }
            clearTimer_() {
              if (this.timerId_ === null) {
                return;
              }
              const win = this.doc_.defaultView;
              if (win) {
                win.clearInterval(this.timerId_);
              }
              this.timerId_ = null;
            }
            setTimer_() {
              this.clearTimer_();
              if (this.interval_ <= 0) {
                return;
              }
              const win = this.doc_.defaultView;
              if (win) {
                this.timerId_ = win.setInterval(this.onTick_, this.interval_);
              }
            }
            onTick_() {
              if (this.disabled_) {
                return;
              }
              this.emitter.emit("tick", {
                sender: this
              });
            }
          }
          class CompositeConstraint {
            constructor(constraints) {
              this.constraints = constraints;
            }
            constrain(value) {
              return this.constraints.reduce((result, c) => {
                return c.constrain(result);
              }, value);
            }
          }
          function findConstraint(c, constraintClass) {
            if (c instanceof constraintClass) {
              return c;
            }
            if (c instanceof CompositeConstraint) {
              const result = c.constraints.reduce((tmpResult, sc) => {
                if (tmpResult) {
                  return tmpResult;
                }
                return sc instanceof constraintClass ? sc : null;
              }, null);
              if (result) {
                return result;
              }
            }
            return null;
          }
          class ListConstraint {
            constructor(options) {
              this.options = options;
            }
            constrain(value) {
              const opts = this.options;
              if (opts.length === 0) {
                return value;
              }
              const matched = opts.filter((item) => {
                return item.value === value;
              }).length > 0;
              return matched ? value : opts[0].value;
            }
          }
          class RangeConstraint {
            constructor(config3) {
              this.maxValue = config3.max;
              this.minValue = config3.min;
            }
            constrain(value) {
              let result = value;
              if (!isEmpty(this.minValue)) {
                result = Math.max(result, this.minValue);
              }
              if (!isEmpty(this.maxValue)) {
                result = Math.min(result, this.maxValue);
              }
              return result;
            }
          }
          class StepConstraint {
            constructor(step) {
              this.step = step;
            }
            constrain(value) {
              const r = value < 0 ? -Math.round(-value / this.step) : Math.round(value / this.step);
              return r * this.step;
            }
          }
          const className$j = ClassName("lst");
          class ListView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.props_ = config3.props;
              this.element = doc.createElement("div");
              this.element.classList.add(className$j());
              config3.viewProps.bindClassModifiers(this.element);
              const selectElem = doc.createElement("select");
              selectElem.classList.add(className$j("s"));
              bindValueMap(this.props_, "options", (opts) => {
                removeChildElements(selectElem);
                opts.forEach((item, index2) => {
                  const optionElem = doc.createElement("option");
                  optionElem.dataset.index = String(index2);
                  optionElem.textContent = item.text;
                  optionElem.value = String(item.value);
                  selectElem.appendChild(optionElem);
                });
              });
              config3.viewProps.bindDisabled(selectElem);
              this.element.appendChild(selectElem);
              this.selectElement = selectElem;
              const markElem = doc.createElement("div");
              markElem.classList.add(className$j("m"));
              markElem.appendChild(createSvgIconElement(doc, "dropdown"));
              this.element.appendChild(markElem);
              config3.value.emitter.on("change", this.onValueChange_);
              this.value_ = config3.value;
              this.update_();
            }
            update_() {
              this.selectElement.value = String(this.value_.rawValue);
            }
            onValueChange_() {
              this.update_();
            }
          }
          class ListController {
            constructor(doc, config3) {
              this.onSelectChange_ = this.onSelectChange_.bind(this);
              this.props = config3.props;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new ListView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
              });
              this.view.selectElement.addEventListener("change", this.onSelectChange_);
            }
            onSelectChange_(e) {
              const selectElem = forceCast(e.currentTarget);
              const optElem = selectElem.selectedOptions.item(0);
              if (!optElem) {
                return;
              }
              const itemIndex = Number(optElem.dataset.index);
              this.value.rawValue = this.props.get("options")[itemIndex].value;
            }
          }
          const className$i = ClassName("pop");
          class PopupView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$i());
              config3.viewProps.bindClassModifiers(this.element);
              bindValue(config3.shows, valueToClassName(this.element, className$i(void 0, "v")));
            }
          }
          class PopupController {
            constructor(doc, config3) {
              this.shows = createValue(false);
              this.viewProps = config3.viewProps;
              this.view = new PopupView(doc, {
                shows: this.shows,
                viewProps: this.viewProps
              });
            }
          }
          const className$h = ClassName("txt");
          class TextView {
            constructor(doc, config3) {
              this.onChange_ = this.onChange_.bind(this);
              this.element = doc.createElement("div");
              this.element.classList.add(className$h());
              config3.viewProps.bindClassModifiers(this.element);
              this.props_ = config3.props;
              this.props_.emitter.on("change", this.onChange_);
              const inputElem = doc.createElement("input");
              inputElem.classList.add(className$h("i"));
              inputElem.type = "text";
              config3.viewProps.bindDisabled(inputElem);
              this.element.appendChild(inputElem);
              this.inputElement = inputElem;
              config3.value.emitter.on("change", this.onChange_);
              this.value_ = config3.value;
              this.refresh();
            }
            refresh() {
              const formatter = this.props_.get("formatter");
              this.inputElement.value = formatter(this.value_.rawValue);
            }
            onChange_() {
              this.refresh();
            }
          }
          class TextController {
            constructor(doc, config3) {
              this.onInputChange_ = this.onInputChange_.bind(this);
              this.parser_ = config3.parser;
              this.props = config3.props;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new TextView(doc, {
                props: config3.props,
                value: this.value,
                viewProps: this.viewProps
              });
              this.view.inputElement.addEventListener("change", this.onInputChange_);
            }
            onInputChange_(e) {
              const inputElem = forceCast(e.currentTarget);
              const value = inputElem.value;
              const parsedValue = this.parser_(value);
              if (!isEmpty(parsedValue)) {
                this.value.rawValue = parsedValue;
              }
              this.view.refresh();
            }
          }
          function boolToString(value) {
            return String(value);
          }
          function boolFromUnknown(value) {
            if (value === "false") {
              return false;
            }
            return !!value;
          }
          function BooleanFormatter(value) {
            return boolToString(value);
          }
          class NumberLiteralNode {
            constructor(text2) {
              this.text = text2;
            }
            evaluate() {
              return Number(this.text);
            }
            toString() {
              return this.text;
            }
          }
          const BINARY_OPERATION_MAP = {
            "**": (v1, v2) => Math.pow(v1, v2),
            "*": (v1, v2) => v1 * v2,
            "/": (v1, v2) => v1 / v2,
            "%": (v1, v2) => v1 % v2,
            "+": (v1, v2) => v1 + v2,
            "-": (v1, v2) => v1 - v2,
            "<<": (v1, v2) => v1 << v2,
            ">>": (v1, v2) => v1 >> v2,
            ">>>": (v1, v2) => v1 >>> v2,
            "&": (v1, v2) => v1 & v2,
            "^": (v1, v2) => v1 ^ v2,
            "|": (v1, v2) => v1 | v2
          };
          class BinaryOperationNode {
            constructor(operator, left, right) {
              this.left = left;
              this.operator = operator;
              this.right = right;
            }
            evaluate() {
              const op = BINARY_OPERATION_MAP[this.operator];
              if (!op) {
                throw new Error(`unexpected binary operator: '${this.operator}`);
              }
              return op(this.left.evaluate(), this.right.evaluate());
            }
            toString() {
              return [
                "b(",
                this.left.toString(),
                this.operator,
                this.right.toString(),
                ")"
              ].join(" ");
            }
          }
          const UNARY_OPERATION_MAP = {
            "+": (v) => v,
            "-": (v) => -v,
            "~": (v) => ~v
          };
          class UnaryOperationNode {
            constructor(operator, expr) {
              this.operator = operator;
              this.expression = expr;
            }
            evaluate() {
              const op = UNARY_OPERATION_MAP[this.operator];
              if (!op) {
                throw new Error(`unexpected unary operator: '${this.operator}`);
              }
              return op(this.expression.evaluate());
            }
            toString() {
              return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
            }
          }
          function combineReader(parsers) {
            return (text2, cursor) => {
              for (let i2 = 0; i2 < parsers.length; i2++) {
                const result = parsers[i2](text2, cursor);
                if (result !== "") {
                  return result;
                }
              }
              return "";
            };
          }
          function readWhitespace(text2, cursor) {
            var _a;
            const m = text2.substr(cursor).match(/^\s+/);
            return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
          }
          function readNonZeroDigit(text2, cursor) {
            const ch = text2.substr(cursor, 1);
            return ch.match(/^[1-9]$/) ? ch : "";
          }
          function readDecimalDigits(text2, cursor) {
            var _a;
            const m = text2.substr(cursor).match(/^[0-9]+/);
            return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
          }
          function readSignedInteger(text2, cursor) {
            const ds = readDecimalDigits(text2, cursor);
            if (ds !== "") {
              return ds;
            }
            const sign2 = text2.substr(cursor, 1);
            cursor += 1;
            if (sign2 !== "-" && sign2 !== "+") {
              return "";
            }
            const sds = readDecimalDigits(text2, cursor);
            if (sds === "") {
              return "";
            }
            return sign2 + sds;
          }
          function readExponentPart(text2, cursor) {
            const e = text2.substr(cursor, 1);
            cursor += 1;
            if (e.toLowerCase() !== "e") {
              return "";
            }
            const si = readSignedInteger(text2, cursor);
            if (si === "") {
              return "";
            }
            return e + si;
          }
          function readDecimalIntegerLiteral(text2, cursor) {
            const ch = text2.substr(cursor, 1);
            if (ch === "0") {
              return ch;
            }
            const nzd = readNonZeroDigit(text2, cursor);
            cursor += nzd.length;
            if (nzd === "") {
              return "";
            }
            return nzd + readDecimalDigits(text2, cursor);
          }
          function readDecimalLiteral1(text2, cursor) {
            const dil = readDecimalIntegerLiteral(text2, cursor);
            cursor += dil.length;
            if (dil === "") {
              return "";
            }
            const dot = text2.substr(cursor, 1);
            cursor += dot.length;
            if (dot !== ".") {
              return "";
            }
            const dds = readDecimalDigits(text2, cursor);
            cursor += dds.length;
            return dil + dot + dds + readExponentPart(text2, cursor);
          }
          function readDecimalLiteral2(text2, cursor) {
            const dot = text2.substr(cursor, 1);
            cursor += dot.length;
            if (dot !== ".") {
              return "";
            }
            const dds = readDecimalDigits(text2, cursor);
            cursor += dds.length;
            if (dds === "") {
              return "";
            }
            return dot + dds + readExponentPart(text2, cursor);
          }
          function readDecimalLiteral3(text2, cursor) {
            const dil = readDecimalIntegerLiteral(text2, cursor);
            cursor += dil.length;
            if (dil === "") {
              return "";
            }
            return dil + readExponentPart(text2, cursor);
          }
          const readDecimalLiteral = combineReader([
            readDecimalLiteral1,
            readDecimalLiteral2,
            readDecimalLiteral3
          ]);
          function parseBinaryDigits(text2, cursor) {
            var _a;
            const m = text2.substr(cursor).match(/^[01]+/);
            return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
          }
          function readBinaryIntegerLiteral(text2, cursor) {
            const prefix = text2.substr(cursor, 2);
            cursor += prefix.length;
            if (prefix.toLowerCase() !== "0b") {
              return "";
            }
            const bds = parseBinaryDigits(text2, cursor);
            if (bds === "") {
              return "";
            }
            return prefix + bds;
          }
          function readOctalDigits(text2, cursor) {
            var _a;
            const m = text2.substr(cursor).match(/^[0-7]+/);
            return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
          }
          function readOctalIntegerLiteral(text2, cursor) {
            const prefix = text2.substr(cursor, 2);
            cursor += prefix.length;
            if (prefix.toLowerCase() !== "0o") {
              return "";
            }
            const ods = readOctalDigits(text2, cursor);
            if (ods === "") {
              return "";
            }
            return prefix + ods;
          }
          function readHexDigits(text2, cursor) {
            var _a;
            const m = text2.substr(cursor).match(/^[0-9a-f]+/i);
            return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
          }
          function readHexIntegerLiteral(text2, cursor) {
            const prefix = text2.substr(cursor, 2);
            cursor += prefix.length;
            if (prefix.toLowerCase() !== "0x") {
              return "";
            }
            const hds = readHexDigits(text2, cursor);
            if (hds === "") {
              return "";
            }
            return prefix + hds;
          }
          const readNonDecimalIntegerLiteral = combineReader([
            readBinaryIntegerLiteral,
            readOctalIntegerLiteral,
            readHexIntegerLiteral
          ]);
          const readNumericLiteral = combineReader([
            readNonDecimalIntegerLiteral,
            readDecimalLiteral
          ]);
          function parseLiteral(text2, cursor) {
            const num = readNumericLiteral(text2, cursor);
            cursor += num.length;
            if (num === "") {
              return null;
            }
            return {
              evaluable: new NumberLiteralNode(num),
              cursor
            };
          }
          function parseParenthesizedExpression(text2, cursor) {
            const op = text2.substr(cursor, 1);
            cursor += op.length;
            if (op !== "(") {
              return null;
            }
            const expr = parseExpression(text2, cursor);
            if (!expr) {
              return null;
            }
            cursor = expr.cursor;
            cursor += readWhitespace(text2, cursor).length;
            const cl = text2.substr(cursor, 1);
            cursor += cl.length;
            if (cl !== ")") {
              return null;
            }
            return {
              evaluable: expr.evaluable,
              cursor
            };
          }
          function parsePrimaryExpression(text2, cursor) {
            return parseLiteral(text2, cursor) || parseParenthesizedExpression(text2, cursor);
          }
          function parseUnaryExpression(text2, cursor) {
            const expr = parsePrimaryExpression(text2, cursor);
            if (expr) {
              return expr;
            }
            const op = text2.substr(cursor, 1);
            cursor += op.length;
            if (op !== "+" && op !== "-" && op !== "~") {
              return null;
            }
            const num = parseUnaryExpression(text2, cursor);
            if (!num) {
              return null;
            }
            cursor = num.cursor;
            return {
              cursor,
              evaluable: new UnaryOperationNode(op, num.evaluable)
            };
          }
          function readBinaryOperator(ops, text2, cursor) {
            cursor += readWhitespace(text2, cursor).length;
            const op = ops.filter((op2) => text2.startsWith(op2, cursor))[0];
            if (!op) {
              return null;
            }
            cursor += op.length;
            cursor += readWhitespace(text2, cursor).length;
            return {
              cursor,
              operator: op
            };
          }
          function createBinaryOperationExpressionParser(exprParser, ops) {
            return (text2, cursor) => {
              const firstExpr = exprParser(text2, cursor);
              if (!firstExpr) {
                return null;
              }
              cursor = firstExpr.cursor;
              let expr = firstExpr.evaluable;
              for (; ; ) {
                const op = readBinaryOperator(ops, text2, cursor);
                if (!op) {
                  break;
                }
                cursor = op.cursor;
                const nextExpr = exprParser(text2, cursor);
                if (!nextExpr) {
                  return null;
                }
                cursor = nextExpr.cursor;
                expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
              }
              return expr ? {
                cursor,
                evaluable: expr
              } : null;
            };
          }
          const parseBinaryOperationExpression = [
            ["**"],
            ["*", "/", "%"],
            ["+", "-"],
            ["<<", ">>>", ">>"],
            ["&"],
            ["^"],
            ["|"]
          ].reduce((parser, ops) => {
            return createBinaryOperationExpressionParser(parser, ops);
          }, parseUnaryExpression);
          function parseExpression(text2, cursor) {
            cursor += readWhitespace(text2, cursor).length;
            return parseBinaryOperationExpression(text2, cursor);
          }
          function parseEcmaNumberExpression(text2) {
            const expr = parseExpression(text2, 0);
            if (!expr) {
              return null;
            }
            const cursor = expr.cursor + readWhitespace(text2, expr.cursor).length;
            if (cursor !== text2.length) {
              return null;
            }
            return expr.evaluable;
          }
          function parseNumber(text2) {
            var _a;
            const r = parseEcmaNumberExpression(text2);
            return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
          }
          function numberFromUnknown(value) {
            if (typeof value === "number") {
              return value;
            }
            if (typeof value === "string") {
              const pv = parseNumber(value);
              if (!isEmpty(pv)) {
                return pv;
              }
            }
            return 0;
          }
          function numberToString(value) {
            return String(value);
          }
          function createNumberFormatter(digits) {
            return (value) => {
              return value.toFixed(Math.max(Math.min(digits, 20), 0));
            };
          }
          const innerFormatter = createNumberFormatter(0);
          function formatPercentage(value) {
            return innerFormatter(value) + "%";
          }
          function stringFromUnknown(value) {
            return String(value);
          }
          function formatString(value) {
            return value;
          }
          function fillBuffer(buffer, bufferSize) {
            while (buffer.length < bufferSize) {
              buffer.push(void 0);
            }
          }
          function initializeBuffer(bufferSize) {
            const buffer = [];
            fillBuffer(buffer, bufferSize);
            return createValue(buffer);
          }
          function createTrimmedBuffer(buffer) {
            const index2 = buffer.indexOf(void 0);
            return forceCast(index2 < 0 ? buffer : buffer.slice(0, index2));
          }
          function createPushedBuffer(buffer, newValue) {
            const newBuffer = [...createTrimmedBuffer(buffer), newValue];
            if (newBuffer.length > buffer.length) {
              newBuffer.splice(0, newBuffer.length - buffer.length);
            } else {
              fillBuffer(newBuffer, buffer.length);
            }
            return newBuffer;
          }
          function connectValues({ primary, secondary, forward, backward }) {
            let changing = false;
            function preventFeedback(callback) {
              if (changing) {
                return;
              }
              changing = true;
              callback();
              changing = false;
            }
            primary.emitter.on("change", (ev) => {
              preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
              });
            });
            secondary.emitter.on("change", (ev) => {
              preventFeedback(() => {
                primary.setRawValue(backward(primary, secondary), ev.options);
              });
              preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
              });
            });
            preventFeedback(() => {
              secondary.setRawValue(forward(primary, secondary), {
                forceEmit: false,
                last: true
              });
            });
          }
          function getStepForKey(baseStep, keys) {
            const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
            if (keys.upKey) {
              return +step;
            } else if (keys.downKey) {
              return -step;
            }
            return 0;
          }
          function getVerticalStepKeys(ev) {
            return {
              altKey: ev.altKey,
              downKey: ev.key === "ArrowDown",
              shiftKey: ev.shiftKey,
              upKey: ev.key === "ArrowUp"
            };
          }
          function getHorizontalStepKeys(ev) {
            return {
              altKey: ev.altKey,
              downKey: ev.key === "ArrowLeft",
              shiftKey: ev.shiftKey,
              upKey: ev.key === "ArrowRight"
            };
          }
          function isVerticalArrowKey(key) {
            return key === "ArrowUp" || key === "ArrowDown";
          }
          function isArrowKey(key) {
            return isVerticalArrowKey(key) || key === "ArrowLeft" || key === "ArrowRight";
          }
          function computeOffset$1(ev, elem) {
            const win = elem.ownerDocument.defaultView;
            const rect = elem.getBoundingClientRect();
            return {
              x: ev.pageX - ((win && win.scrollX || 0) + rect.left),
              y: ev.pageY - ((win && win.scrollY || 0) + rect.top)
            };
          }
          class PointerHandler {
            constructor(element) {
              this.lastTouch_ = null;
              this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
              this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
              this.onMouseDown_ = this.onMouseDown_.bind(this);
              this.onTouchEnd_ = this.onTouchEnd_.bind(this);
              this.onTouchMove_ = this.onTouchMove_.bind(this);
              this.onTouchStart_ = this.onTouchStart_.bind(this);
              this.elem_ = element;
              this.emitter = new Emitter();
              element.addEventListener("touchstart", this.onTouchStart_);
              element.addEventListener("touchmove", this.onTouchMove_);
              element.addEventListener("touchend", this.onTouchEnd_);
              element.addEventListener("mousedown", this.onMouseDown_);
            }
            computePosition_(offset2) {
              const rect = this.elem_.getBoundingClientRect();
              return {
                bounds: {
                  width: rect.width,
                  height: rect.height
                },
                point: offset2 ? {
                  x: offset2.x,
                  y: offset2.y
                } : null
              };
            }
            onMouseDown_(ev) {
              var _a;
              ev.preventDefault();
              (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
              const doc = this.elem_.ownerDocument;
              doc.addEventListener("mousemove", this.onDocumentMouseMove_);
              doc.addEventListener("mouseup", this.onDocumentMouseUp_);
              this.emitter.emit("down", {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey
              });
            }
            onDocumentMouseMove_(ev) {
              this.emitter.emit("move", {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey
              });
            }
            onDocumentMouseUp_(ev) {
              const doc = this.elem_.ownerDocument;
              doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
              doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
              this.emitter.emit("up", {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey
              });
            }
            onTouchStart_(ev) {
              ev.preventDefault();
              const touch = ev.targetTouches.item(0);
              const rect = this.elem_.getBoundingClientRect();
              this.emitter.emit("down", {
                altKey: ev.altKey,
                data: this.computePosition_(touch ? {
                  x: touch.clientX - rect.left,
                  y: touch.clientY - rect.top
                } : void 0),
                sender: this,
                shiftKey: ev.shiftKey
              });
              this.lastTouch_ = touch;
            }
            onTouchMove_(ev) {
              const touch = ev.targetTouches.item(0);
              const rect = this.elem_.getBoundingClientRect();
              this.emitter.emit("move", {
                altKey: ev.altKey,
                data: this.computePosition_(touch ? {
                  x: touch.clientX - rect.left,
                  y: touch.clientY - rect.top
                } : void 0),
                sender: this,
                shiftKey: ev.shiftKey
              });
              this.lastTouch_ = touch;
            }
            onTouchEnd_(ev) {
              var _a;
              const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
              const rect = this.elem_.getBoundingClientRect();
              this.emitter.emit("up", {
                altKey: ev.altKey,
                data: this.computePosition_(touch ? {
                  x: touch.clientX - rect.left,
                  y: touch.clientY - rect.top
                } : void 0),
                sender: this,
                shiftKey: ev.shiftKey
              });
            }
          }
          function mapRange3(value, start1, end1, start2, end2) {
            const p = (value - start1) / (end1 - start1);
            return start2 + p * (end2 - start2);
          }
          function getDecimalDigits(value) {
            const text2 = String(value.toFixed(10));
            const frac = text2.split(".")[1];
            return frac.replace(/0+$/, "").length;
          }
          function constrainRange(value, min, max) {
            return Math.min(Math.max(value, min), max);
          }
          function loopRange(value, max) {
            return (value % max + max) % max;
          }
          const className$g = ClassName("txt");
          class NumberTextView {
            constructor(doc, config3) {
              this.onChange_ = this.onChange_.bind(this);
              this.props_ = config3.props;
              this.props_.emitter.on("change", this.onChange_);
              this.element = doc.createElement("div");
              this.element.classList.add(className$g(), className$g(void 0, "num"));
              if (config3.arrayPosition) {
                this.element.classList.add(className$g(void 0, config3.arrayPosition));
              }
              config3.viewProps.bindClassModifiers(this.element);
              const inputElem = doc.createElement("input");
              inputElem.classList.add(className$g("i"));
              inputElem.type = "text";
              config3.viewProps.bindDisabled(inputElem);
              this.element.appendChild(inputElem);
              this.inputElement = inputElem;
              this.onDraggingChange_ = this.onDraggingChange_.bind(this);
              this.dragging_ = config3.dragging;
              this.dragging_.emitter.on("change", this.onDraggingChange_);
              this.element.classList.add(className$g());
              this.inputElement.classList.add(className$g("i"));
              const knobElem = doc.createElement("div");
              knobElem.classList.add(className$g("k"));
              this.element.appendChild(knobElem);
              this.knobElement = knobElem;
              const guideElem = doc.createElementNS(SVG_NS, "svg");
              guideElem.classList.add(className$g("g"));
              this.knobElement.appendChild(guideElem);
              const bodyElem = doc.createElementNS(SVG_NS, "path");
              bodyElem.classList.add(className$g("gb"));
              guideElem.appendChild(bodyElem);
              this.guideBodyElem_ = bodyElem;
              const headElem = doc.createElementNS(SVG_NS, "path");
              headElem.classList.add(className$g("gh"));
              guideElem.appendChild(headElem);
              this.guideHeadElem_ = headElem;
              const tooltipElem = doc.createElement("div");
              tooltipElem.classList.add(ClassName("tt")());
              this.knobElement.appendChild(tooltipElem);
              this.tooltipElem_ = tooltipElem;
              config3.value.emitter.on("change", this.onChange_);
              this.value = config3.value;
              this.refresh();
            }
            onDraggingChange_(ev) {
              if (ev.rawValue === null) {
                this.element.classList.remove(className$g(void 0, "drg"));
                return;
              }
              this.element.classList.add(className$g(void 0, "drg"));
              const x = ev.rawValue / this.props_.get("draggingScale");
              const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
              const adx = constrainRange(-aox, -4, 4);
              this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(" "));
              this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
              const formatter = this.props_.get("formatter");
              this.tooltipElem_.textContent = formatter(this.value.rawValue);
              this.tooltipElem_.style.left = `${x}px`;
            }
            refresh() {
              const formatter = this.props_.get("formatter");
              this.inputElement.value = formatter(this.value.rawValue);
            }
            onChange_() {
              this.refresh();
            }
          }
          class NumberTextController {
            constructor(doc, config3) {
              this.originRawValue_ = 0;
              this.onInputChange_ = this.onInputChange_.bind(this);
              this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
              this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
              this.onPointerDown_ = this.onPointerDown_.bind(this);
              this.onPointerMove_ = this.onPointerMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.baseStep_ = config3.baseStep;
              this.parser_ = config3.parser;
              this.props = config3.props;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.dragging_ = createValue(null);
              this.view = new NumberTextView(doc, {
                arrayPosition: config3.arrayPosition,
                dragging: this.dragging_,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
              });
              this.view.inputElement.addEventListener("change", this.onInputChange_);
              this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
              this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
              const ph = new PointerHandler(this.view.knobElement);
              ph.emitter.on("down", this.onPointerDown_);
              ph.emitter.on("move", this.onPointerMove_);
              ph.emitter.on("up", this.onPointerUp_);
            }
            onInputChange_(e) {
              const inputElem = forceCast(e.currentTarget);
              const value = inputElem.value;
              const parsedValue = this.parser_(value);
              if (!isEmpty(parsedValue)) {
                this.value.rawValue = parsedValue;
              }
              this.view.refresh();
            }
            onInputKeyDown_(ev) {
              const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue + step, {
                forceEmit: false,
                last: false
              });
            }
            onInputKeyUp_(ev) {
              const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
            onPointerDown_() {
              this.originRawValue_ = this.value.rawValue;
              this.dragging_.rawValue = 0;
            }
            computeDraggingValue_(data) {
              if (!data.point) {
                return null;
              }
              const dx = data.point.x - data.bounds.width / 2;
              return this.originRawValue_ + dx * this.props.get("draggingScale");
            }
            onPointerMove_(ev) {
              const v = this.computeDraggingValue_(ev.data);
              if (v === null) {
                return;
              }
              this.value.setRawValue(v, {
                forceEmit: false,
                last: false
              });
              this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
            }
            onPointerUp_(ev) {
              const v = this.computeDraggingValue_(ev.data);
              if (v === null) {
                return;
              }
              this.value.setRawValue(v, {
                forceEmit: true,
                last: true
              });
              this.dragging_.rawValue = null;
            }
          }
          const className$f = ClassName("sld");
          class SliderView {
            constructor(doc, config3) {
              this.onChange_ = this.onChange_.bind(this);
              this.props_ = config3.props;
              this.props_.emitter.on("change", this.onChange_);
              this.element = doc.createElement("div");
              this.element.classList.add(className$f());
              config3.viewProps.bindClassModifiers(this.element);
              const trackElem = doc.createElement("div");
              trackElem.classList.add(className$f("t"));
              config3.viewProps.bindTabIndex(trackElem);
              this.element.appendChild(trackElem);
              this.trackElement = trackElem;
              const knobElem = doc.createElement("div");
              knobElem.classList.add(className$f("k"));
              this.trackElement.appendChild(knobElem);
              this.knobElement = knobElem;
              config3.value.emitter.on("change", this.onChange_);
              this.value = config3.value;
              this.update_();
            }
            update_() {
              const p = constrainRange(mapRange3(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
              this.knobElement.style.width = `${p}%`;
            }
            onChange_() {
              this.update_();
            }
          }
          class SliderController {
            constructor(doc, config3) {
              this.onKeyDown_ = this.onKeyDown_.bind(this);
              this.onKeyUp_ = this.onKeyUp_.bind(this);
              this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.baseStep_ = config3.baseStep;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.props = config3.props;
              this.view = new SliderView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps
              });
              this.ptHandler_ = new PointerHandler(this.view.trackElement);
              this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
              this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
              this.ptHandler_.emitter.on("up", this.onPointerUp_);
              this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
              this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
            }
            handlePointerEvent_(d, opts) {
              if (!d.point) {
                return;
              }
              this.value.setRawValue(mapRange3(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
            }
            onPointerDownOrMove_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerUp_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true
              });
            }
            onKeyDown_(ev) {
              const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue + step, {
                forceEmit: false,
                last: false
              });
            }
            onKeyUp_(ev) {
              const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
          }
          const className$e = ClassName("sldtxt");
          class SliderTextView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$e());
              const sliderElem = doc.createElement("div");
              sliderElem.classList.add(className$e("s"));
              this.sliderView_ = config3.sliderView;
              sliderElem.appendChild(this.sliderView_.element);
              this.element.appendChild(sliderElem);
              const textElem = doc.createElement("div");
              textElem.classList.add(className$e("t"));
              this.textView_ = config3.textView;
              textElem.appendChild(this.textView_.element);
              this.element.appendChild(textElem);
            }
          }
          class SliderTextController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.sliderC_ = new SliderController(doc, {
                baseStep: config3.baseStep,
                props: config3.sliderProps,
                value: config3.value,
                viewProps: this.viewProps
              });
              this.textC_ = new NumberTextController(doc, {
                baseStep: config3.baseStep,
                parser: config3.parser,
                props: config3.textProps,
                value: config3.value,
                viewProps: config3.viewProps
              });
              this.view = new SliderTextView(doc, {
                sliderView: this.sliderC_.view,
                textView: this.textC_.view
              });
            }
            get sliderController() {
              return this.sliderC_;
            }
            get textController() {
              return this.textC_;
            }
          }
          function writePrimitive(target, value) {
            target.write(value);
          }
          function parseListOptions(value) {
            const p = ParamsParsers;
            if (Array.isArray(value)) {
              return p.required.array(p.required.object({
                text: p.required.string,
                value: p.required.raw
              }))(value).value;
            }
            if (typeof value === "object") {
              return p.required.raw(value).value;
            }
            return void 0;
          }
          function parsePickerLayout(value) {
            if (value === "inline" || value === "popup") {
              return value;
            }
            return void 0;
          }
          function parsePointDimensionParams(value) {
            const p = ParamsParsers;
            return p.required.object({
              max: p.optional.number,
              min: p.optional.number,
              step: p.optional.number
            })(value).value;
          }
          function normalizeListOptions(options) {
            if (Array.isArray(options)) {
              return options;
            }
            const items = [];
            Object.keys(options).forEach((text2) => {
              items.push({ text: text2, value: options[text2] });
            });
            return items;
          }
          function createListConstraint(options) {
            return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
          }
          function findListItems(constraint) {
            const c = constraint ? findConstraint(constraint, ListConstraint) : null;
            if (!c) {
              return null;
            }
            return c.options;
          }
          function findStep(constraint) {
            const c = constraint ? findConstraint(constraint, StepConstraint) : null;
            if (!c) {
              return null;
            }
            return c.step;
          }
          function getSuitableDecimalDigits(constraint, rawValue) {
            const sc = constraint && findConstraint(constraint, StepConstraint);
            if (sc) {
              return getDecimalDigits(sc.step);
            }
            return Math.max(getDecimalDigits(rawValue), 2);
          }
          function getBaseStep(constraint) {
            const step = findStep(constraint);
            return step !== null && step !== void 0 ? step : 1;
          }
          function getSuitableDraggingScale(constraint, rawValue) {
            var _a;
            const sc = constraint && findConstraint(constraint, StepConstraint);
            const base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
            return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
          }
          const className$d = ClassName("ckb");
          class CheckboxView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.element = doc.createElement("div");
              this.element.classList.add(className$d());
              config3.viewProps.bindClassModifiers(this.element);
              const labelElem = doc.createElement("label");
              labelElem.classList.add(className$d("l"));
              this.element.appendChild(labelElem);
              const inputElem = doc.createElement("input");
              inputElem.classList.add(className$d("i"));
              inputElem.type = "checkbox";
              labelElem.appendChild(inputElem);
              this.inputElement = inputElem;
              config3.viewProps.bindDisabled(this.inputElement);
              const wrapperElem = doc.createElement("div");
              wrapperElem.classList.add(className$d("w"));
              labelElem.appendChild(wrapperElem);
              const markElem = createSvgIconElement(doc, "check");
              wrapperElem.appendChild(markElem);
              config3.value.emitter.on("change", this.onValueChange_);
              this.value = config3.value;
              this.update_();
            }
            update_() {
              this.inputElement.checked = this.value.rawValue;
            }
            onValueChange_() {
              this.update_();
            }
          }
          class CheckboxController {
            constructor(doc, config3) {
              this.onInputChange_ = this.onInputChange_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new CheckboxView(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.view.inputElement.addEventListener("change", this.onInputChange_);
            }
            onInputChange_(e) {
              const inputElem = forceCast(e.currentTarget);
              this.value.rawValue = inputElem.checked;
            }
          }
          function createConstraint$5(params) {
            const constraints = [];
            const lc = createListConstraint(params.options);
            if (lc) {
              constraints.push(lc);
            }
            return new CompositeConstraint(constraints);
          }
          const BooleanInputPlugin = {
            id: "input-bool",
            type: "input",
            accept: (value, params) => {
              if (typeof value !== "boolean") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                options: p.optional.custom(parseListOptions)
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => boolFromUnknown,
              constraint: (args) => createConstraint$5(args.params),
              writer: (_args) => writePrimitive
            },
            controller: (args) => {
              var _a;
              const doc = args.document;
              const value = args.value;
              const c = args.constraint;
              if (c && findConstraint(c, ListConstraint)) {
                return new ListController(doc, {
                  props: ValueMap.fromObject({
                    options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                  }),
                  value,
                  viewProps: args.viewProps
                });
              }
              return new CheckboxController(doc, {
                value,
                viewProps: args.viewProps
              });
            }
          };
          const className$c = ClassName("col");
          class ColorView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$c());
              config3.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
              bindValueMap(config3.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
              const headElem = doc.createElement("div");
              headElem.classList.add(className$c("h"));
              this.element.appendChild(headElem);
              const swatchElem = doc.createElement("div");
              swatchElem.classList.add(className$c("s"));
              headElem.appendChild(swatchElem);
              this.swatchElement = swatchElem;
              const textElem = doc.createElement("div");
              textElem.classList.add(className$c("t"));
              headElem.appendChild(textElem);
              this.textElement = textElem;
              if (config3.pickerLayout === "inline") {
                const pickerElem = doc.createElement("div");
                pickerElem.classList.add(className$c("p"));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
              } else {
                this.pickerElement = null;
              }
            }
          }
          function rgbToHsl(r, g, b) {
            const rp = constrainRange(r / 255, 0, 1);
            const gp = constrainRange(g / 255, 0, 1);
            const bp = constrainRange(b / 255, 0, 1);
            const cmax = Math.max(rp, gp, bp);
            const cmin = Math.min(rp, gp, bp);
            const c = cmax - cmin;
            let h = 0;
            let s = 0;
            const l = (cmin + cmax) / 2;
            if (c !== 0) {
              s = c / (1 - Math.abs(cmax + cmin - 1));
              if (rp === cmax) {
                h = (gp - bp) / c;
              } else if (gp === cmax) {
                h = 2 + (bp - rp) / c;
              } else {
                h = 4 + (rp - gp) / c;
              }
              h = h / 6 + (h < 0 ? 1 : 0);
            }
            return [h * 360, s * 100, l * 100];
          }
          function hslToRgb(h, s, l) {
            const hp = (h % 360 + 360) % 360;
            const sp = constrainRange(s / 100, 0, 1);
            const lp = constrainRange(l / 100, 0, 1);
            const c = (1 - Math.abs(2 * lp - 1)) * sp;
            const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
            const m = lp - c / 2;
            let rp, gp, bp;
            if (hp >= 0 && hp < 60) {
              [rp, gp, bp] = [c, x, 0];
            } else if (hp >= 60 && hp < 120) {
              [rp, gp, bp] = [x, c, 0];
            } else if (hp >= 120 && hp < 180) {
              [rp, gp, bp] = [0, c, x];
            } else if (hp >= 180 && hp < 240) {
              [rp, gp, bp] = [0, x, c];
            } else if (hp >= 240 && hp < 300) {
              [rp, gp, bp] = [x, 0, c];
            } else {
              [rp, gp, bp] = [c, 0, x];
            }
            return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
          }
          function rgbToHsv(r, g, b) {
            const rp = constrainRange(r / 255, 0, 1);
            const gp = constrainRange(g / 255, 0, 1);
            const bp = constrainRange(b / 255, 0, 1);
            const cmax = Math.max(rp, gp, bp);
            const cmin = Math.min(rp, gp, bp);
            const d = cmax - cmin;
            let h;
            if (d === 0) {
              h = 0;
            } else if (cmax === rp) {
              h = 60 * (((gp - bp) / d % 6 + 6) % 6);
            } else if (cmax === gp) {
              h = 60 * ((bp - rp) / d + 2);
            } else {
              h = 60 * ((rp - gp) / d + 4);
            }
            const s = cmax === 0 ? 0 : d / cmax;
            const v = cmax;
            return [h, s * 100, v * 100];
          }
          function hsvToRgb(h, s, v) {
            const hp = loopRange(h, 360);
            const sp = constrainRange(s / 100, 0, 1);
            const vp = constrainRange(v / 100, 0, 1);
            const c = vp * sp;
            const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
            const m = vp - c;
            let rp, gp, bp;
            if (hp >= 0 && hp < 60) {
              [rp, gp, bp] = [c, x, 0];
            } else if (hp >= 60 && hp < 120) {
              [rp, gp, bp] = [x, c, 0];
            } else if (hp >= 120 && hp < 180) {
              [rp, gp, bp] = [0, c, x];
            } else if (hp >= 180 && hp < 240) {
              [rp, gp, bp] = [0, x, c];
            } else if (hp >= 240 && hp < 300) {
              [rp, gp, bp] = [x, 0, c];
            } else {
              [rp, gp, bp] = [c, 0, x];
            }
            return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
          }
          function hslToHsv(h, s, l) {
            const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
            return [
              h,
              sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,
              l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)
            ];
          }
          function hsvToHsl(h, s, v) {
            const sd = 100 - Math.abs(v * (200 - s) / 100 - 100);
            return [h, sd !== 0 ? s * v / sd : 0, v * (200 - s) / (2 * 100)];
          }
          function removeAlphaComponent(comps) {
            return [comps[0], comps[1], comps[2]];
          }
          function appendAlphaComponent(comps, alpha) {
            return [comps[0], comps[1], comps[2], alpha];
          }
          const MODE_CONVERTER_MAP = {
            hsl: {
              hsl: (h, s, l) => [h, s, l],
              hsv: hslToHsv,
              rgb: hslToRgb
            },
            hsv: {
              hsl: hsvToHsl,
              hsv: (h, s, v) => [h, s, v],
              rgb: hsvToRgb
            },
            rgb: {
              hsl: rgbToHsl,
              hsv: rgbToHsv,
              rgb: (r, g, b) => [r, g, b]
            }
          };
          function convertColorMode(components, fromMode, toMode) {
            return MODE_CONVERTER_MAP[fromMode][toMode](...components);
          }
          const CONSTRAINT_MAP = {
            hsl: (comps) => {
              var _a;
              return [
                loopRange(comps[0], 360),
                constrainRange(comps[1], 0, 100),
                constrainRange(comps[2], 0, 100),
                constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
              ];
            },
            hsv: (comps) => {
              var _a;
              return [
                loopRange(comps[0], 360),
                constrainRange(comps[1], 0, 100),
                constrainRange(comps[2], 0, 100),
                constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
              ];
            },
            rgb: (comps) => {
              var _a;
              return [
                constrainRange(comps[0], 0, 255),
                constrainRange(comps[1], 0, 255),
                constrainRange(comps[2], 0, 255),
                constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
              ];
            }
          };
          function isRgbColorComponent(obj, key) {
            if (typeof obj !== "object" || isEmpty(obj)) {
              return false;
            }
            return key in obj && typeof obj[key] === "number";
          }
          class Color2 {
            constructor(comps, mode) {
              this.mode_ = mode;
              this.comps_ = CONSTRAINT_MAP[mode](comps);
            }
            static black() {
              return new Color2([0, 0, 0], "rgb");
            }
            static fromObject(obj) {
              const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
              return new Color2(comps, "rgb");
            }
            static toRgbaObject(color) {
              return color.toRgbaObject();
            }
            static isRgbColorObject(obj) {
              return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
            }
            static isRgbaColorObject(obj) {
              return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
            }
            static isColorObject(obj) {
              return this.isRgbColorObject(obj);
            }
            static equals(v1, v2) {
              if (v1.mode_ !== v2.mode_) {
                return false;
              }
              const comps1 = v1.comps_;
              const comps2 = v2.comps_;
              for (let i2 = 0; i2 < comps1.length; i2++) {
                if (comps1[i2] !== comps2[i2]) {
                  return false;
                }
              }
              return true;
            }
            get mode() {
              return this.mode_;
            }
            getComponents(opt_mode) {
              return appendAlphaComponent(convertColorMode(removeAlphaComponent(this.comps_), this.mode_, opt_mode || this.mode_), this.comps_[3]);
            }
            toRgbaObject() {
              const rgbComps = this.getComponents("rgb");
              return {
                r: rgbComps[0],
                g: rgbComps[1],
                b: rgbComps[2],
                a: rgbComps[3]
              };
            }
          }
          const className$b = ClassName("colp");
          class ColorPickerView {
            constructor(doc, config3) {
              this.alphaViews_ = null;
              this.element = doc.createElement("div");
              this.element.classList.add(className$b());
              const hsvElem = doc.createElement("div");
              hsvElem.classList.add(className$b("hsv"));
              const svElem = doc.createElement("div");
              svElem.classList.add(className$b("sv"));
              this.svPaletteView_ = config3.svPaletteView;
              svElem.appendChild(this.svPaletteView_.element);
              hsvElem.appendChild(svElem);
              const hElem = doc.createElement("div");
              hElem.classList.add(className$b("h"));
              this.hPaletteView_ = config3.hPaletteView;
              hElem.appendChild(this.hPaletteView_.element);
              hsvElem.appendChild(hElem);
              this.element.appendChild(hsvElem);
              const rgbElem = doc.createElement("div");
              rgbElem.classList.add(className$b("rgb"));
              this.textView_ = config3.textView;
              rgbElem.appendChild(this.textView_.element);
              this.element.appendChild(rgbElem);
              if (config3.alphaViews) {
                this.alphaViews_ = {
                  palette: config3.alphaViews.palette,
                  text: config3.alphaViews.text
                };
                const aElem = doc.createElement("div");
                aElem.classList.add(className$b("a"));
                const apElem = doc.createElement("div");
                apElem.classList.add(className$b("ap"));
                apElem.appendChild(this.alphaViews_.palette.element);
                aElem.appendChild(apElem);
                const atElem = doc.createElement("div");
                atElem.classList.add(className$b("at"));
                atElem.appendChild(this.alphaViews_.text.element);
                aElem.appendChild(atElem);
                this.element.appendChild(aElem);
              }
            }
            get allFocusableElements() {
              const elems = [
                this.svPaletteView_.element,
                this.hPaletteView_.element,
                this.textView_.modeSelectElement,
                ...this.textView_.textViews.map((v) => v.inputElement)
              ];
              if (this.alphaViews_) {
                elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
              }
              return elems;
            }
          }
          function parseColorInputParams(params) {
            const p = ParamsParsers;
            return parseParams(params, {
              alpha: p.optional.boolean,
              expanded: p.optional.boolean,
              picker: p.optional.custom(parsePickerLayout)
            });
          }
          function getBaseStepForColor(forAlpha) {
            return forAlpha ? 0.1 : 1;
          }
          function parseCssNumberOrPercentage(text2, maxValue) {
            const m = text2.match(/^(.+)%$/);
            if (!m) {
              return Math.min(parseFloat(text2), maxValue);
            }
            return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
          }
          const ANGLE_TO_DEG_MAP = {
            deg: (angle) => angle,
            grad: (angle) => angle * 360 / 400,
            rad: (angle) => angle * 360 / (2 * Math.PI),
            turn: (angle) => angle * 360
          };
          function parseCssNumberOrAngle(text2) {
            const m = text2.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
            if (!m) {
              return parseFloat(text2);
            }
            const angle = parseFloat(m[1]);
            const unit = m[2];
            return ANGLE_TO_DEG_MAP[unit](angle);
          }
          const NOTATION_TO_PARSER_MAP = {
            "func.rgb": (text2) => {
              const m = text2.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
              if (!m) {
                return null;
              }
              const comps = [
                parseCssNumberOrPercentage(m[1], 255),
                parseCssNumberOrPercentage(m[2], 255),
                parseCssNumberOrPercentage(m[3], 255)
              ];
              if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
                return null;
              }
              return new Color2(comps, "rgb");
            },
            "func.rgba": (text2) => {
              const m = text2.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
              if (!m) {
                return null;
              }
              const comps = [
                parseCssNumberOrPercentage(m[1], 255),
                parseCssNumberOrPercentage(m[2], 255),
                parseCssNumberOrPercentage(m[3], 255),
                parseCssNumberOrPercentage(m[4], 1)
              ];
              if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
                return null;
              }
              return new Color2(comps, "rgb");
            },
            "func.hsl": (text2) => {
              const m = text2.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
              if (!m) {
                return null;
              }
              const comps = [
                parseCssNumberOrAngle(m[1]),
                parseCssNumberOrPercentage(m[2], 100),
                parseCssNumberOrPercentage(m[3], 100)
              ];
              if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
                return null;
              }
              return new Color2(comps, "hsl");
            },
            "func.hsla": (text2) => {
              const m = text2.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
              if (!m) {
                return null;
              }
              const comps = [
                parseCssNumberOrAngle(m[1]),
                parseCssNumberOrPercentage(m[2], 100),
                parseCssNumberOrPercentage(m[3], 100),
                parseCssNumberOrPercentage(m[4], 1)
              ];
              if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
                return null;
              }
              return new Color2(comps, "hsl");
            },
            "hex.rgb": (text2) => {
              const mRgb = text2.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
              if (mRgb) {
                return new Color2([
                  parseInt(mRgb[1] + mRgb[1], 16),
                  parseInt(mRgb[2] + mRgb[2], 16),
                  parseInt(mRgb[3] + mRgb[3], 16)
                ], "rgb");
              }
              const mRrggbb = text2.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
              if (mRrggbb) {
                return new Color2([
                  parseInt(mRrggbb[1], 16),
                  parseInt(mRrggbb[2], 16),
                  parseInt(mRrggbb[3], 16)
                ], "rgb");
              }
              return null;
            },
            "hex.rgba": (text2) => {
              const mRgb = text2.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
              if (mRgb) {
                return new Color2([
                  parseInt(mRgb[1] + mRgb[1], 16),
                  parseInt(mRgb[2] + mRgb[2], 16),
                  parseInt(mRgb[3] + mRgb[3], 16),
                  mapRange3(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
                ], "rgb");
              }
              const mRrggbb = text2.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
              if (mRrggbb) {
                return new Color2([
                  parseInt(mRrggbb[1], 16),
                  parseInt(mRrggbb[2], 16),
                  parseInt(mRrggbb[3], 16),
                  mapRange3(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
                ], "rgb");
              }
              return null;
            }
          };
          function getColorNotation(text2) {
            const notations = Object.keys(NOTATION_TO_PARSER_MAP);
            return notations.reduce((result, notation) => {
              if (result) {
                return result;
              }
              const subparser = NOTATION_TO_PARSER_MAP[notation];
              return subparser(text2) ? notation : null;
            }, null);
          }
          const CompositeColorParser = (text2) => {
            const notation = getColorNotation(text2);
            return notation ? NOTATION_TO_PARSER_MAP[notation](text2) : null;
          };
          function hasAlphaComponent(notation) {
            return notation === "func.hsla" || notation === "func.rgba" || notation === "hex.rgba";
          }
          function colorFromString(value) {
            if (typeof value === "string") {
              const cv = CompositeColorParser(value);
              if (cv) {
                return cv;
              }
            }
            return Color2.black();
          }
          function zerofill(comp) {
            const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
            return hex.length === 1 ? `0${hex}` : hex;
          }
          function colorToHexRgbString(value, prefix = "#") {
            const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
            return `${prefix}${hexes}`;
          }
          function colorToHexRgbaString(value, prefix = "#") {
            const rgbaComps = value.getComponents("rgb");
            const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
            return `${prefix}${hexes}`;
          }
          function colorToFunctionalRgbString(value) {
            const formatter = createNumberFormatter(0);
            const comps = removeAlphaComponent(value.getComponents("rgb")).map((comp) => formatter(comp));
            return `rgb(${comps.join(", ")})`;
          }
          function colorToFunctionalRgbaString(value) {
            const aFormatter = createNumberFormatter(2);
            const rgbFormatter = createNumberFormatter(0);
            const comps = value.getComponents("rgb").map((comp, index2) => {
              const formatter = index2 === 3 ? aFormatter : rgbFormatter;
              return formatter(comp);
            });
            return `rgba(${comps.join(", ")})`;
          }
          function colorToFunctionalHslString(value) {
            const formatters = [
              createNumberFormatter(0),
              formatPercentage,
              formatPercentage
            ];
            const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index2) => formatters[index2](comp));
            return `hsl(${comps.join(", ")})`;
          }
          function colorToFunctionalHslaString(value) {
            const formatters = [
              createNumberFormatter(0),
              formatPercentage,
              formatPercentage,
              createNumberFormatter(2)
            ];
            const comps = value.getComponents("hsl").map((comp, index2) => formatters[index2](comp));
            return `hsla(${comps.join(", ")})`;
          }
          const NOTATION_TO_STRINGIFIER_MAP = {
            "func.hsl": colorToFunctionalHslString,
            "func.hsla": colorToFunctionalHslaString,
            "func.rgb": colorToFunctionalRgbString,
            "func.rgba": colorToFunctionalRgbaString,
            "hex.rgb": colorToHexRgbString,
            "hex.rgba": colorToHexRgbaString
          };
          function getColorStringifier(notation) {
            return NOTATION_TO_STRINGIFIER_MAP[notation];
          }
          const className$a = ClassName("apl");
          class APaletteView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.value = config3.value;
              this.value.emitter.on("change", this.onValueChange_);
              this.element = doc.createElement("div");
              this.element.classList.add(className$a());
              config3.viewProps.bindTabIndex(this.element);
              const barElem = doc.createElement("div");
              barElem.classList.add(className$a("b"));
              this.element.appendChild(barElem);
              const colorElem = doc.createElement("div");
              colorElem.classList.add(className$a("c"));
              barElem.appendChild(colorElem);
              this.colorElem_ = colorElem;
              const markerElem = doc.createElement("div");
              markerElem.classList.add(className$a("m"));
              this.element.appendChild(markerElem);
              this.markerElem_ = markerElem;
              const previewElem = doc.createElement("div");
              previewElem.classList.add(className$a("p"));
              this.markerElem_.appendChild(previewElem);
              this.previewElem_ = previewElem;
              this.update_();
            }
            update_() {
              const c = this.value.rawValue;
              const rgbaComps = c.getComponents("rgb");
              const leftColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
              const rightColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
              const gradientComps = [
                "to right",
                colorToFunctionalRgbaString(leftColor),
                colorToFunctionalRgbaString(rightColor)
              ];
              this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
              this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
              const left = mapRange3(rgbaComps[3], 0, 1, 0, 100);
              this.markerElem_.style.left = `${left}%`;
            }
            onValueChange_() {
              this.update_();
            }
          }
          class APaletteController {
            constructor(doc, config3) {
              this.onKeyDown_ = this.onKeyDown_.bind(this);
              this.onKeyUp_ = this.onKeyUp_.bind(this);
              this.onPointerDown_ = this.onPointerDown_.bind(this);
              this.onPointerMove_ = this.onPointerMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new APaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.ptHandler_ = new PointerHandler(this.view.element);
              this.ptHandler_.emitter.on("down", this.onPointerDown_);
              this.ptHandler_.emitter.on("move", this.onPointerMove_);
              this.ptHandler_.emitter.on("up", this.onPointerUp_);
              this.view.element.addEventListener("keydown", this.onKeyDown_);
              this.view.element.addEventListener("keyup", this.onKeyUp_);
            }
            handlePointerEvent_(d, opts) {
              if (!d.point) {
                return;
              }
              const alpha = d.point.x / d.bounds.width;
              const c = this.value.rawValue;
              const [h, s, v] = c.getComponents("hsv");
              this.value.setRawValue(new Color2([h, s, v, alpha], "hsv"), opts);
            }
            onPointerDown_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerMove_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerUp_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true
              });
            }
            onKeyDown_(ev) {
              const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              const c = this.value.rawValue;
              const [h, s, v, a] = c.getComponents("hsv");
              this.value.setRawValue(new Color2([h, s, v, a + step], "hsv"), {
                forceEmit: false,
                last: false
              });
            }
            onKeyUp_(ev) {
              const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
          }
          const className$9 = ClassName("coltxt");
          function createModeSelectElement(doc) {
            const selectElem = doc.createElement("select");
            const items = [
              { text: "RGB", value: "rgb" },
              { text: "HSL", value: "hsl" },
              { text: "HSV", value: "hsv" }
            ];
            selectElem.appendChild(items.reduce((frag, item) => {
              const optElem = doc.createElement("option");
              optElem.textContent = item.text;
              optElem.value = item.value;
              frag.appendChild(optElem);
              return frag;
            }, doc.createDocumentFragment()));
            return selectElem;
          }
          class ColorTextView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$9());
              const modeElem = doc.createElement("div");
              modeElem.classList.add(className$9("m"));
              this.modeElem_ = createModeSelectElement(doc);
              this.modeElem_.classList.add(className$9("ms"));
              modeElem.appendChild(this.modeSelectElement);
              const modeMarkerElem = doc.createElement("div");
              modeMarkerElem.classList.add(className$9("mm"));
              modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
              modeElem.appendChild(modeMarkerElem);
              this.element.appendChild(modeElem);
              const textsElem = doc.createElement("div");
              textsElem.classList.add(className$9("w"));
              this.element.appendChild(textsElem);
              this.textsElem_ = textsElem;
              this.textViews_ = config3.textViews;
              this.applyTextViews_();
              bindValue(config3.colorMode, (mode) => {
                this.modeElem_.value = mode;
              });
            }
            get modeSelectElement() {
              return this.modeElem_;
            }
            get textViews() {
              return this.textViews_;
            }
            set textViews(textViews) {
              this.textViews_ = textViews;
              this.applyTextViews_();
            }
            applyTextViews_() {
              removeChildElements(this.textsElem_);
              const doc = this.element.ownerDocument;
              this.textViews_.forEach((v) => {
                const compElem = doc.createElement("div");
                compElem.classList.add(className$9("c"));
                compElem.appendChild(v.element);
                this.textsElem_.appendChild(compElem);
              });
            }
          }
          const FORMATTER = createNumberFormatter(0);
          const MODE_TO_CONSTRAINT_MAP = {
            rgb: () => {
              return new RangeConstraint({ min: 0, max: 255 });
            },
            hsl: (index2) => {
              return index2 === 0 ? new RangeConstraint({ min: 0, max: 360 }) : new RangeConstraint({ min: 0, max: 100 });
            },
            hsv: (index2) => {
              return index2 === 0 ? new RangeConstraint({ min: 0, max: 360 }) : new RangeConstraint({ min: 0, max: 100 });
            }
          };
          function createComponentController(doc, config3, index2) {
            return new NumberTextController(doc, {
              arrayPosition: index2 === 0 ? "fst" : index2 === 3 - 1 ? "lst" : "mid",
              baseStep: getBaseStepForColor(false),
              parser: config3.parser,
              props: ValueMap.fromObject({
                draggingScale: 1,
                formatter: FORMATTER
              }),
              value: createValue(0, {
                constraint: MODE_TO_CONSTRAINT_MAP[config3.colorMode](index2)
              }),
              viewProps: config3.viewProps
            });
          }
          class ColorTextController {
            constructor(doc, config3) {
              this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
              this.parser_ = config3.parser;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.colorMode = createValue(this.value.rawValue.mode);
              this.ccs_ = this.createComponentControllers_(doc);
              this.view = new ColorTextView(doc, {
                colorMode: this.colorMode,
                textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
              });
              this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
            }
            createComponentControllers_(doc) {
              const cc = {
                colorMode: this.colorMode.rawValue,
                parser: this.parser_,
                viewProps: this.viewProps
              };
              const ccs = [
                createComponentController(doc, cc, 0),
                createComponentController(doc, cc, 1),
                createComponentController(doc, cc, 2)
              ];
              ccs.forEach((cs, index2) => {
                connectValues({
                  primary: this.value,
                  secondary: cs.value,
                  forward: (p) => {
                    return p.rawValue.getComponents(this.colorMode.rawValue)[index2];
                  },
                  backward: (p, s) => {
                    const pickedMode = this.colorMode.rawValue;
                    const comps = p.rawValue.getComponents(pickedMode);
                    comps[index2] = s.rawValue;
                    return new Color2(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode);
                  }
                });
              });
              return ccs;
            }
            onModeSelectChange_(ev) {
              const selectElem = ev.currentTarget;
              this.colorMode.rawValue = selectElem.value;
              this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
              this.view.textViews = [
                this.ccs_[0].view,
                this.ccs_[1].view,
                this.ccs_[2].view
              ];
            }
          }
          const className$8 = ClassName("hpl");
          class HPaletteView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.value = config3.value;
              this.value.emitter.on("change", this.onValueChange_);
              this.element = doc.createElement("div");
              this.element.classList.add(className$8());
              config3.viewProps.bindTabIndex(this.element);
              const colorElem = doc.createElement("div");
              colorElem.classList.add(className$8("c"));
              this.element.appendChild(colorElem);
              const markerElem = doc.createElement("div");
              markerElem.classList.add(className$8("m"));
              this.element.appendChild(markerElem);
              this.markerElem_ = markerElem;
              this.update_();
            }
            update_() {
              const c = this.value.rawValue;
              const [h] = c.getComponents("hsv");
              this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color2([h, 100, 100], "hsv"));
              const left = mapRange3(h, 0, 360, 0, 100);
              this.markerElem_.style.left = `${left}%`;
            }
            onValueChange_() {
              this.update_();
            }
          }
          class HPaletteController {
            constructor(doc, config3) {
              this.onKeyDown_ = this.onKeyDown_.bind(this);
              this.onKeyUp_ = this.onKeyUp_.bind(this);
              this.onPointerDown_ = this.onPointerDown_.bind(this);
              this.onPointerMove_ = this.onPointerMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new HPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.ptHandler_ = new PointerHandler(this.view.element);
              this.ptHandler_.emitter.on("down", this.onPointerDown_);
              this.ptHandler_.emitter.on("move", this.onPointerMove_);
              this.ptHandler_.emitter.on("up", this.onPointerUp_);
              this.view.element.addEventListener("keydown", this.onKeyDown_);
              this.view.element.addEventListener("keyup", this.onKeyUp_);
            }
            handlePointerEvent_(d, opts) {
              if (!d.point) {
                return;
              }
              const hue = mapRange3(d.point.x, 0, d.bounds.width, 0, 360);
              const c = this.value.rawValue;
              const [, s, v, a] = c.getComponents("hsv");
              this.value.setRawValue(new Color2([hue, s, v, a], "hsv"), opts);
            }
            onPointerDown_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerMove_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerUp_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true
              });
            }
            onKeyDown_(ev) {
              const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              const c = this.value.rawValue;
              const [h, s, v, a] = c.getComponents("hsv");
              this.value.setRawValue(new Color2([h + step, s, v, a], "hsv"), {
                forceEmit: false,
                last: false
              });
            }
            onKeyUp_(ev) {
              const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
              if (step === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
          }
          const className$7 = ClassName("svp");
          const CANVAS_RESOL = 64;
          class SvPaletteView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.value = config3.value;
              this.value.emitter.on("change", this.onValueChange_);
              this.element = doc.createElement("div");
              this.element.classList.add(className$7());
              config3.viewProps.bindTabIndex(this.element);
              const canvasElem = doc.createElement("canvas");
              canvasElem.height = CANVAS_RESOL;
              canvasElem.width = CANVAS_RESOL;
              canvasElem.classList.add(className$7("c"));
              this.element.appendChild(canvasElem);
              this.canvasElement = canvasElem;
              const markerElem = doc.createElement("div");
              markerElem.classList.add(className$7("m"));
              this.element.appendChild(markerElem);
              this.markerElem_ = markerElem;
              this.update_();
            }
            update_() {
              const ctx = getCanvasContext(this.canvasElement);
              if (!ctx) {
                return;
              }
              const c = this.value.rawValue;
              const hsvComps = c.getComponents("hsv");
              const width = this.canvasElement.width;
              const height = this.canvasElement.height;
              const imgData = ctx.getImageData(0, 0, width, height);
              const data = imgData.data;
              for (let iy = 0; iy < height; iy++) {
                for (let ix = 0; ix < width; ix++) {
                  const s = mapRange3(ix, 0, width, 0, 100);
                  const v = mapRange3(iy, 0, height, 100, 0);
                  const rgbComps = hsvToRgb(hsvComps[0], s, v);
                  const i2 = (iy * width + ix) * 4;
                  data[i2] = rgbComps[0];
                  data[i2 + 1] = rgbComps[1];
                  data[i2 + 2] = rgbComps[2];
                  data[i2 + 3] = 255;
                }
              }
              ctx.putImageData(imgData, 0, 0);
              const left = mapRange3(hsvComps[1], 0, 100, 0, 100);
              this.markerElem_.style.left = `${left}%`;
              const top = mapRange3(hsvComps[2], 0, 100, 100, 0);
              this.markerElem_.style.top = `${top}%`;
            }
            onValueChange_() {
              this.update_();
            }
          }
          class SvPaletteController {
            constructor(doc, config3) {
              this.onKeyDown_ = this.onKeyDown_.bind(this);
              this.onKeyUp_ = this.onKeyUp_.bind(this);
              this.onPointerDown_ = this.onPointerDown_.bind(this);
              this.onPointerMove_ = this.onPointerMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new SvPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.ptHandler_ = new PointerHandler(this.view.element);
              this.ptHandler_.emitter.on("down", this.onPointerDown_);
              this.ptHandler_.emitter.on("move", this.onPointerMove_);
              this.ptHandler_.emitter.on("up", this.onPointerUp_);
              this.view.element.addEventListener("keydown", this.onKeyDown_);
              this.view.element.addEventListener("keyup", this.onKeyUp_);
            }
            handlePointerEvent_(d, opts) {
              if (!d.point) {
                return;
              }
              const saturation = mapRange3(d.point.x, 0, d.bounds.width, 0, 100);
              const value = mapRange3(d.point.y, 0, d.bounds.height, 100, 0);
              const [h, , , a] = this.value.rawValue.getComponents("hsv");
              this.value.setRawValue(new Color2([h, saturation, value, a], "hsv"), opts);
            }
            onPointerDown_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerMove_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerUp_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true
              });
            }
            onKeyDown_(ev) {
              if (isArrowKey(ev.key)) {
                ev.preventDefault();
              }
              const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
              const baseStep = getBaseStepForColor(false);
              const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
              const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
              if (ds === 0 && dv === 0) {
                return;
              }
              this.value.setRawValue(new Color2([h, s + ds, v + dv, a], "hsv"), {
                forceEmit: false,
                last: false
              });
            }
            onKeyUp_(ev) {
              const baseStep = getBaseStepForColor(false);
              const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
              const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
              if (ds === 0 && dv === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
          }
          class ColorPickerController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.hPaletteC_ = new HPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.svPaletteC_ = new SvPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              this.alphaIcs_ = config3.supportsAlpha ? {
                palette: new APaletteController(doc, {
                  value: this.value,
                  viewProps: this.viewProps
                }),
                text: new NumberTextController(doc, {
                  parser: parseNumber,
                  baseStep: 0.1,
                  props: ValueMap.fromObject({
                    draggingScale: 0.01,
                    formatter: createNumberFormatter(2)
                  }),
                  value: createValue(0, {
                    constraint: new RangeConstraint({ min: 0, max: 1 })
                  }),
                  viewProps: this.viewProps
                })
              } : null;
              if (this.alphaIcs_) {
                connectValues({
                  primary: this.value,
                  secondary: this.alphaIcs_.text.value,
                  forward: (p) => {
                    return p.rawValue.getComponents()[3];
                  },
                  backward: (p, s) => {
                    const comps = p.rawValue.getComponents();
                    comps[3] = s.rawValue;
                    return new Color2(comps, p.rawValue.mode);
                  }
                });
              }
              this.textC_ = new ColorTextController(doc, {
                parser: parseNumber,
                value: this.value,
                viewProps: this.viewProps
              });
              this.view = new ColorPickerView(doc, {
                alphaViews: this.alphaIcs_ ? {
                  palette: this.alphaIcs_.palette.view,
                  text: this.alphaIcs_.text.view
                } : null,
                hPaletteView: this.hPaletteC_.view,
                supportsAlpha: config3.supportsAlpha,
                svPaletteView: this.svPaletteC_.view,
                textView: this.textC_.view
              });
            }
            get textController() {
              return this.textC_;
            }
          }
          const className$6 = ClassName("colsw");
          class ColorSwatchView {
            constructor(doc, config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              config3.value.emitter.on("change", this.onValueChange_);
              this.value = config3.value;
              this.element = doc.createElement("div");
              this.element.classList.add(className$6());
              config3.viewProps.bindClassModifiers(this.element);
              const swatchElem = doc.createElement("div");
              swatchElem.classList.add(className$6("sw"));
              this.element.appendChild(swatchElem);
              this.swatchElem_ = swatchElem;
              const buttonElem = doc.createElement("button");
              buttonElem.classList.add(className$6("b"));
              config3.viewProps.bindDisabled(buttonElem);
              this.element.appendChild(buttonElem);
              this.buttonElement = buttonElem;
              this.update_();
            }
            update_() {
              const value = this.value.rawValue;
              this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
            }
            onValueChange_() {
              this.update_();
            }
          }
          class ColorSwatchController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new ColorSwatchView(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
            }
          }
          class ColorController {
            constructor(doc, config3) {
              this.onButtonBlur_ = this.onButtonBlur_.bind(this);
              this.onButtonClick_ = this.onButtonClick_.bind(this);
              this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
              this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.foldable_ = Foldable.create(config3.expanded);
              this.swatchC_ = new ColorSwatchController(doc, {
                value: this.value,
                viewProps: this.viewProps
              });
              const buttonElem = this.swatchC_.view.buttonElement;
              buttonElem.addEventListener("blur", this.onButtonBlur_);
              buttonElem.addEventListener("click", this.onButtonClick_);
              this.textC_ = new TextController(doc, {
                parser: config3.parser,
                props: ValueMap.fromObject({
                  formatter: config3.formatter
                }),
                value: this.value,
                viewProps: this.viewProps
              });
              this.view = new ColorView(doc, {
                foldable: this.foldable_,
                pickerLayout: config3.pickerLayout
              });
              this.view.swatchElement.appendChild(this.swatchC_.view.element);
              this.view.textElement.appendChild(this.textC_.view.element);
              this.popC_ = config3.pickerLayout === "popup" ? new PopupController(doc, {
                viewProps: this.viewProps
              }) : null;
              const pickerC = new ColorPickerController(doc, {
                supportsAlpha: config3.supportsAlpha,
                value: this.value,
                viewProps: this.viewProps
              });
              pickerC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener("blur", this.onPopupChildBlur_);
                elem.addEventListener("keydown", this.onPopupChildKeydown_);
              });
              this.pickerC_ = pickerC;
              if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(pickerC.view.element);
                connectValues({
                  primary: this.foldable_.value("expanded"),
                  secondary: this.popC_.shows,
                  forward: (p) => p.rawValue,
                  backward: (_, s) => s.rawValue
                });
              } else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
              }
            }
            get textController() {
              return this.textC_;
            }
            onButtonBlur_(e) {
              if (!this.popC_) {
                return;
              }
              const elem = this.view.element;
              const nextTarget = forceCast(e.relatedTarget);
              if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
              }
            }
            onButtonClick_() {
              this.foldable_.set("expanded", !this.foldable_.get("expanded"));
              if (this.foldable_.get("expanded")) {
                this.pickerC_.view.allFocusableElements[0].focus();
              }
            }
            onPopupChildBlur_(ev) {
              if (!this.popC_) {
                return;
              }
              const elem = this.popC_.view.element;
              const nextTarget = findNextTarget(ev);
              if (nextTarget && elem.contains(nextTarget)) {
                return;
              }
              if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
                return;
              }
              this.popC_.shows.rawValue = false;
            }
            onPopupChildKeydown_(ev) {
              if (this.popC_) {
                if (ev.key === "Escape") {
                  this.popC_.shows.rawValue = false;
                }
              } else if (this.view.pickerElement) {
                if (ev.key === "Escape") {
                  this.swatchC_.view.buttonElement.focus();
                }
              }
            }
          }
          function colorFromObject(value) {
            if (Color2.isColorObject(value)) {
              return Color2.fromObject(value);
            }
            return Color2.black();
          }
          function colorToRgbNumber(value) {
            return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
              return result << 8 | Math.floor(comp) & 255;
            }, 0);
          }
          function colorToRgbaNumber(value) {
            return value.getComponents("rgb").reduce((result, comp, index2) => {
              const hex = Math.floor(index2 === 3 ? comp * 255 : comp) & 255;
              return result << 8 | hex;
            }, 0) >>> 0;
          }
          function numberToRgbColor(num) {
            return new Color2([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
          }
          function numberToRgbaColor(num) {
            return new Color2([
              num >> 24 & 255,
              num >> 16 & 255,
              num >> 8 & 255,
              mapRange3(num & 255, 0, 255, 0, 1)
            ], "rgb");
          }
          function colorFromRgbNumber(value) {
            if (typeof value !== "number") {
              return Color2.black();
            }
            return numberToRgbColor(value);
          }
          function colorFromRgbaNumber(value) {
            if (typeof value !== "number") {
              return Color2.black();
            }
            return numberToRgbaColor(value);
          }
          function createColorStringWriter(notation) {
            const stringify = getColorStringifier(notation);
            return (target, value) => {
              writePrimitive(target, stringify(value));
            };
          }
          function createColorNumberWriter(supportsAlpha) {
            const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
            return (target, value) => {
              writePrimitive(target, colorToNumber(value));
            };
          }
          function writeRgbaColorObject(target, value) {
            const obj = value.toRgbaObject();
            target.writeProperty("r", obj.r);
            target.writeProperty("g", obj.g);
            target.writeProperty("b", obj.b);
            target.writeProperty("a", obj.a);
          }
          function writeRgbColorObject(target, value) {
            const obj = value.toRgbaObject();
            target.writeProperty("r", obj.r);
            target.writeProperty("g", obj.g);
            target.writeProperty("b", obj.b);
          }
          function createColorObjectWriter(supportsAlpha) {
            return supportsAlpha ? writeRgbaColorObject : writeRgbColorObject;
          }
          function shouldSupportAlpha$1(inputParams) {
            return "alpha" in inputParams && inputParams.alpha === true;
          }
          function createFormatter$1(supportsAlpha) {
            return supportsAlpha ? (v) => colorToHexRgbaString(v, "0x") : (v) => colorToHexRgbString(v, "0x");
          }
          const NumberColorInputPlugin = {
            id: "input-color-number",
            type: "input",
            accept: (value, params) => {
              if (typeof value !== "number") {
                return null;
              }
              if (!("view" in params)) {
                return null;
              }
              if (params.view !== "color") {
                return null;
              }
              const result = parseColorInputParams(params);
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (args) => {
                return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
              },
              equals: Color2.equals,
              writer: (args) => {
                return createColorNumberWriter(shouldSupportAlpha$1(args.params));
              }
            },
            controller: (args) => {
              const supportsAlpha = shouldSupportAlpha$1(args.params);
              const expanded = "expanded" in args.params ? args.params.expanded : void 0;
              const picker = "picker" in args.params ? args.params.picker : void 0;
              return new ColorController(args.document, {
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: createFormatter$1(supportsAlpha),
                parser: CompositeColorParser,
                pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
                supportsAlpha,
                value: args.value,
                viewProps: args.viewProps
              });
            }
          };
          function shouldSupportAlpha(initialValue) {
            return Color2.isRgbaColorObject(initialValue);
          }
          const ObjectColorInputPlugin = {
            id: "input-color-object",
            type: "input",
            accept: (value, params) => {
              if (!Color2.isColorObject(value)) {
                return null;
              }
              const result = parseColorInputParams(params);
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => colorFromObject,
              equals: Color2.equals,
              writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue))
            },
            controller: (args) => {
              const supportsAlpha = Color2.isRgbaColorObject(args.initialValue);
              const expanded = "expanded" in args.params ? args.params.expanded : void 0;
              const picker = "picker" in args.params ? args.params.picker : void 0;
              const formatter = supportsAlpha ? colorToHexRgbaString : colorToHexRgbString;
              return new ColorController(args.document, {
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter,
                parser: CompositeColorParser,
                pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
                supportsAlpha,
                value: args.value,
                viewProps: args.viewProps
              });
            }
          };
          const StringColorInputPlugin = {
            id: "input-color-string",
            type: "input",
            accept: (value, params) => {
              if (typeof value !== "string") {
                return null;
              }
              if ("view" in params && params.view === "text") {
                return null;
              }
              const notation = getColorNotation(value);
              if (!notation) {
                return null;
              }
              const result = parseColorInputParams(params);
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => colorFromString,
              equals: Color2.equals,
              writer: (args) => {
                const notation = getColorNotation(args.initialValue);
                if (!notation) {
                  throw TpError.shouldNeverHappen();
                }
                return createColorStringWriter(notation);
              }
            },
            controller: (args) => {
              const notation = getColorNotation(args.initialValue);
              if (!notation) {
                throw TpError.shouldNeverHappen();
              }
              const stringifier = getColorStringifier(notation);
              const expanded = "expanded" in args.params ? args.params.expanded : void 0;
              const picker = "picker" in args.params ? args.params.picker : void 0;
              return new ColorController(args.document, {
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: stringifier,
                parser: CompositeColorParser,
                pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
                supportsAlpha: hasAlphaComponent(notation),
                value: args.value,
                viewProps: args.viewProps
              });
            }
          };
          class PointNdConstraint {
            constructor(config3) {
              this.components = config3.components;
              this.asm_ = config3.assembly;
            }
            constrain(value) {
              const comps = this.asm_.toComponents(value).map((comp, index2) => {
                var _a, _b;
                return (_b = (_a = this.components[index2]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
              });
              return this.asm_.fromComponents(comps);
            }
          }
          const className$5 = ClassName("pndtxt");
          class PointNdTextView {
            constructor(doc, config3) {
              this.textViews = config3.textViews;
              this.element = doc.createElement("div");
              this.element.classList.add(className$5());
              this.textViews.forEach((v) => {
                const axisElem = doc.createElement("div");
                axisElem.classList.add(className$5("a"));
                axisElem.appendChild(v.element);
                this.element.appendChild(axisElem);
              });
            }
          }
          function createAxisController(doc, config3, index2) {
            return new NumberTextController(doc, {
              arrayPosition: index2 === 0 ? "fst" : index2 === config3.axes.length - 1 ? "lst" : "mid",
              baseStep: config3.axes[index2].baseStep,
              parser: config3.parser,
              props: config3.axes[index2].textProps,
              value: createValue(0, {
                constraint: config3.axes[index2].constraint
              }),
              viewProps: config3.viewProps
            });
          }
          class PointNdTextController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.acs_ = config3.axes.map((_, index2) => createAxisController(doc, config3, index2));
              this.acs_.forEach((c, index2) => {
                connectValues({
                  primary: this.value,
                  secondary: c.value,
                  forward: (p) => {
                    return config3.assembly.toComponents(p.rawValue)[index2];
                  },
                  backward: (p, s) => {
                    const comps = config3.assembly.toComponents(p.rawValue);
                    comps[index2] = s.rawValue;
                    return config3.assembly.fromComponents(comps);
                  }
                });
              });
              this.view = new PointNdTextView(doc, {
                textViews: this.acs_.map((ac) => ac.view)
              });
            }
          }
          function createStepConstraint(params) {
            if ("step" in params && !isEmpty(params.step)) {
              return new StepConstraint(params.step);
            }
            return null;
          }
          function createRangeConstraint(params) {
            if ("max" in params && !isEmpty(params.max) || "min" in params && !isEmpty(params.min)) {
              return new RangeConstraint({
                max: params.max,
                min: params.min
              });
            }
            return null;
          }
          function createConstraint$4(params) {
            const constraints = [];
            const sc = createStepConstraint(params);
            if (sc) {
              constraints.push(sc);
            }
            const rc = createRangeConstraint(params);
            if (rc) {
              constraints.push(rc);
            }
            const lc = createListConstraint(params.options);
            if (lc) {
              constraints.push(lc);
            }
            return new CompositeConstraint(constraints);
          }
          function findRange(constraint) {
            const c = constraint ? findConstraint(constraint, RangeConstraint) : null;
            if (!c) {
              return [void 0, void 0];
            }
            return [c.minValue, c.maxValue];
          }
          function estimateSuitableRange(constraint) {
            const [min, max] = findRange(constraint);
            return [min !== null && min !== void 0 ? min : 0, max !== null && max !== void 0 ? max : 100];
          }
          const NumberInputPlugin = {
            id: "input-number",
            type: "input",
            accept: (value, params) => {
              if (typeof value !== "number") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                format: p.optional.function,
                max: p.optional.number,
                min: p.optional.number,
                options: p.optional.custom(parseListOptions),
                step: p.optional.number
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => numberFromUnknown,
              constraint: (args) => createConstraint$4(args.params),
              writer: (_args) => writePrimitive
            },
            controller: (args) => {
              var _a, _b;
              const value = args.value;
              const c = args.constraint;
              if (c && findConstraint(c, ListConstraint)) {
                return new ListController(args.document, {
                  props: ValueMap.fromObject({
                    options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                  }),
                  value,
                  viewProps: args.viewProps
                });
              }
              const formatter = (_b = "format" in args.params ? args.params.format : void 0) !== null && _b !== void 0 ? _b : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
              if (c && findConstraint(c, RangeConstraint)) {
                const [min, max] = estimateSuitableRange(c);
                return new SliderTextController(args.document, {
                  baseStep: getBaseStep(c),
                  parser: parseNumber,
                  sliderProps: ValueMap.fromObject({
                    maxValue: max,
                    minValue: min
                  }),
                  textProps: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(c, value.rawValue),
                    formatter
                  }),
                  value,
                  viewProps: args.viewProps
                });
              }
              return new NumberTextController(args.document, {
                baseStep: getBaseStep(c),
                parser: parseNumber,
                props: ValueMap.fromObject({
                  draggingScale: getSuitableDraggingScale(c, value.rawValue),
                  formatter
                }),
                value,
                viewProps: args.viewProps
              });
            }
          };
          class Point2d {
            constructor(x = 0, y = 0) {
              this.x = x;
              this.y = y;
            }
            getComponents() {
              return [this.x, this.y];
            }
            static isObject(obj) {
              if (isEmpty(obj)) {
                return false;
              }
              const x = obj.x;
              const y = obj.y;
              if (typeof x !== "number" || typeof y !== "number") {
                return false;
              }
              return true;
            }
            static equals(v1, v2) {
              return v1.x === v2.x && v1.y === v2.y;
            }
            toObject() {
              return {
                x: this.x,
                y: this.y
              };
            }
          }
          const Point2dAssembly = {
            toComponents: (p) => p.getComponents(),
            fromComponents: (comps) => new Point2d(...comps)
          };
          const className$4 = ClassName("p2d");
          class Point2dView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className$4());
              config3.viewProps.bindClassModifiers(this.element);
              bindValue(config3.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
              const headElem = doc.createElement("div");
              headElem.classList.add(className$4("h"));
              this.element.appendChild(headElem);
              const buttonElem = doc.createElement("button");
              buttonElem.classList.add(className$4("b"));
              buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
              config3.viewProps.bindDisabled(buttonElem);
              headElem.appendChild(buttonElem);
              this.buttonElement = buttonElem;
              const textElem = doc.createElement("div");
              textElem.classList.add(className$4("t"));
              headElem.appendChild(textElem);
              this.textElement = textElem;
              if (config3.pickerLayout === "inline") {
                const pickerElem = doc.createElement("div");
                pickerElem.classList.add(className$4("p"));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
              } else {
                this.pickerElement = null;
              }
            }
          }
          const className$3 = ClassName("p2dp");
          class Point2dPickerView {
            constructor(doc, config3) {
              this.onFoldableChange_ = this.onFoldableChange_.bind(this);
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.invertsY_ = config3.invertsY;
              this.maxValue_ = config3.maxValue;
              this.element = doc.createElement("div");
              this.element.classList.add(className$3());
              if (config3.layout === "popup") {
                this.element.classList.add(className$3(void 0, "p"));
              }
              const padElem = doc.createElement("div");
              padElem.classList.add(className$3("p"));
              config3.viewProps.bindTabIndex(padElem);
              this.element.appendChild(padElem);
              this.padElement = padElem;
              const svgElem = doc.createElementNS(SVG_NS, "svg");
              svgElem.classList.add(className$3("g"));
              this.padElement.appendChild(svgElem);
              this.svgElem_ = svgElem;
              const xAxisElem = doc.createElementNS(SVG_NS, "line");
              xAxisElem.classList.add(className$3("ax"));
              xAxisElem.setAttributeNS(null, "x1", "0");
              xAxisElem.setAttributeNS(null, "y1", "50%");
              xAxisElem.setAttributeNS(null, "x2", "100%");
              xAxisElem.setAttributeNS(null, "y2", "50%");
              this.svgElem_.appendChild(xAxisElem);
              const yAxisElem = doc.createElementNS(SVG_NS, "line");
              yAxisElem.classList.add(className$3("ax"));
              yAxisElem.setAttributeNS(null, "x1", "50%");
              yAxisElem.setAttributeNS(null, "y1", "0");
              yAxisElem.setAttributeNS(null, "x2", "50%");
              yAxisElem.setAttributeNS(null, "y2", "100%");
              this.svgElem_.appendChild(yAxisElem);
              const lineElem = doc.createElementNS(SVG_NS, "line");
              lineElem.classList.add(className$3("l"));
              lineElem.setAttributeNS(null, "x1", "50%");
              lineElem.setAttributeNS(null, "y1", "50%");
              this.svgElem_.appendChild(lineElem);
              this.lineElem_ = lineElem;
              const markerElem = doc.createElement("div");
              markerElem.classList.add(className$3("m"));
              this.padElement.appendChild(markerElem);
              this.markerElem_ = markerElem;
              config3.value.emitter.on("change", this.onValueChange_);
              this.value = config3.value;
              this.update_();
            }
            get allFocusableElements() {
              return [this.padElement];
            }
            update_() {
              const [x, y] = this.value.rawValue.getComponents();
              const max = this.maxValue_;
              const px2 = mapRange3(x, -max, +max, 0, 100);
              const py2 = mapRange3(y, -max, +max, 0, 100);
              const ipy = this.invertsY_ ? 100 - py2 : py2;
              this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
              this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
              this.markerElem_.style.left = `${px2}%`;
              this.markerElem_.style.top = `${ipy}%`;
            }
            onValueChange_() {
              this.update_();
            }
            onFoldableChange_() {
              this.update_();
            }
          }
          function computeOffset(ev, baseSteps, invertsY) {
            return [
              getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
              getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
            ];
          }
          class Point2dPickerController {
            constructor(doc, config3) {
              this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
              this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
              this.onPointerDown_ = this.onPointerDown_.bind(this);
              this.onPointerMove_ = this.onPointerMove_.bind(this);
              this.onPointerUp_ = this.onPointerUp_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.baseSteps_ = config3.baseSteps;
              this.maxValue_ = config3.maxValue;
              this.invertsY_ = config3.invertsY;
              this.view = new Point2dPickerView(doc, {
                invertsY: this.invertsY_,
                layout: config3.layout,
                maxValue: this.maxValue_,
                value: this.value,
                viewProps: this.viewProps
              });
              this.ptHandler_ = new PointerHandler(this.view.padElement);
              this.ptHandler_.emitter.on("down", this.onPointerDown_);
              this.ptHandler_.emitter.on("move", this.onPointerMove_);
              this.ptHandler_.emitter.on("up", this.onPointerUp_);
              this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
              this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
            }
            handlePointerEvent_(d, opts) {
              if (!d.point) {
                return;
              }
              const max = this.maxValue_;
              const px2 = mapRange3(d.point.x, 0, d.bounds.width, -max, +max);
              const py2 = mapRange3(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
              this.value.setRawValue(new Point2d(px2, py2), opts);
            }
            onPointerDown_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerMove_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false
              });
            }
            onPointerUp_(ev) {
              this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true
              });
            }
            onPadKeyDown_(ev) {
              if (isArrowKey(ev.key)) {
                ev.preventDefault();
              }
              const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
              if (dx === 0 && dy === 0) {
                return;
              }
              this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
                forceEmit: false,
                last: false
              });
            }
            onPadKeyUp_(ev) {
              const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
              if (dx === 0 && dy === 0) {
                return;
              }
              this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true
              });
            }
          }
          class Point2dController {
            constructor(doc, config3) {
              var _a, _b;
              this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
              this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
              this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
              this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.foldable_ = Foldable.create(config3.expanded);
              this.popC_ = config3.pickerLayout === "popup" ? new PopupController(doc, {
                viewProps: this.viewProps
              }) : null;
              const padC = new Point2dPickerController(doc, {
                baseSteps: [config3.axes[0].baseStep, config3.axes[1].baseStep],
                invertsY: config3.invertsY,
                layout: config3.pickerLayout,
                maxValue: config3.maxValue,
                value: this.value,
                viewProps: this.viewProps
              });
              padC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener("blur", this.onPopupChildBlur_);
                elem.addEventListener("keydown", this.onPopupChildKeydown_);
              });
              this.pickerC_ = padC;
              this.textC_ = new PointNdTextController(doc, {
                assembly: Point2dAssembly,
                axes: config3.axes,
                parser: config3.parser,
                value: this.value,
                viewProps: this.viewProps
              });
              this.view = new Point2dView(doc, {
                expanded: this.foldable_.value("expanded"),
                pickerLayout: config3.pickerLayout,
                viewProps: this.viewProps
              });
              this.view.textElement.appendChild(this.textC_.view.element);
              (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener("blur", this.onPadButtonBlur_);
              (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.onPadButtonClick_);
              if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(this.pickerC_.view.element);
                connectValues({
                  primary: this.foldable_.value("expanded"),
                  secondary: this.popC_.shows,
                  forward: (p) => p.rawValue,
                  backward: (_, s) => s.rawValue
                });
              } else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
              }
            }
            onPadButtonBlur_(e) {
              if (!this.popC_) {
                return;
              }
              const elem = this.view.element;
              const nextTarget = forceCast(e.relatedTarget);
              if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
              }
            }
            onPadButtonClick_() {
              this.foldable_.set("expanded", !this.foldable_.get("expanded"));
              if (this.foldable_.get("expanded")) {
                this.pickerC_.view.allFocusableElements[0].focus();
              }
            }
            onPopupChildBlur_(ev) {
              if (!this.popC_) {
                return;
              }
              const elem = this.popC_.view.element;
              const nextTarget = findNextTarget(ev);
              if (nextTarget && elem.contains(nextTarget)) {
                return;
              }
              if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
                return;
              }
              this.popC_.shows.rawValue = false;
            }
            onPopupChildKeydown_(ev) {
              if (this.popC_) {
                if (ev.key === "Escape") {
                  this.popC_.shows.rawValue = false;
                }
              } else if (this.view.pickerElement) {
                if (ev.key === "Escape") {
                  this.view.buttonElement.focus();
                }
              }
            }
          }
          function point2dFromUnknown(value) {
            return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
          }
          function writePoint2d(target, value) {
            target.writeProperty("x", value.x);
            target.writeProperty("y", value.y);
          }
          function createDimensionConstraint$2(params) {
            if (!params) {
              return void 0;
            }
            const constraints = [];
            if (!isEmpty(params.step)) {
              constraints.push(new StepConstraint(params.step));
            }
            if (!isEmpty(params.max) || !isEmpty(params.min)) {
              constraints.push(new RangeConstraint({
                max: params.max,
                min: params.min
              }));
            }
            return new CompositeConstraint(constraints);
          }
          function createConstraint$3(params) {
            return new PointNdConstraint({
              assembly: Point2dAssembly,
              components: [
                createDimensionConstraint$2("x" in params ? params.x : void 0),
                createDimensionConstraint$2("y" in params ? params.y : void 0)
              ]
            });
          }
          function getSuitableMaxDimensionValue(constraint, rawValue) {
            const rc = constraint && findConstraint(constraint, RangeConstraint);
            if (rc) {
              return Math.max(Math.abs(rc.minValue || 0), Math.abs(rc.maxValue || 0));
            }
            const step = getBaseStep(constraint);
            return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
          }
          function getSuitableMaxValue(initialValue, constraint) {
            const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
            const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
            const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
            const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
            return Math.max(xr, yr);
          }
          function createAxis$2(initialValue, constraint) {
            return {
              baseStep: getBaseStep(constraint),
              constraint,
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
              })
            };
          }
          function shouldInvertY(params) {
            if (!("y" in params)) {
              return false;
            }
            const yParams = params.y;
            if (!yParams) {
              return false;
            }
            return "inverted" in yParams ? !!yParams.inverted : false;
          }
          const Point2dInputPlugin = {
            id: "input-point2d",
            type: "input",
            accept: (value, params) => {
              if (!Point2d.isObject(value)) {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                expanded: p.optional.boolean,
                picker: p.optional.custom(parsePickerLayout),
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.object({
                  inverted: p.optional.boolean,
                  max: p.optional.number,
                  min: p.optional.number,
                  step: p.optional.number
                })
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => point2dFromUnknown,
              constraint: (args) => createConstraint$3(args.params),
              equals: Point2d.equals,
              writer: (_args) => writePoint2d
            },
            controller: (args) => {
              const doc = args.document;
              const value = args.value;
              const c = args.constraint;
              if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
              }
              const expanded = "expanded" in args.params ? args.params.expanded : void 0;
              const picker = "picker" in args.params ? args.params.picker : void 0;
              return new Point2dController(doc, {
                axes: [
                  createAxis$2(value.rawValue.x, c.components[0]),
                  createAxis$2(value.rawValue.y, c.components[1])
                ],
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                invertsY: shouldInvertY(args.params),
                maxValue: getSuitableMaxValue(value.rawValue, c),
                parser: parseNumber,
                pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
                value,
                viewProps: args.viewProps
              });
            }
          };
          class Point3d {
            constructor(x = 0, y = 0, z = 0) {
              this.x = x;
              this.y = y;
              this.z = z;
            }
            getComponents() {
              return [this.x, this.y, this.z];
            }
            static isObject(obj) {
              if (isEmpty(obj)) {
                return false;
              }
              const x = obj.x;
              const y = obj.y;
              const z = obj.z;
              if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number") {
                return false;
              }
              return true;
            }
            static equals(v1, v2) {
              return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
            }
            toObject() {
              return {
                x: this.x,
                y: this.y,
                z: this.z
              };
            }
          }
          const Point3dAssembly = {
            toComponents: (p) => p.getComponents(),
            fromComponents: (comps) => new Point3d(...comps)
          };
          function point3dFromUnknown(value) {
            return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
          }
          function writePoint3d(target, value) {
            target.writeProperty("x", value.x);
            target.writeProperty("y", value.y);
            target.writeProperty("z", value.z);
          }
          function createDimensionConstraint$1(params) {
            if (!params) {
              return void 0;
            }
            const constraints = [];
            if (!isEmpty(params.step)) {
              constraints.push(new StepConstraint(params.step));
            }
            if (!isEmpty(params.max) || !isEmpty(params.min)) {
              constraints.push(new RangeConstraint({
                max: params.max,
                min: params.min
              }));
            }
            return new CompositeConstraint(constraints);
          }
          function createConstraint$2(params) {
            return new PointNdConstraint({
              assembly: Point3dAssembly,
              components: [
                createDimensionConstraint$1("x" in params ? params.x : void 0),
                createDimensionConstraint$1("y" in params ? params.y : void 0),
                createDimensionConstraint$1("z" in params ? params.z : void 0)
              ]
            });
          }
          function createAxis$1(initialValue, constraint) {
            return {
              baseStep: getBaseStep(constraint),
              constraint,
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
              })
            };
          }
          const Point3dInputPlugin = {
            id: "input-point3d",
            type: "input",
            accept: (value, params) => {
              if (!Point3d.isObject(value)) {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams)
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => point3dFromUnknown,
              constraint: (args) => createConstraint$2(args.params),
              equals: Point3d.equals,
              writer: (_args) => writePoint3d
            },
            controller: (args) => {
              const value = args.value;
              const c = args.constraint;
              if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
              }
              return new PointNdTextController(args.document, {
                assembly: Point3dAssembly,
                axes: [
                  createAxis$1(value.rawValue.x, c.components[0]),
                  createAxis$1(value.rawValue.y, c.components[1]),
                  createAxis$1(value.rawValue.z, c.components[2])
                ],
                parser: parseNumber,
                value,
                viewProps: args.viewProps
              });
            }
          };
          class Point4d {
            constructor(x = 0, y = 0, z = 0, w = 0) {
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
            }
            getComponents() {
              return [this.x, this.y, this.z, this.w];
            }
            static isObject(obj) {
              if (isEmpty(obj)) {
                return false;
              }
              const x = obj.x;
              const y = obj.y;
              const z = obj.z;
              const w = obj.w;
              if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number" || typeof w !== "number") {
                return false;
              }
              return true;
            }
            static equals(v1, v2) {
              return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
            }
            toObject() {
              return {
                x: this.x,
                y: this.y,
                z: this.z,
                w: this.w
              };
            }
          }
          const Point4dAssembly = {
            toComponents: (p) => p.getComponents(),
            fromComponents: (comps) => new Point4d(...comps)
          };
          function point4dFromUnknown(value) {
            return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
          }
          function writePoint4d(target, value) {
            target.writeProperty("x", value.x);
            target.writeProperty("y", value.y);
            target.writeProperty("z", value.z);
            target.writeProperty("w", value.w);
          }
          function createDimensionConstraint(params) {
            if (!params) {
              return void 0;
            }
            const constraints = [];
            if (!isEmpty(params.step)) {
              constraints.push(new StepConstraint(params.step));
            }
            if (!isEmpty(params.max) || !isEmpty(params.min)) {
              constraints.push(new RangeConstraint({
                max: params.max,
                min: params.min
              }));
            }
            return new CompositeConstraint(constraints);
          }
          function createConstraint$1(params) {
            return new PointNdConstraint({
              assembly: Point4dAssembly,
              components: [
                createDimensionConstraint("x" in params ? params.x : void 0),
                createDimensionConstraint("y" in params ? params.y : void 0),
                createDimensionConstraint("z" in params ? params.z : void 0),
                createDimensionConstraint("w" in params ? params.w : void 0)
              ]
            });
          }
          function createAxis(initialValue, constraint) {
            return {
              baseStep: getBaseStep(constraint),
              constraint,
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
              })
            };
          }
          const Point4dInputPlugin = {
            id: "input-point4d",
            type: "input",
            accept: (value, params) => {
              if (!Point4d.isObject(value)) {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
                w: p.optional.custom(parsePointDimensionParams)
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => point4dFromUnknown,
              constraint: (args) => createConstraint$1(args.params),
              equals: Point4d.equals,
              writer: (_args) => writePoint4d
            },
            controller: (args) => {
              const value = args.value;
              const c = args.constraint;
              if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
              }
              return new PointNdTextController(args.document, {
                assembly: Point4dAssembly,
                axes: value.rawValue.getComponents().map((comp, index2) => createAxis(comp, c.components[index2])),
                parser: parseNumber,
                value,
                viewProps: args.viewProps
              });
            }
          };
          function createConstraint(params) {
            const constraints = [];
            const lc = createListConstraint(params.options);
            if (lc) {
              constraints.push(lc);
            }
            return new CompositeConstraint(constraints);
          }
          const StringInputPlugin = {
            id: "input-string",
            type: "input",
            accept: (value, params) => {
              if (typeof value !== "string") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                options: p.optional.custom(parseListOptions)
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => stringFromUnknown,
              constraint: (args) => createConstraint(args.params),
              writer: (_args) => writePrimitive
            },
            controller: (args) => {
              var _a;
              const doc = args.document;
              const value = args.value;
              const c = args.constraint;
              if (c && findConstraint(c, ListConstraint)) {
                return new ListController(doc, {
                  props: ValueMap.fromObject({
                    options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                  }),
                  value,
                  viewProps: args.viewProps
                });
              }
              return new TextController(doc, {
                parser: (v) => v,
                props: ValueMap.fromObject({
                  formatter: formatString
                }),
                value,
                viewProps: args.viewProps
              });
            }
          };
          const Constants = {
            monitor: {
              defaultInterval: 200,
              defaultLineCount: 3
            }
          };
          const className$2 = ClassName("mll");
          class MultiLogView {
            constructor(doc, config3) {
              this.onValueUpdate_ = this.onValueUpdate_.bind(this);
              this.formatter_ = config3.formatter;
              this.element = doc.createElement("div");
              this.element.classList.add(className$2());
              config3.viewProps.bindClassModifiers(this.element);
              const textareaElem = doc.createElement("textarea");
              textareaElem.classList.add(className$2("i"));
              textareaElem.style.height = `calc(var(--bld-us) * ${config3.lineCount})`;
              textareaElem.readOnly = true;
              config3.viewProps.bindDisabled(textareaElem);
              this.element.appendChild(textareaElem);
              this.textareaElem_ = textareaElem;
              config3.value.emitter.on("change", this.onValueUpdate_);
              this.value = config3.value;
              this.update_();
            }
            update_() {
              const elem = this.textareaElem_;
              const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
              const lines = [];
              this.value.rawValue.forEach((value) => {
                if (value !== void 0) {
                  lines.push(this.formatter_(value));
                }
              });
              elem.textContent = lines.join("\n");
              if (shouldScroll) {
                elem.scrollTop = elem.scrollHeight;
              }
            }
            onValueUpdate_() {
              this.update_();
            }
          }
          class MultiLogController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new MultiLogView(doc, {
                formatter: config3.formatter,
                lineCount: config3.lineCount,
                value: this.value,
                viewProps: this.viewProps
              });
            }
          }
          const className$1 = ClassName("sgl");
          class SingleLogView {
            constructor(doc, config3) {
              this.onValueUpdate_ = this.onValueUpdate_.bind(this);
              this.formatter_ = config3.formatter;
              this.element = doc.createElement("div");
              this.element.classList.add(className$1());
              config3.viewProps.bindClassModifiers(this.element);
              const inputElem = doc.createElement("input");
              inputElem.classList.add(className$1("i"));
              inputElem.readOnly = true;
              inputElem.type = "text";
              config3.viewProps.bindDisabled(inputElem);
              this.element.appendChild(inputElem);
              this.inputElement = inputElem;
              config3.value.emitter.on("change", this.onValueUpdate_);
              this.value = config3.value;
              this.update_();
            }
            update_() {
              const values = this.value.rawValue;
              const lastValue = values[values.length - 1];
              this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
            }
            onValueUpdate_() {
              this.update_();
            }
          }
          class SingleLogController {
            constructor(doc, config3) {
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new SingleLogView(doc, {
                formatter: config3.formatter,
                value: this.value,
                viewProps: this.viewProps
              });
            }
          }
          const BooleanMonitorPlugin = {
            id: "monitor-bool",
            type: "monitor",
            accept: (value, params) => {
              if (typeof value !== "boolean") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                lineCount: p.optional.number
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => boolFromUnknown
            },
            controller: (args) => {
              var _a;
              if (args.value.rawValue.length === 1) {
                return new SingleLogController(args.document, {
                  formatter: BooleanFormatter,
                  value: args.value,
                  viewProps: args.viewProps
                });
              }
              return new MultiLogController(args.document, {
                formatter: BooleanFormatter,
                lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                value: args.value,
                viewProps: args.viewProps
              });
            }
          };
          class GraphCursor {
            constructor() {
              this.emitter = new Emitter();
              this.index_ = -1;
            }
            get index() {
              return this.index_;
            }
            set index(index2) {
              const changed = this.index_ !== index2;
              if (changed) {
                this.index_ = index2;
                this.emitter.emit("change", {
                  index: index2,
                  sender: this
                });
              }
            }
          }
          const className = ClassName("grl");
          class GraphLogView {
            constructor(doc, config3) {
              this.onCursorChange_ = this.onCursorChange_.bind(this);
              this.onValueUpdate_ = this.onValueUpdate_.bind(this);
              this.element = doc.createElement("div");
              this.element.classList.add(className());
              config3.viewProps.bindClassModifiers(this.element);
              this.formatter_ = config3.formatter;
              this.minValue_ = config3.minValue;
              this.maxValue_ = config3.maxValue;
              this.cursor_ = config3.cursor;
              this.cursor_.emitter.on("change", this.onCursorChange_);
              const svgElem = doc.createElementNS(SVG_NS, "svg");
              svgElem.classList.add(className("g"));
              svgElem.style.height = `calc(var(--bld-us) * ${config3.lineCount})`;
              this.element.appendChild(svgElem);
              this.svgElem_ = svgElem;
              const lineElem = doc.createElementNS(SVG_NS, "polyline");
              this.svgElem_.appendChild(lineElem);
              this.lineElem_ = lineElem;
              const tooltipElem = doc.createElement("div");
              tooltipElem.classList.add(className("t"), ClassName("tt")());
              this.element.appendChild(tooltipElem);
              this.tooltipElem_ = tooltipElem;
              config3.value.emitter.on("change", this.onValueUpdate_);
              this.value = config3.value;
              this.update_();
            }
            get graphElement() {
              return this.svgElem_;
            }
            update_() {
              const bounds = this.svgElem_.getBoundingClientRect();
              const maxIndex = this.value.rawValue.length - 1;
              const min = this.minValue_;
              const max = this.maxValue_;
              const points = [];
              this.value.rawValue.forEach((v, index2) => {
                if (v === void 0) {
                  return;
                }
                const x = mapRange3(index2, 0, maxIndex, 0, bounds.width);
                const y = mapRange3(v, min, max, bounds.height, 0);
                points.push([x, y].join(","));
              });
              this.lineElem_.setAttributeNS(null, "points", points.join(" "));
              const tooltipElem = this.tooltipElem_;
              const value = this.value.rawValue[this.cursor_.index];
              if (value === void 0) {
                tooltipElem.classList.remove(className("t", "a"));
                return;
              }
              const tx = mapRange3(this.cursor_.index, 0, maxIndex, 0, bounds.width);
              const ty = mapRange3(value, min, max, bounds.height, 0);
              tooltipElem.style.left = `${tx}px`;
              tooltipElem.style.top = `${ty}px`;
              tooltipElem.textContent = `${this.formatter_(value)}`;
              if (!tooltipElem.classList.contains(className("t", "a"))) {
                tooltipElem.classList.add(className("t", "a"), className("t", "in"));
                forceReflow(tooltipElem);
                tooltipElem.classList.remove(className("t", "in"));
              }
            }
            onValueUpdate_() {
              this.update_();
            }
            onCursorChange_() {
              this.update_();
            }
          }
          class GraphLogController {
            constructor(doc, config3) {
              this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
              this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
              this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
              this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
              this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.cursor_ = new GraphCursor();
              this.view = new GraphLogView(doc, {
                cursor: this.cursor_,
                formatter: config3.formatter,
                lineCount: config3.lineCount,
                maxValue: config3.maxValue,
                minValue: config3.minValue,
                value: this.value,
                viewProps: this.viewProps
              });
              if (!supportsTouch(doc)) {
                this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
                this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
              } else {
                const ph = new PointerHandler(this.view.element);
                ph.emitter.on("down", this.onGraphPointerDown_);
                ph.emitter.on("move", this.onGraphPointerMove_);
                ph.emitter.on("up", this.onGraphPointerUp_);
              }
            }
            onGraphMouseLeave_() {
              this.cursor_.index = -1;
            }
            onGraphMouseMove_(ev) {
              const bounds = this.view.element.getBoundingClientRect();
              this.cursor_.index = Math.floor(mapRange3(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
            }
            onGraphPointerDown_(ev) {
              this.onGraphPointerMove_(ev);
            }
            onGraphPointerMove_(ev) {
              if (!ev.data.point) {
                this.cursor_.index = -1;
                return;
              }
              this.cursor_.index = Math.floor(mapRange3(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
            }
            onGraphPointerUp_() {
              this.cursor_.index = -1;
            }
          }
          function createFormatter(params) {
            return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
          }
          function createTextMonitor(args) {
            var _a;
            if (args.value.rawValue.length === 1) {
              return new SingleLogController(args.document, {
                formatter: createFormatter(args.params),
                value: args.value,
                viewProps: args.viewProps
              });
            }
            return new MultiLogController(args.document, {
              formatter: createFormatter(args.params),
              lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
              value: args.value,
              viewProps: args.viewProps
            });
          }
          function createGraphMonitor(args) {
            var _a, _b, _c;
            return new GraphLogController(args.document, {
              formatter: createFormatter(args.params),
              lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
              maxValue: (_b = "max" in args.params ? args.params.max : null) !== null && _b !== void 0 ? _b : 100,
              minValue: (_c = "min" in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0,
              value: args.value,
              viewProps: args.viewProps
            });
          }
          function shouldShowGraph(params) {
            return "view" in params && params.view === "graph";
          }
          const NumberMonitorPlugin = {
            id: "monitor-number",
            type: "monitor",
            accept: (value, params) => {
              if (typeof value !== "number") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                format: p.optional.function,
                lineCount: p.optional.number,
                max: p.optional.number,
                min: p.optional.number,
                view: p.optional.string
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
              reader: (_args) => numberFromUnknown
            },
            controller: (args) => {
              if (shouldShowGraph(args.params)) {
                return createGraphMonitor(args);
              }
              return createTextMonitor(args);
            }
          };
          const StringMonitorPlugin = {
            id: "monitor-string",
            type: "monitor",
            accept: (value, params) => {
              if (typeof value !== "string") {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                lineCount: p.optional.number,
                multiline: p.optional.boolean
              });
              return result ? {
                initialValue: value,
                params: result
              } : null;
            },
            binding: {
              reader: (_args) => stringFromUnknown
            },
            controller: (args) => {
              var _a;
              const value = args.value;
              const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
              if (multiline) {
                return new MultiLogController(args.document, {
                  formatter: formatString,
                  lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                  value,
                  viewProps: args.viewProps
                });
              }
              return new SingleLogController(args.document, {
                formatter: formatString,
                value,
                viewProps: args.viewProps
              });
            }
          };
          class InputBinding {
            constructor(config3) {
              this.onValueChange_ = this.onValueChange_.bind(this);
              this.reader = config3.reader;
              this.writer = config3.writer;
              this.emitter = new Emitter();
              this.value = config3.value;
              this.value.emitter.on("change", this.onValueChange_);
              this.target = config3.target;
              this.read();
            }
            read() {
              const targetValue = this.target.read();
              if (targetValue !== void 0) {
                this.value.rawValue = this.reader(targetValue);
              }
            }
            write_(rawValue) {
              this.writer(this.target, rawValue);
            }
            onValueChange_(ev) {
              this.write_(ev.rawValue);
              this.emitter.emit("change", {
                options: ev.options,
                rawValue: ev.rawValue,
                sender: this
              });
            }
          }
          function createInputBindingController(plugin, args) {
            const result = plugin.accept(args.target.read(), args.params);
            if (isEmpty(result)) {
              return null;
            }
            const p = ParamsParsers;
            const valueArgs = {
              target: args.target,
              initialValue: result.initialValue,
              params: result.params
            };
            const reader = plugin.binding.reader(valueArgs);
            const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
            const value = createValue(reader(result.initialValue), {
              constraint,
              equals: plugin.binding.equals
            });
            const binding = new InputBinding({
              reader,
              target: args.target,
              value,
              writer: plugin.binding.writer(valueArgs)
            });
            const disabled = p.optional.boolean(args.params.disabled).value;
            const hidden = p.optional.boolean(args.params.hidden).value;
            const controller = plugin.controller({
              constraint,
              document: args.document,
              initialValue: result.initialValue,
              params: result.params,
              value: binding.value,
              viewProps: ViewProps.create({
                disabled,
                hidden
              })
            });
            const label = p.optional.string(args.params.label).value;
            return new InputBindingController(args.document, {
              binding,
              blade: createBlade(),
              props: ValueMap.fromObject({
                label: label || args.target.key
              }),
              valueController: controller
            });
          }
          class MonitorBinding {
            constructor(config3) {
              this.onTick_ = this.onTick_.bind(this);
              this.reader_ = config3.reader;
              this.target = config3.target;
              this.emitter = new Emitter();
              this.value = config3.value;
              this.ticker = config3.ticker;
              this.ticker.emitter.on("tick", this.onTick_);
              this.read();
            }
            dispose() {
              this.ticker.dispose();
            }
            read() {
              const targetValue = this.target.read();
              if (targetValue === void 0) {
                return;
              }
              const buffer = this.value.rawValue;
              const newValue = this.reader_(targetValue);
              this.value.rawValue = createPushedBuffer(buffer, newValue);
              this.emitter.emit("update", {
                rawValue: newValue,
                sender: this
              });
            }
            onTick_(_) {
              this.read();
            }
          }
          function createTicker(document2, interval) {
            return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
          }
          function createMonitorBindingController(plugin, args) {
            var _a, _b, _c;
            const P = ParamsParsers;
            const result = plugin.accept(args.target.read(), args.params);
            if (isEmpty(result)) {
              return null;
            }
            const bindingArgs = {
              target: args.target,
              initialValue: result.initialValue,
              params: result.params
            };
            const reader = plugin.binding.reader(bindingArgs);
            const bufferSize = (_b = (_a = P.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
            const interval = P.optional.number(args.params.interval).value;
            const binding = new MonitorBinding({
              reader,
              target: args.target,
              ticker: createTicker(args.document, interval),
              value: initializeBuffer(bufferSize)
            });
            const disabled = P.optional.boolean(args.params.disabled).value;
            const hidden = P.optional.boolean(args.params.hidden).value;
            const controller = plugin.controller({
              document: args.document,
              params: result.params,
              value: binding.value,
              viewProps: ViewProps.create({
                disabled,
                hidden
              })
            });
            const label = (_c = P.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : args.target.key;
            return new MonitorBindingController(args.document, {
              binding,
              blade: createBlade(),
              props: ValueMap.fromObject({
                label
              }),
              valueController: controller
            });
          }
          class PluginPool {
            constructor() {
              this.pluginsMap_ = {
                blades: [],
                inputs: [],
                monitors: []
              };
            }
            getAll() {
              return [
                ...this.pluginsMap_.blades,
                ...this.pluginsMap_.inputs,
                ...this.pluginsMap_.monitors
              ];
            }
            register(r) {
              if (r.type === "blade") {
                this.pluginsMap_.blades.unshift(r);
              } else if (r.type === "input") {
                this.pluginsMap_.inputs.unshift(r);
              } else if (r.type === "monitor") {
                this.pluginsMap_.monitors.unshift(r);
              }
            }
            createInput(document2, target, params) {
              const initialValue = target.read();
              if (isEmpty(initialValue)) {
                throw new TpError({
                  context: {
                    key: target.key
                  },
                  type: "nomatchingcontroller"
                });
              }
              const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result || createInputBindingController(plugin, {
                document: document2,
                target,
                params
              }), null);
              if (bc) {
                return bc;
              }
              throw new TpError({
                context: {
                  key: target.key
                },
                type: "nomatchingcontroller"
              });
            }
            createMonitor(document2, target, params) {
              const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result || createMonitorBindingController(plugin, {
                document: document2,
                params,
                target
              }), null);
              if (bc) {
                return bc;
              }
              throw new TpError({
                context: {
                  key: target.key
                },
                type: "nomatchingcontroller"
              });
            }
            createBlade(document2, params) {
              const bc = this.pluginsMap_.blades.reduce((result, plugin) => result || createBladeController(plugin, {
                document: document2,
                params
              }), null);
              if (!bc) {
                throw new TpError({
                  type: "nomatchingview",
                  context: {
                    params
                  }
                });
              }
              return bc;
            }
            createBladeApi(bc) {
              if (bc instanceof InputBindingController) {
                return new InputBindingApi(bc);
              }
              if (bc instanceof MonitorBindingController) {
                return new MonitorBindingApi(bc);
              }
              if (bc instanceof RackController) {
                return new RackApi(bc, this);
              }
              const api = this.pluginsMap_.blades.reduce((result, plugin) => result || plugin.api({
                controller: bc,
                pool: this
              }), null);
              if (!api) {
                throw TpError.shouldNeverHappen();
              }
              return api;
            }
          }
          function createDefaultPluginPool() {
            const pool = new PluginPool();
            [
              Point2dInputPlugin,
              Point3dInputPlugin,
              Point4dInputPlugin,
              StringInputPlugin,
              NumberInputPlugin,
              StringColorInputPlugin,
              ObjectColorInputPlugin,
              NumberColorInputPlugin,
              BooleanInputPlugin,
              BooleanMonitorPlugin,
              StringMonitorPlugin,
              NumberMonitorPlugin,
              ButtonBladePlugin,
              FolderBladePlugin,
              SeparatorBladePlugin,
              TabBladePlugin
            ].forEach((p) => {
              pool.register(p);
            });
            return pool;
          }
          class ListApi extends BladeApi {
            constructor(controller) {
              super(controller);
              this.emitter_ = new Emitter();
              this.controller_.valueController.value.emitter.on("change", (ev) => {
                this.emitter_.emit("change", {
                  event: new TpChangeEvent(this, ev.rawValue)
                });
              });
            }
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            get options() {
              return this.controller_.valueController.props.get("options");
            }
            set options(options) {
              this.controller_.valueController.props.set("options", options);
            }
            get value() {
              return this.controller_.valueController.value.rawValue;
            }
            set value(value) {
              this.controller_.valueController.value.rawValue = value;
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
          }
          class SliderApi extends BladeApi {
            constructor(controller) {
              super(controller);
              this.emitter_ = new Emitter();
              this.controller_.valueController.value.emitter.on("change", (ev) => {
                this.emitter_.emit("change", {
                  event: new TpChangeEvent(this, ev.rawValue)
                });
              });
            }
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            get maxValue() {
              return this.controller_.valueController.sliderController.props.get("maxValue");
            }
            set maxValue(maxValue) {
              this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
            }
            get minValue() {
              return this.controller_.valueController.sliderController.props.get("minValue");
            }
            set minValue(minValue) {
              this.controller_.valueController.sliderController.props.set("minValue", minValue);
            }
            get value() {
              return this.controller_.valueController.value.rawValue;
            }
            set value(value) {
              this.controller_.valueController.value.rawValue = value;
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
          }
          class TextApi extends BladeApi {
            constructor(controller) {
              super(controller);
              this.emitter_ = new Emitter();
              this.controller_.valueController.value.emitter.on("change", (ev) => {
                this.emitter_.emit("change", {
                  event: new TpChangeEvent(this, ev.rawValue)
                });
              });
            }
            get label() {
              return this.controller_.props.get("label");
            }
            set label(label) {
              this.controller_.props.set("label", label);
            }
            get formatter() {
              return this.controller_.valueController.props.get("formatter");
            }
            set formatter(formatter) {
              this.controller_.valueController.props.set("formatter", formatter);
            }
            get value() {
              return this.controller_.valueController.value.rawValue;
            }
            set value(value) {
              this.controller_.valueController.value.rawValue = value;
            }
            on(eventName, handler) {
              const bh = handler.bind(this);
              this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
              });
              return this;
            }
          }
          const ListBladePlugin = function() {
            return {
              id: "list",
              type: "blade",
              accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                  options: p.required.custom(parseListOptions),
                  value: p.required.raw,
                  view: p.required.constant("list"),
                  label: p.optional.string
                });
                return result ? { params: result } : null;
              },
              controller(args) {
                const ic = new ListController(args.document, {
                  props: ValueMap.fromObject({
                    options: normalizeListOptions(args.params.options)
                  }),
                  value: createValue(args.params.value),
                  viewProps: args.viewProps
                });
                return new LabeledValueController(args.document, {
                  blade: args.blade,
                  props: ValueMap.fromObject({
                    label: args.params.label
                  }),
                  valueController: ic
                });
              },
              api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                  return null;
                }
                if (!(args.controller.valueController instanceof ListController)) {
                  return null;
                }
                return new ListApi(args.controller);
              }
            };
          }();
          function exportPresetJson(targets) {
            return targets.reduce((result, target) => {
              return Object.assign(result, {
                [target.presetKey]: target.read()
              });
            }, {});
          }
          function importPresetJson(targets, preset) {
            targets.forEach((target) => {
              const value = preset[target.presetKey];
              if (value !== void 0) {
                target.write(value);
              }
            });
          }
          class RootApi extends FolderApi {
            constructor(controller, pool) {
              super(controller, pool);
            }
            get element() {
              return this.controller_.view.element;
            }
            importPreset(preset) {
              const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
                return ibc.binding.target;
              });
              importPresetJson(targets, preset);
              this.refresh();
            }
            exportPreset() {
              const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
                return ibc.binding.target;
              });
              return exportPresetJson(targets);
            }
            refresh() {
              this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
                ibc.binding.read();
              });
              this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
                mbc.binding.read();
              });
            }
          }
          class RootController extends FolderController {
            constructor(doc, config3) {
              super(doc, {
                expanded: config3.expanded,
                blade: config3.blade,
                props: config3.props,
                root: true,
                viewProps: config3.viewProps
              });
            }
          }
          const SliderBladePlugin = {
            id: "slider",
            type: "blade",
            accept(params) {
              const p = ParamsParsers;
              const result = parseParams(params, {
                max: p.required.number,
                min: p.required.number,
                view: p.required.constant("slider"),
                format: p.optional.function,
                label: p.optional.string,
                value: p.optional.number
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              var _a, _b;
              const v = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
              const vc = new SliderTextController(args.document, {
                baseStep: 1,
                parser: parseNumber,
                sliderProps: ValueMap.fromObject({
                  maxValue: args.params.max,
                  minValue: args.params.min
                }),
                textProps: ValueMap.fromObject({
                  draggingScale: getSuitableDraggingScale(void 0, v),
                  formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString
                }),
                value: createValue(v),
                viewProps: args.viewProps
              });
              return new LabeledValueController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                  label: args.params.label
                }),
                valueController: vc
              });
            },
            api(args) {
              if (!(args.controller instanceof LabeledValueController)) {
                return null;
              }
              if (!(args.controller.valueController instanceof SliderTextController)) {
                return null;
              }
              return new SliderApi(args.controller);
            }
          };
          const TextBladePlugin = function() {
            return {
              id: "text",
              type: "blade",
              accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                  parse: p.required.function,
                  value: p.required.raw,
                  view: p.required.constant("text"),
                  format: p.optional.function,
                  label: p.optional.string
                });
                return result ? { params: result } : null;
              },
              controller(args) {
                var _a;
                const ic = new TextController(args.document, {
                  parser: args.params.parse,
                  props: ValueMap.fromObject({
                    formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : (v) => String(v)
                  }),
                  value: createValue(args.params.value),
                  viewProps: args.viewProps
                });
                return new LabeledValueController(args.document, {
                  blade: args.blade,
                  props: ValueMap.fromObject({
                    label: args.params.label
                  }),
                  valueController: ic
                });
              },
              api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                  return null;
                }
                if (!(args.controller.valueController instanceof TextController)) {
                  return null;
                }
                return new TextApi(args.controller);
              }
            };
          }();
          function createDefaultWrapperElement(doc) {
            const elem = doc.createElement("div");
            elem.classList.add(ClassName("dfw")());
            if (doc.body) {
              doc.body.appendChild(elem);
            }
            return elem;
          }
          function embedStyle(doc, id2, css2) {
            if (doc.querySelector(`style[data-tp-style=${id2}]`)) {
              return;
            }
            const styleElem = doc.createElement("style");
            styleElem.dataset.tpStyle = id2;
            styleElem.textContent = css2;
            doc.head.appendChild(styleElem);
          }
          class Pane3 extends RootApi {
            constructor(opt_config) {
              var _a;
              const config3 = opt_config || {};
              const doc = (_a = config3.document) !== null && _a !== void 0 ? _a : getWindowDocument();
              const pool = createDefaultPluginPool();
              const rootController = new RootController(doc, {
                expanded: config3.expanded,
                blade: createBlade(),
                props: ValueMap.fromObject({
                  title: config3.title
                }),
                viewProps: ViewProps.create()
              });
              super(rootController, pool);
              this.pool_ = pool;
              this.containerElem_ = config3.container || createDefaultWrapperElement(doc);
              this.containerElem_.appendChild(this.element);
              this.doc_ = doc;
              this.usesDefaultWrapper_ = !config3.container;
              this.setUpDefaultPlugins_();
            }
            get document() {
              if (!this.doc_) {
                throw TpError.alreadyDisposed();
              }
              return this.doc_;
            }
            dispose() {
              const containerElem = this.containerElem_;
              if (!containerElem) {
                throw TpError.alreadyDisposed();
              }
              if (this.usesDefaultWrapper_) {
                const parentElem = containerElem.parentElement;
                if (parentElem) {
                  parentElem.removeChild(containerElem);
                }
              }
              this.containerElem_ = null;
              this.doc_ = null;
              super.dispose();
            }
            registerPlugin(bundle) {
              const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
              plugins.forEach((p) => {
                this.pool_.register(p);
                this.embedPluginStyle_(p);
              });
            }
            embedPluginStyle_(plugin) {
              if (plugin.css) {
                embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
              }
            }
            setUpDefaultPlugins_() {
              embedStyle(this.document, "default", ".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(0,0,0,0.2));--in-bg-a: var(--tp-input-background-color-active, rgba(0,0,0,0.35));--in-bg-f: var(--tp-input-background-color-focus, rgba(0,0,0,0.3));--in-bg-h: var(--tp-input-background-color-hover, rgba(0,0,0,0.25));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:calc(var(--cnt-h-p) + 8px);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}");
              this.pool_.getAll().forEach((plugin) => {
                this.embedPluginStyle_(plugin);
              });
              this.registerPlugin({
                plugins: [
                  SliderBladePlugin,
                  ListBladePlugin,
                  TabBladePlugin,
                  TextBladePlugin
                ]
              });
            }
          }
          const VERSION = new Semver("3.0.5");
          exports3.BladeApi = BladeApi;
          exports3.ButtonApi = ButtonApi;
          exports3.FolderApi = FolderApi;
          exports3.InputBindingApi = InputBindingApi;
          exports3.ListApi = ListApi;
          exports3.MonitorBindingApi = MonitorBindingApi;
          exports3.Pane = Pane3;
          exports3.SeparatorApi = SeparatorApi;
          exports3.SliderApi = SliderApi;
          exports3.TabApi = TabApi;
          exports3.TabPageApi = TabPageApi;
          exports3.TextApi = TextApi;
          exports3.TpChangeEvent = TpChangeEvent;
          exports3.VERSION = VERSION;
          Object.defineProperty(exports3, "__esModule", { value: true });
        });
      }
    });
  
    // node_modules/tweakpane-image-plugin/dist/tweakpane-image-plugin.js
    var require_tweakpane_image_plugin = __commonJS({
      "node_modules/tweakpane-image-plugin/dist/tweakpane-image-plugin.js"(exports2, module2) {
        (function(global2, factory) {
          typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.TweakpaneImagePlugin = {}));
        })(exports2, function(exports3) {
          "use strict";
          function forceCast(v) {
            return v;
          }
          const PREFIX = "tp";
          function ClassName(viewName) {
            const fn = (opt_elementName, opt_modifier) => {
              return [
                PREFIX,
                "-",
                viewName,
                "v",
                opt_elementName ? `_${opt_elementName}` : "",
                opt_modifier ? `-${opt_modifier}` : ""
              ].join("");
            };
            return fn;
          }
          function parseObject(value, keyToParserMap) {
            const keys = Object.keys(keyToParserMap);
            const result = keys.reduce((tmp2, key) => {
              if (tmp2 === void 0) {
                return void 0;
              }
              const parser = keyToParserMap[key];
              const result2 = parser(value[key]);
              return result2.succeeded ? Object.assign(Object.assign({}, tmp2), { [key]: result2.value }) : void 0;
            }, {});
            return forceCast(result);
          }
          function parseArray(value, parseItem) {
            return value.reduce((tmp2, item) => {
              if (tmp2 === void 0) {
                return void 0;
              }
              const result = parseItem(item);
              if (!result.succeeded || result.value === void 0) {
                return void 0;
              }
              return [...tmp2, result.value];
            }, []);
          }
          function isObject3(value) {
            if (value === null) {
              return false;
            }
            return typeof value === "object";
          }
          function createParamsParserBuilder(parse) {
            return (optional) => (v) => {
              if (!optional && v === void 0) {
                return {
                  succeeded: false,
                  value: void 0
                };
              }
              if (optional && v === void 0) {
                return {
                  succeeded: true,
                  value: void 0
                };
              }
              const result = parse(v);
              return result !== void 0 ? {
                succeeded: true,
                value: result
              } : {
                succeeded: false,
                value: void 0
              };
            };
          }
          function createParamsParserBuilders(optional) {
            return {
              custom: (parse) => createParamsParserBuilder(parse)(optional),
              boolean: createParamsParserBuilder((v) => typeof v === "boolean" ? v : void 0)(optional),
              number: createParamsParserBuilder((v) => typeof v === "number" ? v : void 0)(optional),
              string: createParamsParserBuilder((v) => typeof v === "string" ? v : void 0)(optional),
              function: createParamsParserBuilder((v) => typeof v === "function" ? v : void 0)(optional),
              constant: (value) => createParamsParserBuilder((v) => v === value ? value : void 0)(optional),
              raw: createParamsParserBuilder((v) => v)(optional),
              object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject3(v)) {
                  return void 0;
                }
                return parseObject(v, keyToParserMap);
              })(optional),
              array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                  return void 0;
                }
                return parseArray(v, itemParser);
              })(optional)
            };
          }
          const ParamsParsers = {
            optional: createParamsParserBuilders(true),
            required: createParamsParserBuilders(false)
          };
          function parseParams(value, keyToParserMap) {
            const result = ParamsParsers.required.object(keyToParserMap)(value);
            return result.succeeded ? result.value : void 0;
          }
          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          }
          function createPlaceholderImage() {
            const canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#222";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ddd";
            ctx.font = "monospaced";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("No image", canvas.width * 0.5, canvas.height * 0.5);
            return new Promise((resolve) => {
              canvas.toBlob((blob) => {
                const image = new Image();
                image.src = URL.createObjectURL(blob);
                image.onload = () => {
                  resolve(image);
                };
              });
            });
          }
          function loadImage3(src2) {
            return __awaiter(this, void 0, void 0, function* () {
              const image = new Image();
              image.crossOrigin = "anonymous";
              return new Promise((resolve) => {
                image.src = src2;
                image.onload = () => {
                  resolve(image);
                };
              });
            });
          }
          function cloneImage(source) {
            const canvas = document.createElement("canvas");
            canvas.width = source.width;
            canvas.height = source.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(source, 0, 0);
            const image = new Image();
            return new Promise((resolve) => {
              canvas.toBlob((blob) => {
                image.src = URL.createObjectURL(blob);
                image.onload = () => {
                  resolve(image);
                };
              });
            });
          }
          const className = ClassName("img");
          class PluginView {
            constructor(doc, config3) {
              this.element = doc.createElement("div");
              this.element.classList.add(className());
              config3.viewProps.bindClassModifiers(this.element);
              this.input = doc.createElement("input");
              this.input.classList.add(className("input"));
              this.input.setAttribute("type", "file");
              this.input.setAttribute("accept", config3.extensions.join(","));
              this.element.appendChild(this.input);
              this.image_ = doc.createElement("img");
              this.image_.classList.add(className("image"));
              this.image_.classList.add(className(`image_${config3.imageFit}`));
              this.element.classList.add(className("area_root"));
              this.element.appendChild(this.image_);
            }
            changeImage(src2) {
              this.image_.src = src2;
            }
            changeDraggingState(state) {
              const el = this.element;
              if (state) {
                el === null || el === void 0 ? void 0 : el.classList.add(className("area_dragging"));
              } else {
                el === null || el === void 0 ? void 0 : el.classList.remove(className("area_dragging"));
              }
            }
          }
          class PluginController {
            constructor(doc, config3) {
              this.placeholderImage = null;
              this.value = config3.value;
              this.viewProps = config3.viewProps;
              this.view = new PluginView(doc, {
                viewProps: this.viewProps,
                extensions: config3.extensions,
                imageFit: config3.imageFit
              });
              this.onFile = this.onFile.bind(this);
              this.onDrop = this.onDrop.bind(this);
              this.onDragOver = this.onDragOver.bind(this);
              this.onDragLeave = this.onDragLeave.bind(this);
              this.view.input.addEventListener("change", this.onFile);
              this.view.element.addEventListener("drop", this.onDrop);
              this.view.element.addEventListener("dragover", this.onDragOver);
              this.view.element.addEventListener("dragleave", this.onDragLeave);
              this.viewProps.handleDispose(() => {
                this.view.input.removeEventListener("change", this.onFile);
                this.view.input.removeEventListener("drop", this.onDrop);
                this.view.input.removeEventListener("dragover", this.onDragOver);
                this.view.input.removeEventListener("dragleave", this.onDragLeave);
              });
              this.value.emitter.on("change", this.handleValueChange.bind(this));
              this.handleValueChange();
            }
            onFile(event2) {
              const files = (event2 === null || event2 === void 0 ? void 0 : event2.target).files;
              if (!files || !files.length)
                return;
              const file = files[0];
              const url = URL.createObjectURL(file);
              this.setValue(url);
              this.updateImage(url);
            }
            onDrop(event2) {
              return __awaiter(this, void 0, void 0, function* () {
                event2.preventDefault();
                try {
                  const { dataTransfer } = event2;
                  const file = dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.files[0];
                  if (file) {
                    const url = URL.createObjectURL(file);
                    this.updateImage(url);
                    this.setValue(url);
                  } else {
                    const url = dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.getData("url");
                    if (!url)
                      throw new Error("No url");
                    loadImage3(url).then((image) => __awaiter(this, void 0, void 0, function* () {
                      const clone = yield cloneImage(image);
                      this.updateImage(clone.src);
                      this.setValue(clone);
                    }));
                  }
                } catch (e) {
                  console.error("Could not parse the dropped image", e);
                } finally {
                  this.view.changeDraggingState(false);
                }
              });
            }
            onDragOver(event2) {
              event2.preventDefault();
              this.view.changeDraggingState(true);
            }
            onDragLeave() {
              this.view.changeDraggingState(false);
            }
            handleImage(image) {
              return __awaiter(this, void 0, void 0, function* () {
                if (image instanceof HTMLImageElement) {
                  cloneImage(image).then((clone) => {
                    this.updateImage(clone.src);
                  });
                } else if (typeof image === "string") {
                  let finalUrl = "";
                  try {
                    if (image === "placeholder")
                      throw new Error("placeholder");
                    new URL(image);
                    const loadedImage = yield loadImage3(image);
                    finalUrl = loadedImage.src;
                  } catch (_) {
                    finalUrl = (yield this.handlePlaceholderImage()).src;
                  } finally {
                    this.updateImage(finalUrl);
                    this.setValue(finalUrl);
                  }
                }
              });
            }
            updateImage(src2) {
              this.view.changeImage(src2);
            }
            setValue(src2) {
              return __awaiter(this, void 0, void 0, function* () {
                if (src2 instanceof HTMLImageElement) {
                  this.value.setRawValue(src2);
                } else if (src2) {
                  this.value.setRawValue(yield loadImage3(src2));
                } else {
                  this.value.setRawValue(yield this.handlePlaceholderImage());
                }
              });
            }
            handleValueChange() {
              this.handleImage(this.value.rawValue);
            }
            handlePlaceholderImage() {
              return __awaiter(this, void 0, void 0, function* () {
                if (!this.placeholderImage) {
                  this.placeholderImage = yield createPlaceholderImage();
                }
                return this.placeholderImage;
              });
            }
          }
          const DEFAULT_EXTENSIONS = [".jpg", ".png", ".gif"];
          const TweakpaneImagePlugin2 = {
            id: "input-image",
            type: "input",
            css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:grid;height:calc(var(--bld-us) * 3);overflow:hidden;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:100%;height:100%;opacity:0}.tp-imgv_image{width:100%;height:100%;position:absolute;pointer-events:none;border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:6px;opacity:0.6}",
            accept(exValue, params) {
              if (!(exValue instanceof HTMLImageElement || typeof exValue === "string")) {
                return null;
              }
              const p = ParamsParsers;
              const result = parseParams(params, {
                view: p.required.constant("input-image"),
                acceptUrl: p.optional.boolean,
                imageFit: p.optional.custom((v) => v === "contain" || v === "cover" ? v : void 0),
                extensions: p.optional.array(p.required.string)
              });
              if (!result) {
                return null;
              }
              return {
                initialValue: exValue,
                params: result
              };
            },
            binding: {
              reader(_args) {
                return (exValue) => {
                  if (exValue instanceof HTMLImageElement) {
                    return exValue.src === "" ? "placeholder" : exValue.src;
                  } else {
                    return typeof exValue === "string" ? exValue : "placeholder";
                  }
                };
              },
              writer(_args) {
                return (target, inValue) => {
                  target.write(inValue);
                };
              }
            },
            controller(args) {
              var _a, _b;
              return new PluginController(args.document, {
                value: args.value,
                imageFit: (_a = args.params.imageFit) !== null && _a !== void 0 ? _a : "cover",
                viewProps: args.viewProps,
                extensions: (_b = args.params.extensions) !== null && _b !== void 0 ? _b : DEFAULT_EXTENSIONS
              });
            }
          };
          const plugin = TweakpaneImagePlugin2;
          exports3.plugin = plugin;
          Object.defineProperty(exports3, "__esModule", { value: true });
        });
      }
    });
  
    // node_modules/modujs/dist/main.esm.js
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _iterableToArrayLimit(arr, i2) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var _default = /* @__PURE__ */ function() {
      function _default4(options) {
        _classCallCheck(this, _default4);
        this.mAttr = "data-" + options.dataName;
        this.mCaptureEvents = ["mouseenter", "mouseleave"];
        this.el = options.el;
      }
      _createClass(_default4, [{
        key: "mInit",
        value: function mInit(modules) {
          var _this = this;
          this.modules = modules;
          this.mCheckEventTarget = this.mCheckEventTarget.bind(this);
          if (this.events) {
            Object.keys(this.events).forEach(function(event2) {
              return _this.mAddEvent(event2);
            });
          }
        }
      }, {
        key: "mUpdate",
        value: function mUpdate(modules) {
          this.modules = modules;
        }
      }, {
        key: "mDestroy",
        value: function mDestroy() {
          var _this2 = this;
          if (this.events) {
            Object.keys(this.events).forEach(function(event2) {
              return _this2.mRemoveEvent(event2);
            });
          }
        }
      }, {
        key: "mAddEvent",
        value: function mAddEvent(event2) {
          var capture = this.mCaptureEvents.includes(event2) ? true : false;
          this.el.addEventListener(event2, this.mCheckEventTarget, capture);
        }
      }, {
        key: "mRemoveEvent",
        value: function mRemoveEvent(event2) {
          var capture = this.mCaptureEvents.includes(event2) ? true : false;
          this.el.removeEventListener(event2, this.mCheckEventTarget, capture);
        }
      }, {
        key: "mCheckEventTarget",
        value: function mCheckEventTarget(e) {
          var event2 = this.events[e.type];
          if (typeof event2 === "string") {
            this[event2](e);
          } else {
            var data = "[" + this.mAttr + "]";
            var target = e.target;
            if (this.mCaptureEvents.includes(e.type)) {
              if (target.matches(data)) {
                this.mCallEventMethod(e, event2, target);
              }
            } else {
              while (target && target !== document) {
                if (target.matches(data)) {
                  if (this.mCallEventMethod(e, event2, target) != "undefined") {
                    break;
                  }
                }
                target = target.parentNode;
              }
            }
          }
        }
      }, {
        key: "mCallEventMethod",
        value: function mCallEventMethod(e, event2, target) {
          var name = target.getAttribute(this.mAttr);
          if (event2.hasOwnProperty(name)) {
            var method = event2[name];
            if (!e.hasOwnProperty("currentTarget")) {
              Object.defineProperty(e, "currentTarget", {
                value: target
              });
            }
            if (!e.hasOwnProperty("curTarget")) {
              Object.defineProperty(e, "curTarget", {
                value: target
              });
            }
            this[method](e);
          }
        }
      }, {
        key: "$",
        value: function $2(query, context3) {
          var classIndex = query.indexOf(".");
          var idIndex = query.indexOf("#");
          var attrIndex = query.indexOf("[");
          var indexes = [classIndex, idIndex, attrIndex].filter(function(index3) {
            return index3 != -1;
          });
          var index2 = false;
          var name = query;
          var more = "";
          var parent2 = this.el;
          if (indexes.length) {
            index2 = Math.min.apply(Math, _toConsumableArray(indexes));
            name = query.slice(0, index2);
            more = query.slice(index2);
          }
          if (_typeof(context3) == "object") {
            parent2 = context3;
          }
          return parent2.querySelectorAll("[" + this.mAttr + "=" + name + "]" + more);
        }
      }, {
        key: "parent",
        value: function parent2(query, context3) {
          var data = "[" + this.mAttr + "=" + query + "]";
          var parent3 = context3.parentNode;
          while (parent3 && parent3 !== document) {
            if (parent3.matches(data)) {
              return parent3;
            }
            parent3 = parent3.parentNode;
          }
        }
      }, {
        key: "getData",
        value: function getData(name, context3) {
          var target = context3 || this.el;
          return target.getAttribute(this.mAttr + "-" + name);
        }
      }, {
        key: "setData",
        value: function setData(name, value, context3) {
          var target = context3 || this.el;
          return target.setAttribute(this.mAttr + "-" + name, value);
        }
      }, {
        key: "call",
        value: function call(func, args, mod, id2) {
          var _this3 = this;
          if (args && !mod) {
            mod = args;
            args = false;
          }
          if (this.modules[mod]) {
            if (id2) {
              if (this.modules[mod][id2]) {
                this.modules[mod][id2][func](args);
              }
            } else {
              Object.keys(this.modules[mod]).forEach(function(id3) {
                _this3.modules[mod][id3][func](args);
              });
            }
          }
        }
      }, {
        key: "on",
        value: function on2(e, mod, func, id2) {
          var _this4 = this;
          if (this.modules[mod]) {
            if (id2) {
              this.modules[mod][id2].el.addEventListener(e, function(o) {
                return func(o);
              });
            } else {
              Object.keys(this.modules[mod]).forEach(function(i2) {
                _this4.modules[mod][i2].el.addEventListener(e, function(o) {
                  return func(o);
                });
              });
            }
          }
        }
      }, {
        key: "init",
        value: function init6() {
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }]);
      return _default4;
    }();
    var _default$1 = /* @__PURE__ */ function() {
      function _default4(options) {
        _classCallCheck(this, _default4);
        this.app;
        this.modules = options.modules;
        this.currentModules = {};
        this.activeModules = {};
        this.newModules = {};
        this.moduleId = 0;
      }
      _createClass(_default4, [{
        key: "init",
        value: function init6(app2, scope) {
          var _this = this;
          var container = scope || document;
          var elements = container.querySelectorAll("*");
          if (app2 && !this.app) {
            this.app = app2;
          }
          this.activeModules["app"] = {
            "app": this.app
          };
          elements.forEach(function(el) {
            Array.from(el.attributes).forEach(function(i2) {
              if (i2.name.startsWith("data-module")) {
                var moduleExists = false;
                var dataName = i2.name.split("-").splice(2);
                var moduleName = _this.toCamel(dataName);
                if (_this.modules[moduleName]) {
                  moduleExists = true;
                } else if (_this.modules[_this.toUpper(moduleName)]) {
                  moduleName = _this.toUpper(moduleName);
                  moduleExists = true;
                }
                if (moduleExists) {
                  var options = {
                    el,
                    name: moduleName,
                    dataName: dataName.join("-")
                  };
                  var module2 = new _this.modules[moduleName](options);
                  var id2 = i2.value;
                  if (!id2) {
                    _this.moduleId++;
                    id2 = "m" + _this.moduleId;
                    el.setAttribute(i2.name, id2);
                  }
                  _this.addActiveModule(moduleName, id2, module2);
                  var moduleId = moduleName + "-" + id2;
                  if (scope) {
                    _this.newModules[moduleId] = module2;
                  } else {
                    _this.currentModules[moduleId] = module2;
                  }
                }
              }
            });
          });
          Object.entries(this.currentModules).forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), id2 = _ref2[0], module2 = _ref2[1];
            if (scope) {
              var split = id2.split("-");
              var moduleName = split.shift();
              var moduleId = split.pop();
              _this.addActiveModule(moduleName, moduleId, module2);
            } else {
              _this.initModule(module2);
            }
          });
        }
      }, {
        key: "initModule",
        value: function initModule(module2) {
          module2.mInit(this.activeModules);
          module2.init();
        }
      }, {
        key: "addActiveModule",
        value: function addActiveModule(name, id2, module2) {
          if (this.activeModules[name]) {
            Object.assign(this.activeModules[name], _defineProperty({}, id2, module2));
          } else {
            this.activeModules[name] = _defineProperty({}, id2, module2);
          }
        }
      }, {
        key: "update",
        value: function update(scope) {
          var _this2 = this;
          this.init(this.app, scope);
          Object.entries(this.currentModules).forEach(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), id2 = _ref4[0], module2 = _ref4[1];
            module2.mUpdate(_this2.activeModules);
          });
          Object.entries(this.newModules).forEach(function(_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2), id2 = _ref6[0], module2 = _ref6[1];
            _this2.initModule(module2);
          });
          Object.assign(this.currentModules, this.newModules);
        }
      }, {
        key: "destroy",
        value: function destroy(scope) {
          if (scope) {
            this.destroyScope(scope);
          } else {
            this.destroyModules();
          }
        }
      }, {
        key: "destroyScope",
        value: function destroyScope(scope) {
          var _this3 = this;
          var elements = scope.querySelectorAll("*");
          elements.forEach(function(el) {
            Array.from(el.attributes).forEach(function(i2) {
              if (i2.name.startsWith("data-module")) {
                var id2 = i2.value;
                var dataName = i2.name.split("-").splice(2);
                var moduleName = _this3.toCamel(dataName) + "-" + id2;
                var moduleExists = false;
                if (_this3.currentModules[moduleName]) {
                  moduleExists = true;
                } else if (_this3.currentModules[_this3.toUpper(moduleName)]) {
                  moduleName = _this3.toUpper(moduleName);
                  moduleExists = true;
                }
                if (moduleExists) {
                  _this3.destroyModule(_this3.currentModules[moduleName]);
                  delete _this3.currentModules[moduleName];
                }
              }
            });
          });
          this.activeModules = {};
          this.newModules = {};
        }
      }, {
        key: "destroyModules",
        value: function destroyModules() {
          var _this4 = this;
          Object.entries(this.currentModules).forEach(function(_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2), id2 = _ref8[0], module2 = _ref8[1];
            _this4.destroyModule(module2);
          });
          this.currentModules = [];
        }
      }, {
        key: "destroyModule",
        value: function destroyModule(module2) {
          module2.mDestroy();
          module2.destroy();
        }
      }, {
        key: "toCamel",
        value: function toCamel(arr) {
          var _this5 = this;
          return arr.reduce(function(a, b) {
            return a + _this5.toUpper(b);
          });
        }
      }, {
        key: "toUpper",
        value: function toUpper(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
      }]);
      return _default4;
    }();
    var main_esm_default = _default$1;
  
    // assets/scripts/globals.js
    var import_svg4everybody = __toModule(require_svg4everybody());
    function globals_default() {
      (0, import_svg4everybody.default)();
    }
  
    // assets/scripts/modules.js
    var modules_exports = {};
    __export(modules_exports, {
      AnimateIllustration: () => AnimateIllustration_default,
      CarouselQuote: () => CarouselQuote_default,
      Cursor: () => Cursor_default,
      DepthmapPlayground: () => DepthmapPlayground_default,
      DrawSvg: () => DrawSvg_default,
      Experiences: () => Experiences_default,
      FollowingHover: () => FollowingHover_default,
      FooterReveal: () => FooterReveal_default,
      Form: () => Form_default,
      Gallery: () => Gallery_default,
      GridHelper: () => GridHelper_default,
      Hovered: () => Hovered_default,
      Introduction: () => Introduction_default,
      LightTheme: () => LightTheme_default,
      Load: () => Load_default,
      Logo: () => Logo_default,
      MenuModal: () => MenuModal_default,
      MenuToggler: () => MenuToggler_default,
      Positions: () => Positions_default,
      PushVideo: () => PushVideo_default,
      Scroll: () => Scroll_default,
      ScrollQuote: () => ScrollQuote_default,
      ScrollTo: () => ScrollTo_default,
      SplitText: () => AnimText,
      TileMouse: () => TileMouse_default,
      Trombinoscope: () => Trombinoscope_default,
      TrombinoscopeModal: () => TrombinoscopeModal_default,
      VideoModal: () => VideoModal_default,
      VideoThumb: () => VideoThumb_default,
      Wysiwyg: () => Wysiwyg_default
    });
  
    // node_modules/gsap/gsap-core.js
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var _config = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    };
    var _defaults = {
      duration: 0.5,
      overwrite: false,
      delay: 0
    };
    var _suppressOverwrites;
    var _reverting;
    var _context;
    var _bigNum = 1e8;
    var _tinyNum = 1 / _bigNum;
    var _2PI = Math.PI * 2;
    var _HALF_PI = _2PI / 4;
    var _gsID = 0;
    var _sqrt = Math.sqrt;
    var _cos = Math.cos;
    var _sin = Math.sin;
    var _isString = function _isString2(value) {
      return typeof value === "string";
    };
    var _isFunction = function _isFunction2(value) {
      return typeof value === "function";
    };
    var _isNumber = function _isNumber2(value) {
      return typeof value === "number";
    };
    var _isUndefined = function _isUndefined2(value) {
      return typeof value === "undefined";
    };
    var _isObject = function _isObject2(value) {
      return typeof value === "object";
    };
    var _isNotFalse = function _isNotFalse2(value) {
      return value !== false;
    };
    var _windowExists = function _windowExists2() {
      return typeof window !== "undefined";
    };
    var _isFuncOrString = function _isFuncOrString2(value) {
      return _isFunction(value) || _isString(value);
    };
    var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
    };
    var _isArray = Array.isArray;
    var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
    var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
    var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
    var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
    var _relExp = /[+-]=-?[.\d]+/;
    var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
    var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
    var _globalTimeline;
    var _win;
    var _coreInitted;
    var _doc;
    var _globals = {};
    var _installScope = {};
    var _coreReady;
    var _install = function _install2(scope) {
      return (_installScope = _merge(scope, _globals)) && gsap;
    };
    var _missingPlugin = function _missingPlugin2(property, value) {
      return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
    };
    var _warn = function _warn2(message, suppress) {
      return !suppress && console.warn(message);
    };
    var _addGlobal = function _addGlobal2(name, obj) {
      return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
    };
    var _emptyFunc = function _emptyFunc2() {
      return 0;
    };
    var _startAtRevertConfig = {
      suppressEvents: true,
      isStart: true,
      kill: false
    };
    var _revertConfigNoKill = {
      suppressEvents: true,
      kill: false
    };
    var _revertConfig = {
      suppressEvents: true
    };
    var _reservedProps = {};
    var _lazyTweens = [];
    var _lazyLookup = {};
    var _lastRenderedFrame;
    var _plugins = {};
    var _effects = {};
    var _nextGCFrame = 30;
    var _harnessPlugins = [];
    var _callbackNames = "";
    var _harness = function _harness2(targets) {
      var target = targets[0], harnessPlugin, i2;
      _isObject(target) || _isFunction(target) || (targets = [targets]);
      if (!(harnessPlugin = (target._gsap || {}).harness)) {
        i2 = _harnessPlugins.length;
        while (i2-- && !_harnessPlugins[i2].targetTest(target)) {
        }
        harnessPlugin = _harnessPlugins[i2];
      }
      i2 = targets.length;
      while (i2--) {
        targets[i2] && (targets[i2]._gsap || (targets[i2]._gsap = new GSCache(targets[i2], harnessPlugin))) || targets.splice(i2, 1);
      }
      return targets;
    };
    var _getCache = function _getCache2(target) {
      return target._gsap || _harness(toArray(target))[0]._gsap;
    };
    var _getProperty = function _getProperty2(target, property, v) {
      return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
    };
    var _forEachName = function _forEachName2(names, func) {
      return (names = names.split(",")).forEach(func) || names;
    };
    var _round = function _round2(value) {
      return Math.round(value * 1e5) / 1e5 || 0;
    };
    var _roundPrecise = function _roundPrecise2(value) {
      return Math.round(value * 1e7) / 1e7 || 0;
    };
    var _parseRelative = function _parseRelative2(start, value) {
      var operator = value.charAt(0), end = parseFloat(value.substr(2));
      start = parseFloat(start);
      return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
    };
    var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
      var l = toFind.length, i2 = 0;
      for (; toSearch.indexOf(toFind[i2]) < 0 && ++i2 < l; ) {
      }
      return i2 < l;
    };
    var _lazyRender = function _lazyRender2() {
      var l = _lazyTweens.length, a = _lazyTweens.slice(0), i2, tween;
      _lazyLookup = {};
      _lazyTweens.length = 0;
      for (i2 = 0; i2 < l; i2++) {
        tween = a[i2];
        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
      }
    };
    var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
      _lazyTweens.length && _lazyRender();
      animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
      _lazyTweens.length && _lazyRender();
    };
    var _numericIfPossible = function _numericIfPossible2(value) {
      var n = parseFloat(value);
      return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
    };
    var _passThrough = function _passThrough2(p) {
      return p;
    };
    var _setDefaults = function _setDefaults2(obj, defaults3) {
      for (var p in defaults3) {
        p in obj || (obj[p] = defaults3[p]);
      }
      return obj;
    };
    var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
      return function(obj, defaults3) {
        for (var p in defaults3) {
          p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults3[p]);
        }
      };
    };
    var _merge = function _merge2(base, toMerge) {
      for (var p in toMerge) {
        base[p] = toMerge[p];
      }
      return base;
    };
    var _mergeDeep = function _mergeDeep2(base, toMerge) {
      for (var p in toMerge) {
        p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
      }
      return base;
    };
    var _copyExcluding = function _copyExcluding2(obj, excluding) {
      var copy = {}, p;
      for (p in obj) {
        p in excluding || (copy[p] = obj[p]);
      }
      return copy;
    };
    var _inheritDefaults = function _inheritDefaults2(vars) {
      var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
      if (_isNotFalse(vars.inherit)) {
        while (parent2) {
          func(vars, parent2.vars.defaults);
          parent2 = parent2.parent || parent2._dp;
        }
      }
      return vars;
    };
    var _arraysMatch = function _arraysMatch2(a1, a2) {
      var i2 = a1.length, match = i2 === a2.length;
      while (match && i2-- && a1[i2] === a2[i2]) {
      }
      return i2 < 0;
    };
    var _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
      if (lastProp === void 0) {
        lastProp = "_last";
      }
      var prev2 = parent2[lastProp], t;
      if (sortBy) {
        t = child[sortBy];
        while (prev2 && prev2[sortBy] > t) {
          prev2 = prev2._prev;
        }
      }
      if (prev2) {
        child._next = prev2._next;
        prev2._next = child;
      } else {
        child._next = parent2[firstProp];
        parent2[firstProp] = child;
      }
      if (child._next) {
        child._next._prev = child;
      } else {
        parent2[lastProp] = child;
      }
      child._prev = prev2;
      child.parent = child._dp = parent2;
      return child;
    };
    var _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
      if (lastProp === void 0) {
        lastProp = "_last";
      }
      var prev2 = child._prev, next2 = child._next;
      if (prev2) {
        prev2._next = next2;
      } else if (parent2[firstProp] === child) {
        parent2[firstProp] = next2;
      }
      if (next2) {
        next2._prev = prev2;
      } else if (parent2[lastProp] === child) {
        parent2[lastProp] = prev2;
      }
      child._next = child._prev = child.parent = null;
    };
    var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
      child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
      child._act = 0;
    };
    var _uncache = function _uncache2(animation, child) {
      if (animation && (!child || child._end > animation._dur || child._start < 0)) {
        var a = animation;
        while (a) {
          a._dirty = 1;
          a = a.parent;
        }
      }
      return animation;
    };
    var _recacheAncestors = function _recacheAncestors2(animation) {
      var parent2 = animation.parent;
      while (parent2 && parent2.parent) {
        parent2._dirty = 1;
        parent2.totalDuration();
        parent2 = parent2.parent;
      }
      return animation;
    };
    var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
      return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
    };
    var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
      return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
    };
    var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
      return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
    };
    var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
      var whole = Math.floor(tTime /= cycleDuration);
      return tTime && whole === tTime ? whole - 1 : whole;
    };
    var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
      return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
    };
    var _setEnd = function _setEnd2(animation) {
      return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
    };
    var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
      var parent2 = animation._dp;
      if (parent2 && parent2.smoothChildTiming && animation._ts) {
        animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
        _setEnd(animation);
        parent2._dirty || _uncache(parent2, animation);
      }
      return animation;
    };
    var _postAddChecks = function _postAddChecks2(timeline2, child) {
      var t;
      if (child._time || child._initted && !child._dur) {
        t = _parentToChildTotalTime(timeline2.rawTime(), child);
        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
          child.render(t, true);
        }
      }
      if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
        if (timeline2._dur < timeline2.duration()) {
          t = timeline2;
          while (t._dp) {
            t.rawTime() >= 0 && t.totalTime(t._tTime);
            t = t._dp;
          }
        }
        timeline2._zTime = -_tinyNum;
      }
    };
    var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
      child.parent && _removeFromParent(child);
      child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
      child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
      _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
      _isFromOrFromStart(child) || (timeline2._recent = child);
      skipChecks || _postAddChecks(timeline2, child);
      timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
      return timeline2;
    };
    var _scrollTrigger = function _scrollTrigger2(animation, trigger2) {
      return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger2)) && _globals.ScrollTrigger.create(trigger2, animation);
    };
    var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
      _initTween(tween, time, tTime);
      if (!tween._initted) {
        return 1;
      }
      if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
        _lazyTweens.push(tween);
        tween._lazy = [tTime, suppressEvents];
        return 1;
      }
    };
    var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
      var parent2 = _ref.parent;
      return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
    };
    var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
      var data = _ref2.data;
      return data === "isFromStart" || data === "isStart";
    };
    var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
      var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
      if (repeatDelay && tween._repeat) {
        tTime = _clamp(0, tween._tDur, totalTime);
        iteration = _animationCycle(tTime, repeatDelay);
        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
          prevRatio = 1 - ratio;
          tween.vars.repeatRefresh && tween._initted && tween.invalidate();
        }
      }
      if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
          return;
        }
        prevIteration = tween._zTime;
        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
        suppressEvents || (suppressEvents = totalTime && !prevIteration);
        tween.ratio = ratio;
        tween._from && (ratio = 1 - ratio);
        tween._time = 0;
        tween._tTime = tTime;
        pt = tween._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
        tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
          ratio && _removeFromParent(tween, 1);
          if (!suppressEvents && !_reverting) {
            _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
            tween._prom && tween._prom();
          }
        }
      } else if (!tween._zTime) {
        tween._zTime = totalTime;
      }
    };
    var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
      var child;
      if (time > prevTime) {
        child = animation._first;
        while (child && child._start <= time) {
          if (child.data === "isPause" && child._start > prevTime) {
            return child;
          }
          child = child._next;
        }
      } else {
        child = animation._last;
        while (child && child._start >= time) {
          if (child.data === "isPause" && child._start < prevTime) {
            return child;
          }
          child = child._prev;
        }
      }
    };
    var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
      var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
      totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
      animation._dur = dur;
      animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
      totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
      animation.parent && _setEnd(animation);
      skipUncache || _uncache(animation.parent, animation);
      return animation;
    };
    var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
      return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
    };
    var _zeroPosition = {
      _start: 0,
      endTime: _emptyFunc,
      totalDuration: _emptyFunc
    };
    var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
      var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i2, offset2, isPercent;
      if (_isString(position) && (isNaN(position) || position in labels)) {
        offset2 = position.charAt(0);
        isPercent = position.substr(-1) === "%";
        i2 = position.indexOf("=");
        if (offset2 === "<" || offset2 === ">") {
          i2 >= 0 && (position = position.replace(/=/, ""));
          return (offset2 === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i2 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
        }
        if (i2 < 0) {
          position in labels || (labels[position] = clippedDuration);
          return labels[position];
        }
        offset2 = parseFloat(position.charAt(i2 - 1) + position.substr(i2 + 1));
        if (isPercent && percentAnimation) {
          offset2 = offset2 / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
        }
        return i2 > 1 ? _parsePosition2(animation, position.substr(0, i2 - 1), percentAnimation) + offset2 : clippedDuration + offset2;
      }
      return position == null ? clippedDuration : +position;
    };
    var _createTweenType = function _createTweenType2(type, params, timeline2) {
      var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
      isLegacy && (vars.duration = params[1]);
      vars.parent = timeline2;
      if (type) {
        irVars = vars;
        parent2 = timeline2;
        while (parent2 && !("immediateRender" in irVars)) {
          irVars = parent2.vars.defaults || {};
          parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
        }
        vars.immediateRender = _isNotFalse(irVars.immediateRender);
        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
      }
      return new Tween(params[0], vars, params[varsIndex + 1]);
    };
    var _conditionalReturn = function _conditionalReturn2(value, func) {
      return value || value === 0 ? func(value) : func;
    };
    var _clamp = function _clamp2(min, max, value) {
      return value < min ? min : value > max ? max : value;
    };
    var getUnit = function getUnit2(value, v) {
      return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
    };
    var clamp = function clamp2(min, max, value) {
      return _conditionalReturn(value, function(v) {
        return _clamp(min, max, v);
      });
    };
    var _slice = [].slice;
    var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
      return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
    };
    var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
      if (accumulator === void 0) {
        accumulator = [];
      }
      return ar.forEach(function(value) {
        var _accumulator;
        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
      }) || accumulator;
    };
    var toArray = function toArray2(value, scope, leaveStrings) {
      return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
    };
    var selector = function selector2(value) {
      value = toArray(value)[0] || _warn("Invalid scope") || {};
      return function(v) {
        var el = value.current || value.nativeElement || value;
        return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
      };
    };
    var shuffle = function shuffle2(a) {
      return a.sort(function() {
        return 0.5 - Math.random();
      });
    };
    var distribute = function distribute2(v) {
      if (_isFunction(v)) {
        return v;
      }
      var vars = _isObject(v) ? v : {
        each: v
      }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
      if (_isString(from)) {
        ratioX = ratioY = {
          center: 0.5,
          edges: 0.5,
          end: 1
        }[from] || 0;
      } else if (!isDecimal && ratios) {
        ratioX = from[0];
        ratioY = from[1];
      }
      return function(i2, target, a) {
        var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
        if (!distances) {
          wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
          if (!wrapAt) {
            max = -_bigNum;
            while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
            }
            wrapAt--;
          }
          distances = cache[l] = [];
          originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
          originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
          max = 0;
          min = _bigNum;
          for (j = 0; j < l; j++) {
            x = j % wrapAt - originX;
            y = originY - (j / wrapAt | 0);
            distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
            d > max && (max = d);
            d < min && (min = d);
          }
          from === "random" && shuffle(distances);
          distances.max = max - min;
          distances.min = min;
          distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
          distances.b = l < 0 ? base - l : base;
          distances.u = getUnit(vars.amount || vars.each) || 0;
          ease = ease && l < 0 ? _invertEase(ease) : ease;
        }
        l = (distances[i2] - distances.min) / distances.max || 0;
        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
      };
    };
    var _roundModifier = function _roundModifier2(v) {
      var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
      return function(raw) {
        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
      };
    };
    var snap = function snap2(snapTo, value) {
      var isArray = _isArray(snapTo), radius, is2D;
      if (!isArray && _isObject(snapTo)) {
        radius = isArray = snapTo.radius || _bigNum;
        if (snapTo.values) {
          snapTo = toArray(snapTo.values);
          if (is2D = !_isNumber(snapTo[0])) {
            radius *= radius;
          }
        } else {
          snapTo = _roundModifier(snapTo.increment);
        }
      }
      return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
        is2D = snapTo(raw);
        return Math.abs(is2D - raw) <= radius ? is2D : raw;
      } : function(raw) {
        var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest2 = 0, i2 = snapTo.length, dx, dy;
        while (i2--) {
          if (is2D) {
            dx = snapTo[i2].x - x;
            dy = snapTo[i2].y - y;
            dx = dx * dx + dy * dy;
          } else {
            dx = Math.abs(snapTo[i2] - x);
          }
          if (dx < min) {
            min = dx;
            closest2 = i2;
          }
        }
        closest2 = !radius || min <= radius ? snapTo[closest2] : raw;
        return is2D || closest2 === raw || _isNumber(raw) ? closest2 : closest2 + getUnit(raw);
      });
    };
    var random = function random2(min, max, roundingIncrement, returnFunction) {
      return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
      });
    };
    var pipe = function pipe2() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }
      return function(value) {
        return functions.reduce(function(v, f) {
          return f(v);
        }, value);
      };
    };
    var unitize = function unitize2(func, unit) {
      return function(value) {
        return func(parseFloat(value)) + (unit || getUnit(value));
      };
    };
    var normalize = function normalize2(min, max, value) {
      return mapRange(min, max, 0, 1, value);
    };
    var _wrapArray = function _wrapArray2(a, wrapper, value) {
      return _conditionalReturn(value, function(index2) {
        return a[~~wrapper(index2)];
      });
    };
    var wrap = function wrap2(min, max, value) {
      var range = max - min;
      return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
        return (range + (value2 - min) % range) % range + min;
      });
    };
    var wrapYoyo = function wrapYoyo2(min, max, value) {
      var range = max - min, total = range * 2;
      return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
        value2 = (total + (value2 - min) % total) % total || 0;
        return min + (value2 > range ? total - value2 : value2);
      });
    };
    var _replaceRandom = function _replaceRandom2(value) {
      var prev2 = 0, s = "", i2, nums, end, isArray;
      while (~(i2 = value.indexOf("random(", prev2))) {
        end = value.indexOf(")", i2);
        isArray = value.charAt(i2 + 7) === "[";
        nums = value.substr(i2 + 7, end - i2 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
        s += value.substr(prev2, i2 - prev2) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
        prev2 = end + 1;
      }
      return s + value.substr(prev2, value.length - prev2);
    };
    var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
      var inRange = inMax - inMin, outRange = outMax - outMin;
      return _conditionalReturn(value, function(value2) {
        return outMin + ((value2 - inMin) / inRange * outRange || 0);
      });
    };
    var interpolate = function interpolate2(start, end, progress, mutate) {
      var func = isNaN(start + end) ? 0 : function(p2) {
        return (1 - p2) * start + p2 * end;
      };
      if (!func) {
        var isString = _isString(start), master = {}, p, i2, interpolators, l, il;
        progress === true && (mutate = 1) && (progress = null);
        if (isString) {
          start = {
            p: start
          };
          end = {
            p: end
          };
        } else if (_isArray(start) && !_isArray(end)) {
          interpolators = [];
          l = start.length;
          il = l - 2;
          for (i2 = 1; i2 < l; i2++) {
            interpolators.push(interpolate2(start[i2 - 1], start[i2]));
          }
          l--;
          func = function func2(p2) {
            p2 *= l;
            var i3 = Math.min(il, ~~p2);
            return interpolators[i3](p2 - i3);
          };
          progress = end;
        } else if (!mutate) {
          start = _merge(_isArray(start) ? [] : {}, start);
        }
        if (!interpolators) {
          for (p in end) {
            _addPropTween.call(master, start, p, "get", end[p]);
          }
          func = function func2(p2) {
            return _renderPropTweens(p2, master) || (isString ? start.p : start);
          };
        }
      }
      return _conditionalReturn(progress, func);
    };
    var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
      var labels = timeline2.labels, min = _bigNum, p, distance, label;
      for (p in labels) {
        distance = labels[p] - fromTime;
        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
          label = p;
          min = distance;
        }
      }
      return label;
    };
    var _callback = function _callback2(animation, type, executeLazyFirst) {
      var v = animation.vars, callback = v[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
      if (!callback) {
        return;
      }
      params = v[type + "Params"];
      scope = v.callbackScope || animation;
      executeLazyFirst && _lazyTweens.length && _lazyRender();
      context3 && (_context = context3);
      result = params ? callback.apply(scope, params) : callback.call(scope);
      _context = prevContext;
      return result;
    };
    var _interrupt = function _interrupt2(animation) {
      _removeFromParent(animation);
      animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
      animation.progress() < 1 && _callback(animation, "onInterrupt");
      return animation;
    };
    var _quickTween;
    var _createPlugin = function _createPlugin2(config3) {
      config3 = !config3.name && config3["default"] || config3;
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    };
    var _255 = 255;
    var _colorLookup = {
      aqua: [0, _255, _255],
      lime: [0, _255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _255],
      navy: [0, 0, 128],
      white: [_255, _255, _255],
      olive: [128, 128, 0],
      yellow: [_255, _255, 0],
      orange: [_255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_255, 0, 0],
      pink: [_255, 192, 203],
      cyan: [0, _255, _255],
      transparent: [_255, _255, _255, 0]
    };
    var _hue = function _hue2(h, m1, m2) {
      h += h < 0 ? 1 : h > 1 ? -1 : 0;
      return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
    };
    var splitColor = function splitColor2(v, toHSL, forceAlpha) {
      var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
      if (!a) {
        if (v.substr(-1) === ",") {
          v = v.substr(0, v.length - 1);
        }
        if (_colorLookup[v]) {
          a = _colorLookup[v];
        } else if (v.charAt(0) === "#") {
          if (v.length < 6) {
            r = v.charAt(1);
            g = v.charAt(2);
            b = v.charAt(3);
            v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
          }
          if (v.length === 9) {
            a = parseInt(v.substr(1, 6), 16);
            return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
          }
          v = parseInt(v.substr(1), 16);
          a = [v >> 16, v >> 8 & _255, v & _255];
        } else if (v.substr(0, 3) === "hsl") {
          a = wasHSL = v.match(_strictNumExp);
          if (!toHSL) {
            h = +a[0] % 360 / 360;
            s = +a[1] / 100;
            l = +a[2] / 100;
            g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
            r = l * 2 - g;
            a.length > 3 && (a[3] *= 1);
            a[0] = _hue(h + 1 / 3, r, g);
            a[1] = _hue(h, r, g);
            a[2] = _hue(h - 1 / 3, r, g);
          } else if (~v.indexOf("=")) {
            a = v.match(_numExp);
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
          }
        } else {
          a = v.match(_strictNumExp) || _colorLookup.transparent;
        }
        a = a.map(Number);
      }
      if (toHSL && !wasHSL) {
        r = a[0] / _255;
        g = a[1] / _255;
        b = a[2] / _255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h *= 60;
        }
        a[0] = ~~(h + 0.5);
        a[1] = ~~(s * 100 + 0.5);
        a[2] = ~~(l * 100 + 0.5);
      }
      forceAlpha && a.length < 4 && (a[3] = 1);
      return a;
    };
    var _colorOrderData = function _colorOrderData2(v) {
      var values = [], c = [], i2 = -1;
      v.split(_colorExp).forEach(function(v2) {
        var a = v2.match(_numWithUnitExp) || [];
        values.push.apply(values, a);
        c.push(i2 += a.length + 1);
      });
      values.c = c;
      return values;
    };
    var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
      var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i2 = 0, c, shell, d, l;
      if (!colors) {
        return s;
      }
      colors = colors.map(function(color) {
        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
      });
      if (orderMatchData) {
        d = _colorOrderData(s);
        c = orderMatchData.c;
        if (c.join(result) !== d.c.join(result)) {
          shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
          l = shell.length - 1;
          for (; i2 < l; i2++) {
            result += shell[i2] + (~c.indexOf(i2) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
          }
        }
      }
      if (!shell) {
        shell = s.split(_colorExp);
        l = shell.length - 1;
        for (; i2 < l; i2++) {
          result += shell[i2] + colors[i2];
        }
      }
      return result + shell[l];
    };
    var _colorExp = function() {
      var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
      for (p in _colorLookup) {
        s += "|" + p + "\\b";
      }
      return new RegExp(s + ")", "gi");
    }();
    var _hslExp = /hsl[a]?\(/;
    var _colorStringFilter = function _colorStringFilter2(a) {
      var combined = a.join(" "), toHSL;
      _colorExp.lastIndex = 0;
      if (_colorExp.test(combined)) {
        toHSL = _hslExp.test(combined);
        a[1] = _formatColors(a[1], toHSL);
        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
        return true;
      }
    };
    var _tickerActive;
    var _ticker = function() {
      var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id2, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {
        var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1e3;
          _self.time = time = time / 1e3;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
        manual || (_id2 = _req(_tick2));
        if (dispatch) {
          for (_i = 0; _i < _listeners2.length; _i++) {
            _listeners2[_i](time, _delta, frame, v);
          }
        }
      };
      _self = {
        time: 0,
        frame: 0,
        tick: function tick() {
          _tick(true);
        },
        deltaRatio: function deltaRatio(fps) {
          return _delta / (1e3 / (fps || 60));
        },
        wake: function wake() {
          if (_coreReady) {
            if (!_coreInitted && _windowExists()) {
              _win = _coreInitted = window;
              _doc = _win.document || {};
              _globals.gsap = gsap;
              (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
              _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
              _raf = _win.requestAnimationFrame;
            }
            _id2 && _self.sleep();
            _req = _raf || function(f) {
              return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
            };
            _tickerActive = 1;
            _tick(2);
          }
        },
        sleep: function sleep() {
          (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id2);
          _tickerActive = 0;
          _req = _emptyFunc;
        },
        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
          _lagThreshold = threshold || 1 / _tinyNum;
          _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
        },
        fps: function fps(_fps) {
          _gap = 1e3 / (_fps || 240);
          _nextTime = _self.time * 1e3 + _gap;
        },
        add: function add(callback, once, prioritize) {
          var func = once ? function(t, d, f, v) {
            callback(t, d, f, v);
            _self.remove(func);
          } : callback;
          _self.remove(callback);
          _listeners2[prioritize ? "unshift" : "push"](func);
          _wake();
          return func;
        },
        remove: function remove2(callback, i2) {
          ~(i2 = _listeners2.indexOf(callback)) && _listeners2.splice(i2, 1) && _i >= i2 && _i--;
        },
        _listeners: _listeners2
      };
      return _self;
    }();
    var _wake = function _wake2() {
      return !_tickerActive && _ticker.wake();
    };
    var _easeMap = {};
    var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
    var _quotesExp = /["']/g;
    var _parseObjectInString = function _parseObjectInString2(value) {
      var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i2 = 1, l = split.length, index2, val, parsedVal;
      for (; i2 < l; i2++) {
        val = split[i2];
        index2 = i2 !== l - 1 ? val.lastIndexOf(",") : val.length;
        parsedVal = val.substr(0, index2);
        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
        key = val.substr(index2 + 1).trim();
      }
      return obj;
    };
    var _valueInParentheses = function _valueInParentheses2(value) {
      var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
      return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
    };
    var _configEaseFromString = function _configEaseFromString2(name) {
      var split = (name + "").split("("), ease = _easeMap[split[0]];
      return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
    };
    var _invertEase = function _invertEase2(ease) {
      return function(p) {
        return 1 - ease(1 - p);
      };
    };
    var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
      var child = timeline2._first, ease;
      while (child) {
        if (child instanceof Timeline) {
          _propagateYoyoEase2(child, isYoyo);
        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
          if (child.timeline) {
            _propagateYoyoEase2(child.timeline, isYoyo);
          } else {
            ease = child._ease;
            child._ease = child._yEase;
            child._yEase = ease;
            child._yoyo = isYoyo;
          }
        }
        child = child._next;
      }
    };
    var _parseEase = function _parseEase2(ease, defaultEase) {
      return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
    };
    var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
      if (easeOut === void 0) {
        easeOut = function easeOut2(p) {
          return 1 - easeIn(1 - p);
        };
      }
      if (easeInOut === void 0) {
        easeInOut = function easeInOut2(p) {
          return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
        };
      }
      var ease = {
        easeIn,
        easeOut,
        easeInOut
      }, lowercaseName;
      _forEachName(names, function(name) {
        _easeMap[name] = _globals[name] = ease;
        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
        for (var p in ease) {
          _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
        }
      });
      return ease;
    };
    var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
      return function(p) {
        return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
      };
    };
    var _configElastic = function _configElastic2(type, amplitude, period) {
      var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
      p2 = _2PI / p2;
      ease.config = function(amplitude2, period2) {
        return _configElastic2(type, amplitude2, period2);
      };
      return ease;
    };
    var _configBack = function _configBack2(type, overshoot) {
      if (overshoot === void 0) {
        overshoot = 1.70158;
      }
      var easeOut = function easeOut2(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
      ease.config = function(overshoot2) {
        return _configBack2(type, overshoot2);
      };
      return ease;
    };
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i2) {
      var power = i2 < 5 ? i2 + 1 : i2;
      _insertEase(name + ",Power" + (power - 1), i2 ? function(p) {
        return Math.pow(p, power);
      } : function(p) {
        return p;
      }, function(p) {
        return 1 - Math.pow(1 - p, power);
      }, function(p) {
        return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
      });
    });
    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
    (function(n, c) {
      var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
      };
      _insertEase("Bounce", function(p) {
        return 1 - easeOut(1 - p);
      }, easeOut);
    })(7.5625, 2.75);
    _insertEase("Expo", function(p) {
      return p ? Math.pow(2, 10 * (p - 1)) : 0;
    });
    _insertEase("Circ", function(p) {
      return -(_sqrt(1 - p * p) - 1);
    });
    _insertEase("Sine", function(p) {
      return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
    });
    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
        if (steps === void 0) {
          steps = 1;
        }
        var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
        return function(p) {
          return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
        };
      }
    };
    _defaults.ease = _easeMap["quad.out"];
    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
      return _callbackNames += name + "," + name + "Params,";
    });
    var GSCache = function GSCache2(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter;
    };
    var Animation = /* @__PURE__ */ function() {
      function Animation2(vars) {
        this.vars = vars;
        this._delay = +vars.delay || 0;
        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
          this._rDelay = vars.repeatDelay || 0;
          this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
        }
        this._ts = 1;
        _setDuration(this, +vars.duration, 1, 1);
        this.data = vars.data;
        if (_context) {
          this._ctx = _context;
          _context.data.push(this);
        }
        _tickerActive || _ticker.wake();
      }
      var _proto = Animation2.prototype;
      _proto.delay = function delay3(value) {
        if (value || value === 0) {
          this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
          this._delay = value;
          return this;
        }
        return this._delay;
      };
      _proto.duration = function duration(value) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
      };
      _proto.totalDuration = function totalDuration(value) {
        if (!arguments.length) {
          return this._tDur;
        }
        this._dirty = 0;
        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
      };
      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
        _wake();
        if (!arguments.length) {
          return this._tTime;
        }
        var parent2 = this._dp;
        if (parent2 && parent2.smoothChildTiming && this._ts) {
          _alignPlayhead(this, _totalTime);
          !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
          while (parent2 && parent2.parent) {
            if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
              parent2.totalTime(parent2._tTime, true);
            }
            parent2 = parent2.parent;
          }
          if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
            _addToTimeline(this._dp, this, this._start - this._delay);
          }
        }
        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
          this._ts || (this._pTime = _totalTime);
          _lazySafeRender(this, _totalTime, suppressEvents);
        }
        return this;
      };
      _proto.time = function time(value, suppressEvents) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
      };
      _proto.totalProgress = function totalProgress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
      };
      _proto.progress = function progress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
      };
      _proto.iteration = function iteration(value, suppressEvents) {
        var cycleDuration = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
      };
      _proto.timeScale = function timeScale(value) {
        if (!arguments.length) {
          return this._rts === -_tinyNum ? 0 : this._rts;
        }
        if (this._rts === value) {
          return this;
        }
        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
        this._rts = +value || 0;
        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
        this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);
        _setEnd(this);
        return _recacheAncestors(this);
      };
      _proto.paused = function paused(value) {
        if (!arguments.length) {
          return this._ps;
        }
        if (this._ps !== value) {
          this._ps = value;
          if (value) {
            this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
            this._ts = this._act = 0;
          } else {
            _wake();
            this._ts = this._rts;
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
          }
        }
        return this;
      };
      _proto.startTime = function startTime(value) {
        if (arguments.length) {
          this._start = value;
          var parent2 = this.parent || this._dp;
          parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value - this._delay);
          return this;
        }
        return this._start;
      };
      _proto.endTime = function endTime(includeRepeats) {
        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
      };
      _proto.rawTime = function rawTime(wrapRepeats) {
        var parent2 = this.parent || this._dp;
        return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
      };
      _proto.revert = function revert(config3) {
        if (config3 === void 0) {
          config3 = _revertConfig;
        }
        var prevIsReverting = _reverting;
        _reverting = config3;
        if (this._initted || this._startAt) {
          this.timeline && this.timeline.revert(config3);
          this.totalTime(-0.01, config3.suppressEvents);
        }
        this.data !== "nested" && config3.kill !== false && this.kill();
        _reverting = prevIsReverting;
        return this;
      };
      _proto.globalTime = function globalTime(rawTime) {
        var animation = this, time = arguments.length ? rawTime : animation.rawTime();
        while (animation) {
          time = animation._start + time / (animation._ts || 1);
          animation = animation._dp;
        }
        return !this.parent && this.vars.immediateRender ? -1 : time;
      };
      _proto.repeat = function repeat(value) {
        if (arguments.length) {
          this._repeat = value === Infinity ? -2 : value;
          return _onUpdateTotalDuration(this);
        }
        return this._repeat === -2 ? Infinity : this._repeat;
      };
      _proto.repeatDelay = function repeatDelay(value) {
        if (arguments.length) {
          var time = this._time;
          this._rDelay = value;
          _onUpdateTotalDuration(this);
          return time ? this.time(time) : this;
        }
        return this._rDelay;
      };
      _proto.yoyo = function yoyo(value) {
        if (arguments.length) {
          this._yoyo = value;
          return this;
        }
        return this._yoyo;
      };
      _proto.seek = function seek(position, suppressEvents) {
        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
      };
      _proto.restart = function restart(includeDelay, suppressEvents) {
        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      };
      _proto.play = function play(from, suppressEvents) {
        from != null && this.seek(from, suppressEvents);
        return this.reversed(false).paused(false);
      };
      _proto.reverse = function reverse(from, suppressEvents) {
        from != null && this.seek(from || this.totalDuration(), suppressEvents);
        return this.reversed(true).paused(false);
      };
      _proto.pause = function pause(atTime, suppressEvents) {
        atTime != null && this.seek(atTime, suppressEvents);
        return this.paused(true);
      };
      _proto.resume = function resume() {
        return this.paused(false);
      };
      _proto.reversed = function reversed(value) {
        if (arguments.length) {
          !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
          return this;
        }
        return this._rts < 0;
      };
      _proto.invalidate = function invalidate() {
        this._initted = this._act = 0;
        this._zTime = -_tinyNum;
        return this;
      };
      _proto.isActive = function isActive() {
        var parent2 = this.parent || this._dp, start = this._start, rawTime;
        return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
      };
      _proto.eventCallback = function eventCallback(type, callback, params) {
        var vars = this.vars;
        if (arguments.length > 1) {
          if (!callback) {
            delete vars[type];
          } else {
            vars[type] = callback;
            params && (vars[type + "Params"] = params);
            type === "onUpdate" && (this._onUpdate = callback);
          }
          return this;
        }
        return vars[type];
      };
      _proto.then = function then(onFulfilled) {
        var self2 = this;
        return new Promise(function(resolve) {
          var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
            var _then = self2.then;
            self2.then = null;
            _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
            resolve(f);
            self2.then = _then;
          };
          if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
            _resolve();
          } else {
            self2._prom = _resolve;
          }
        });
      };
      _proto.kill = function kill() {
        _interrupt(this);
      };
      return Animation2;
    }();
    _setDefaults(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
    var Timeline = /* @__PURE__ */ function(_Animation) {
      _inheritsLoose(Timeline2, _Animation);
      function Timeline2(vars, position) {
        var _this;
        if (vars === void 0) {
          vars = {};
        }
        _this = _Animation.call(this, vars) || this;
        _this.labels = {};
        _this.smoothChildTiming = !!vars.smoothChildTiming;
        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
        _this._sort = _isNotFalse(vars.sortChildren);
        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
        vars.reversed && _this.reverse();
        vars.paused && _this.paused(true);
        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
        return _this;
      }
      var _proto2 = Timeline2.prototype;
      _proto2.to = function to(targets, vars, position) {
        _createTweenType(0, arguments, this);
        return this;
      };
      _proto2.from = function from(targets, vars, position) {
        _createTweenType(1, arguments, this);
        return this;
      };
      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
        _createTweenType(2, arguments, this);
        return this;
      };
      _proto2.set = function set(targets, vars, position) {
        vars.duration = 0;
        vars.parent = this;
        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
        vars.immediateRender = !!vars.immediateRender;
        new Tween(targets, vars, _parsePosition(this, position), 1);
        return this;
      };
      _proto2.call = function call(callback, params, position) {
        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
      };
      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.duration = duration;
        vars.stagger = vars.stagger || stagger;
        vars.onComplete = onCompleteAll;
        vars.onCompleteParams = onCompleteAllParams;
        vars.parent = this;
        new Tween(targets, vars, _parsePosition(this, position));
        return this;
      };
      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.runBackwards = 1;
        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
        toVars.startAt = fromVars;
        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
      _proto2.render = function render4(totalTime, suppressEvents, force) {
        var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next2, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
        if (tTime !== this._tTime || force || crossingStart) {
          if (prevTime !== this._time && dur) {
            tTime += this._time - prevTime;
            totalTime += this._time - prevTime;
          }
          time = tTime;
          prevStart = this._start;
          timeScale = this._ts;
          prevPaused = !timeScale;
          if (crossingStart) {
            dur || (prevTime = this._zTime);
            (totalTime || !suppressEvents) && (this._zTime = totalTime);
          }
          if (this._repeat) {
            yoyo = this._yoyo;
            cycleDuration = dur + this._rDelay;
            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
            time = _roundPrecise(tTime % cycleDuration);
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
              time > dur && (time = dur);
            }
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
            if (yoyo && iteration & 1) {
              time = dur - time;
              isYoyo = 1;
            }
            if (iteration !== prevIteration && !this._lock) {
              var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
              iteration < prevIteration && (rewinding = !rewinding);
              prevTime = rewinding ? 0 : dur;
              this._lock = 1;
              this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
              this._tTime = tTime;
              !suppressEvents && this.parent && _callback(this, "onRepeat");
              this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
              if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                return this;
              }
              dur = this._dur;
              tDur = this._tDur;
              if (doesWrap) {
                this._lock = 2;
                prevTime = rewinding ? dur : -1e-4;
                this.render(prevTime, true);
                this.vars.repeatRefresh && !isYoyo && this.invalidate();
              }
              this._lock = 0;
              if (!this._ts && !prevPaused) {
                return this;
              }
              _propagateYoyoEase(this, isYoyo);
            }
          }
          if (this._hasPause && !this._forcing && this._lock < 2) {
            pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
            if (pauseTween) {
              tTime -= time - (time = pauseTween._start);
            }
          }
          this._tTime = tTime;
          this._time = time;
          this._act = !timeScale;
          if (!this._initted) {
            this._onUpdate = this.vars.onUpdate;
            this._initted = 1;
            this._zTime = totalTime;
            prevTime = 0;
          }
          if (!prevTime && time && !suppressEvents) {
            _callback(this, "onStart");
            if (this._tTime !== tTime) {
              return this;
            }
          }
          if (time >= prevTime && totalTime >= 0) {
            child = this._first;
            while (child) {
              next2 = child._next;
              if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next2 && (tTime += this._zTime = -_tinyNum);
                  break;
                }
              }
              child = next2;
            }
          } else {
            child = this._last;
            var adjustedTime = totalTime < 0 ? totalTime : time;
            while (child) {
              next2 = child._prev;
              if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next2 && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                  break;
                }
              }
              child = next2;
            }
          }
          if (pauseTween && !suppressEvents) {
            this.pause();
            pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
            if (this._ts) {
              this._start = prevStart;
              _setEnd(this);
              return this.render(totalTime, suppressEvents, force);
            }
          }
          this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
          if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
            if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
              if (!this._lock) {
                (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                  _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                  this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                }
              }
            }
          }
        }
        return this;
      };
      _proto2.add = function add(child, position) {
        var _this2 = this;
        _isNumber(position) || (position = _parsePosition(this, position, child));
        if (!(child instanceof Animation)) {
          if (_isArray(child)) {
            child.forEach(function(obj) {
              return _this2.add(obj, position);
            });
            return this;
          }
          if (_isString(child)) {
            return this.addLabel(child, position);
          }
          if (_isFunction(child)) {
            child = Tween.delayedCall(0, child);
          } else {
            return this;
          }
        }
        return this !== child ? _addToTimeline(this, child, position) : this;
      };
      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
        if (nested === void 0) {
          nested = true;
        }
        if (tweens === void 0) {
          tweens = true;
        }
        if (timelines === void 0) {
          timelines = true;
        }
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = -_bigNum;
        }
        var a = [], child = this._first;
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            if (child instanceof Tween) {
              tweens && a.push(child);
            } else {
              timelines && a.push(child);
              nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
            }
          }
          child = child._next;
        }
        return a;
      };
      _proto2.getById = function getById2(id2) {
        var animations = this.getChildren(1, 1, 1), i2 = animations.length;
        while (i2--) {
          if (animations[i2].vars.id === id2) {
            return animations[i2];
          }
        }
      };
      _proto2.remove = function remove2(child) {
        if (_isString(child)) {
          return this.removeLabel(child);
        }
        if (_isFunction(child)) {
          return this.killTweensOf(child);
        }
        _removeLinkedListItem(this, child);
        if (child === this._recent) {
          this._recent = this._last;
        }
        return _uncache(this);
      };
      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
        if (!arguments.length) {
          return this._tTime;
        }
        this._forcing = 1;
        if (!this._dp && this._ts) {
          this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
        }
        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
        this._forcing = 0;
        return this;
      };
      _proto2.addLabel = function addLabel(label, position) {
        this.labels[label] = _parsePosition(this, position);
        return this;
      };
      _proto2.removeLabel = function removeLabel(label) {
        delete this.labels[label];
        return this;
      };
      _proto2.addPause = function addPause(position, callback, params) {
        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
        t.data = "isPause";
        this._hasPause = 1;
        return _addToTimeline(this, t, _parsePosition(this, position));
      };
      _proto2.removePause = function removePause(position) {
        var child = this._first;
        position = _parsePosition(this, position);
        while (child) {
          if (child._start === position && child.data === "isPause") {
            _removeFromParent(child);
          }
          child = child._next;
        }
      };
      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        var tweens = this.getTweensOf(targets, onlyActive), i2 = tweens.length;
        while (i2--) {
          _overwritingTween !== tweens[i2] && tweens[i2].kill(targets, props);
        }
        return this;
      };
      _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
        var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children2;
        while (child) {
          if (child instanceof Tween) {
            if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
              a.push(child);
            }
          } else if ((children2 = child.getTweensOf(parsedTargets, onlyActive)).length) {
            a.push.apply(a, children2);
          }
          child = child._next;
        }
        return a;
      };
      _proto2.tweenTo = function tweenTo(position, vars) {
        vars = vars || {};
        var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();
            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }
            _onStart && _onStart.apply(tween, onStartParams || []);
          }
        }, vars));
        return immediateRender ? tween.render(0) : tween;
      };
      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
        return this.tweenTo(toPosition, _setDefaults({
          startAt: {
            time: _parsePosition(this, fromPosition)
          }
        }, vars));
      };
      _proto2.recent = function recent() {
        return this._recent;
      };
      _proto2.nextLabel = function nextLabel(afterTime) {
        if (afterTime === void 0) {
          afterTime = this._time;
        }
        return _getLabelInDirection(this, _parsePosition(this, afterTime));
      };
      _proto2.previousLabel = function previousLabel(beforeTime) {
        if (beforeTime === void 0) {
          beforeTime = this._time;
        }
        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
      };
      _proto2.currentLabel = function currentLabel(value) {
        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
      };
      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = 0;
        }
        var child = this._first, labels = this.labels, p;
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            child._start += amount;
            child._end += amount;
          }
          child = child._next;
        }
        if (adjustLabels) {
          for (p in labels) {
            if (labels[p] >= ignoreBeforeTime) {
              labels[p] += amount;
            }
          }
        }
        return _uncache(this);
      };
      _proto2.invalidate = function invalidate(soft) {
        var child = this._first;
        this._lock = 0;
        while (child) {
          child.invalidate(soft);
          child = child._next;
        }
        return _Animation.prototype.invalidate.call(this, soft);
      };
      _proto2.clear = function clear(includeLabels) {
        if (includeLabels === void 0) {
          includeLabels = true;
        }
        var child = this._first, next2;
        while (child) {
          next2 = child._next;
          this.remove(child);
          child = next2;
        }
        this._dp && (this._time = this._tTime = this._pTime = 0);
        includeLabels && (this.labels = {});
        return _uncache(this);
      };
      _proto2.totalDuration = function totalDuration(value) {
        var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev2, start, parent2;
        if (arguments.length) {
          return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
        }
        if (self2._dirty) {
          parent2 = self2.parent;
          while (child) {
            prev2 = child._prev;
            child._dirty && child.totalDuration();
            start = child._start;
            if (start > prevStart && self2._sort && child._ts && !self2._lock) {
              self2._lock = 1;
              _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
            } else {
              prevStart = start;
            }
            if (start < 0 && child._ts) {
              max -= start;
              if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
                self2._start += start / self2._ts;
                self2._time -= start;
                self2._tTime -= start;
              }
              self2.shiftChildren(-start, false, -Infinity);
              prevStart = 0;
            }
            child._end > max && child._ts && (max = child._end);
            child = prev2;
          }
          _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
          self2._dirty = 0;
        }
        return self2._tDur;
      };
      Timeline2.updateRoot = function updateRoot(time) {
        if (_globalTimeline._ts) {
          _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
          _lastRenderedFrame = _ticker.frame;
        }
        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var child = _globalTimeline._first;
          if (!child || !child._ts) {
            if (_config.autoSleep && _ticker._listeners.length < 2) {
              while (child && !child._ts) {
                child = child._next;
              }
              child || _ticker.sleep();
            }
          }
        }
      };
      return Timeline2;
    }(Animation);
    _setDefaults(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });
    var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
      var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index2 = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
      if (hasRandom = ~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (stringFilter) {
        a = [start, end];
        stringFilter(a, target, prop);
        start = a[0];
        end = a[1];
      }
      startNums = start.match(_complexStringNumExp) || [];
      while (result = _complexStringNumExp.exec(end)) {
        endNum = result[0];
        chunk = end.substring(index2, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(") {
          color = 1;
        }
        if (endNum !== startNums[matchIndex++]) {
          startNum = parseFloat(startNums[matchIndex - 1]) || 0;
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            s: startNum,
            c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
            m: color && color < 4 ? Math.round : 0
          };
          index2 = _complexStringNumExp.lastIndex;
        }
      }
      pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
      pt.fp = funcParam;
      if (_relExp.test(end) || hasRandom) {
        pt.e = 0;
      }
      this._pt = pt;
      return pt;
    };
    var _addPropTween = function _addPropTween2(target, prop, start, end, index2, targets, modifier2, stringFilter, funcParam, optional) {
      _isFunction(end) && (end = end(index2 || 0, target, targets));
      var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
      if (_isString(end)) {
        if (~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
        if (end.charAt(1) === "=") {
          pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
          if (pt || pt === 0) {
            end = pt;
          }
        }
      }
      if (!optional || parsedStart !== end || _forceAllPropTweens) {
        if (!isNaN(parsedStart * end) && end !== "") {
          pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
          funcParam && (pt.fp = funcParam);
          modifier2 && pt.modifier(modifier2, this, target);
          return this._pt = pt;
        }
        !currentValue && !(prop in target) && _missingPlugin(prop, end);
        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
      }
    };
    var _processVars = function _processVars2(vars, index2, target, targets, tween) {
      _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index2, target, targets));
      if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
        return _isString(vars) ? _parseFuncOrString(vars, tween, index2, target, targets) : vars;
      }
      var copy = {}, p;
      for (p in vars) {
        copy[p] = _parseFuncOrString(vars[p], tween, index2, target, targets);
      }
      return copy;
    };
    var _checkPlugin = function _checkPlugin2(property, vars, tween, index2, target, targets) {
      var plugin, pt, ptLookup, i2;
      if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index2, target, targets, tween), tween, index2, targets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
        if (tween !== _quickTween) {
          ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
          i2 = plugin._props.length;
          while (i2--) {
            ptLookup[plugin._props[i2]] = pt;
          }
        }
      }
      return plugin;
    };
    var _overwritingTween;
    var _forceAllPropTweens;
    var _initTween = function _initTween2(tween, time, tTime) {
      var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate2 = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i2, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index2, harnessVars, overwritten;
      tl && (!keyframes || !ease) && (ease = "none");
      tween._ease = _parseEase(ease, _defaults.ease);
      tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
      if (yoyoEase && tween._yoyo && !tween._repeat) {
        yoyoEase = tween._yEase;
        tween._yEase = tween._ease;
        tween._ease = yoyoEase;
      }
      tween._from = !tl && !!vars.runBackwards;
      if (!tl || keyframes && !vars.stagger) {
        harness = targets[0] ? _getCache(targets[0]).harness : 0;
        harnessVars = harness && vars[harness.prop];
        cleanVars = _copyExcluding(vars, _reservedProps);
        if (prevStartAt) {
          prevStartAt._zTime < 0 && prevStartAt.progress(1);
          time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
          prevStartAt._lazy = 0;
        }
        if (startAt) {
          _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
            data: "isStart",
            overwrite: false,
            parent: parent2,
            immediateRender: true,
            lazy: _isNotFalse(lazy),
            startAt: null,
            delay: 0,
            onUpdate: onUpdate2,
            onUpdateParams,
            callbackScope,
            stagger: 0
          }, startAt)));
          tween._startAt._dp = 0;
          time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
          if (immediateRender) {
            if (dur && time <= 0 && tTime <= 0) {
              time && (tween._zTime = time);
              return;
            }
          }
        } else if (runBackwards && dur) {
          if (!prevStartAt) {
            time && (immediateRender = false);
            p = _setDefaults({
              overwrite: false,
              data: "isFromStart",
              lazy: immediateRender && _isNotFalse(lazy),
              immediateRender,
              stagger: 0,
              parent: parent2
            }, cleanVars);
            harnessVars && (p[harness.prop] = harnessVars);
            _removeFromParent(tween._startAt = Tween.set(targets, p));
            tween._startAt._dp = 0;
            time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
            tween._zTime = time;
            if (!immediateRender) {
              _initTween2(tween._startAt, _tinyNum, _tinyNum);
            } else if (!time) {
              return;
            }
          }
        }
        tween._pt = tween._ptCache = 0;
        lazy = dur && _isNotFalse(lazy) || lazy && !dur;
        for (i2 = 0; i2 < targets.length; i2++) {
          target = targets[i2];
          gsData = target._gsap || _harness(targets)[i2]._gsap;
          tween._ptLookup[i2] = ptLookup = {};
          _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
          index2 = fullTargets === targets ? i2 : fullTargets.indexOf(target);
          if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index2, fullTargets) !== false) {
            tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
            plugin._props.forEach(function(name) {
              ptLookup[name] = pt;
            });
            plugin.priority && (hasPriority = 1);
          }
          if (!harness || harnessVars) {
            for (p in cleanVars) {
              if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index2, target, fullTargets))) {
                plugin.priority && (hasPriority = 1);
              } else {
                ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index2, fullTargets, 0, vars.stringFilter);
              }
            }
          }
          tween._op && tween._op[i2] && tween.kill(target, tween._op[i2]);
          if (autoOverwrite && tween._pt) {
            _overwritingTween = tween;
            _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
            overwritten = !tween.parent;
            _overwritingTween = 0;
          }
          tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
        }
        hasPriority && _sortPropTweensByPriority(tween);
        tween._onInit && tween._onInit(tween);
      }
      tween._onUpdate = onUpdate2;
      tween._initted = (!tween._op || tween._pt) && !overwritten;
      keyframes && time <= 0 && tl.render(_bigNum, true, true);
    };
    var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time) {
      var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i2;
      if (!ptCache) {
        ptCache = tween._ptCache[property] = [];
        lookup = tween._ptLookup;
        i2 = tween._targets.length;
        while (i2--) {
          pt = lookup[i2][property];
          if (pt && pt.d && pt.d._pt) {
            pt = pt.d._pt;
            while (pt && pt.p !== property && pt.fp !== property) {
              pt = pt._next;
            }
          }
          if (!pt) {
            _forceAllPropTweens = 1;
            tween.vars[property] = "+=0";
            _initTween(tween, time);
            _forceAllPropTweens = 0;
            return 1;
          }
          ptCache.push(pt);
        }
      }
      i2 = ptCache.length;
      while (i2--) {
        rootPT = ptCache[i2];
        pt = rootPT._pt || rootPT;
        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
        pt.c = value - pt.s;
        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
      }
    };
    var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
      var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i2, aliases;
      if (!propertyAliases) {
        return vars;
      }
      copy = _merge({}, vars);
      for (p in propertyAliases) {
        if (p in copy) {
          aliases = propertyAliases[p].split(",");
          i2 = aliases.length;
          while (i2--) {
            copy[aliases[i2]] = copy[p];
          }
        }
      }
      return copy;
    };
    var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
      var ease = obj.ease || easeEach || "power1.inOut", p, a;
      if (_isArray(obj)) {
        a = allProps[prop] || (allProps[prop] = []);
        obj.forEach(function(value, i2) {
          return a.push({
            t: i2 / (obj.length - 1) * 100,
            v: value,
            e: ease
          });
        });
      } else {
        for (p in obj) {
          a = allProps[p] || (allProps[p] = []);
          p === "ease" || a.push({
            t: parseFloat(prop),
            v: obj[p],
            e: ease
          });
        }
      }
    };
    var _parseFuncOrString = function _parseFuncOrString2(value, tween, i2, target, targets) {
      return _isFunction(value) ? value.call(tween, i2, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
    };
    var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
    var _staggerPropsToSkip = {};
    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
      return _staggerPropsToSkip[name] = 1;
    });
    var Tween = /* @__PURE__ */ function(_Animation2) {
      _inheritsLoose(Tween2, _Animation2);
      function Tween2(targets, vars, position, skipInherit) {
        var _this3;
        if (typeof vars === "number") {
          position.duration = vars;
          vars = position;
          position = null;
        }
        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
        var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay3 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults3 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i2, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
        _this3._ptLookup = [];
        _this3._overwrite = overwrite;
        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
          vars = _this3.vars;
          tl = _this3.timeline = new Timeline({
            data: "nested",
            defaults: defaults3 || {},
            targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
          });
          tl.kill();
          tl.parent = tl._dp = _assertThisInitialized(_this3);
          tl._start = 0;
          if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
            l = parsedTargets.length;
            staggerFunc = stagger && distribute(stagger);
            if (_isObject(stagger)) {
              for (p in stagger) {
                if (~_staggerTweenProps.indexOf(p)) {
                  staggerVarsToMerge || (staggerVarsToMerge = {});
                  staggerVarsToMerge[p] = stagger[p];
                }
              }
            }
            for (i2 = 0; i2 < l; i2++) {
              copy = _copyExcluding(vars, _staggerPropsToSkip);
              copy.stagger = 0;
              yoyoEase && (copy.yoyoEase = yoyoEase);
              staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
              curTarget = parsedTargets[i2];
              copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i2, curTarget, parsedTargets);
              copy.delay = (+_parseFuncOrString(delay3, _assertThisInitialized(_this3), i2, curTarget, parsedTargets) || 0) - _this3._delay;
              if (!stagger && l === 1 && copy.delay) {
                _this3._delay = delay3 = copy.delay;
                _this3._start += delay3;
                copy.delay = 0;
              }
              tl.to(curTarget, copy, staggerFunc ? staggerFunc(i2, curTarget, parsedTargets) : 0);
              tl._ease = _easeMap.none;
            }
            tl.duration() ? duration = delay3 = 0 : _this3.timeline = 0;
          } else if (keyframes) {
            _inheritDefaults(_setDefaults(tl.vars.defaults, {
              ease: "none"
            }));
            tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
            var time = 0, a, kf, v;
            if (_isArray(keyframes)) {
              keyframes.forEach(function(frame) {
                return tl.to(parsedTargets, frame, ">");
              });
              tl.duration();
            } else {
              copy = {};
              for (p in keyframes) {
                p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
              }
              for (p in copy) {
                a = copy[p].sort(function(a2, b) {
                  return a2.t - b.t;
                });
                time = 0;
                for (i2 = 0; i2 < a.length; i2++) {
                  kf = a[i2];
                  v = {
                    ease: kf.e,
                    duration: (kf.t - (i2 ? a[i2 - 1].t : 0)) / 100 * duration
                  };
                  v[p] = kf.v;
                  tl.to(parsedTargets, v, time);
                  time += v.duration;
                }
              }
              tl.duration() < duration && tl.to({}, {
                duration: duration - tl.duration()
              });
            }
          }
          duration || _this3.duration(duration = tl.duration());
        } else {
          _this3.timeline = 0;
        }
        if (overwrite === true && !_suppressOverwrites) {
          _overwritingTween = _assertThisInitialized(_this3);
          _globalTimeline.killTweensOf(parsedTargets);
          _overwritingTween = 0;
        }
        _addToTimeline(parent2, _assertThisInitialized(_this3), position);
        vars.reversed && _this3.reverse();
        vars.paused && _this3.paused(true);
        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
          _this3._tTime = -_tinyNum;
          _this3.render(Math.max(0, -delay3) || 0);
        }
        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
        return _this3;
      }
      var _proto3 = Tween2.prototype;
      _proto3.render = function render4(totalTime, suppressEvents, force) {
        var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
        if (!dur) {
          _renderZeroDurationTween(this, totalTime, suppressEvents, force);
        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
          time = tTime;
          timeline2 = this.timeline;
          if (this._repeat) {
            cycleDuration = dur + this._rDelay;
            if (this._repeat < -1 && isNegative) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
            time = _roundPrecise(tTime % cycleDuration);
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
              time > dur && (time = dur);
            }
            isYoyo = this._yoyo && iteration & 1;
            if (isYoyo) {
              yoyoEase = this._yEase;
              time = dur - time;
            }
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            if (time === prevTime && !force && this._initted) {
              this._tTime = tTime;
              return this;
            }
            if (iteration !== prevIteration) {
              timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
              if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                this._lock = force = 1;
                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
              }
            }
          }
          if (!this._initted) {
            if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
              this._tTime = 0;
              return this;
            }
            if (prevTime !== this._time) {
              return this;
            }
            if (dur !== this._dur) {
              return this.render(totalTime, suppressEvents, force);
            }
          }
          this._tTime = tTime;
          this._time = time;
          if (!this._act && this._ts) {
            this._act = 1;
            this._lazy = 0;
          }
          this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
          if (this._from) {
            this.ratio = ratio = 1 - ratio;
          }
          if (time && !prevTime && !suppressEvents) {
            _callback(this, "onStart");
            if (this._tTime !== tTime) {
              return this;
            }
          }
          pt = this._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          timeline2 && timeline2.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
          if (this._onUpdate && !suppressEvents) {
            isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
            _callback(this, "onUpdate");
          }
          this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
          if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
            isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
            (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
            if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
              _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
        return this;
      };
      _proto3.targets = function targets() {
        return this._targets;
      };
      _proto3.invalidate = function invalidate(soft) {
        (!soft || !this.vars.runBackwards) && (this._startAt = 0);
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
        this._ptLookup = [];
        this.timeline && this.timeline.invalidate(soft);
        return _Animation2.prototype.invalidate.call(this, soft);
      };
      _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
        _tickerActive || _ticker.wake();
        this._ts || this.play();
        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
        this._initted || _initTween(this, time);
        ratio = this._ease(time / this._dur);
        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
          return this.resetTo(property, value, start, startIsRelative);
        }
        _alignPlayhead(this, 0);
        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
        return this.render(0);
      };
      _proto3.kill = function kill(targets, vars) {
        if (vars === void 0) {
          vars = "all";
        }
        if (!targets && (!vars || vars === "all")) {
          this._lazy = this._pt = 0;
          return this.parent ? _interrupt(this) : this;
        }
        if (this.timeline) {
          var tDur = this.timeline.totalDuration();
          this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
          this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
          return this;
        }
        var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i2;
        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
          vars === "all" && (this._pt = 0);
          return _interrupt(this);
        }
        overwrittenProps = this._op = this._op || [];
        if (vars !== "all") {
          if (_isString(vars)) {
            p = {};
            _forEachName(vars, function(name) {
              return p[name] = 1;
            });
            vars = p;
          }
          vars = _addAliasesToVars(parsedTargets, vars);
        }
        i2 = parsedTargets.length;
        while (i2--) {
          if (~killingTargets.indexOf(parsedTargets[i2])) {
            curLookup = propTweenLookup[i2];
            if (vars === "all") {
              overwrittenProps[i2] = vars;
              props = curLookup;
              curOverwriteProps = {};
            } else {
              curOverwriteProps = overwrittenProps[i2] = overwrittenProps[i2] || {};
              props = vars;
            }
            for (p in props) {
              pt = curLookup && curLookup[p];
              if (pt) {
                if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                  _removeLinkedListItem(this, pt, "_pt");
                }
                delete curLookup[p];
              }
              if (curOverwriteProps !== "all") {
                curOverwriteProps[p] = 1;
              }
            }
          }
        }
        this._initted && !this._pt && firstPT && _interrupt(this);
        return this;
      };
      Tween2.to = function to(targets, vars) {
        return new Tween2(targets, vars, arguments[2]);
      };
      Tween2.from = function from(targets, vars) {
        return _createTweenType(1, arguments);
      };
      Tween2.delayedCall = function delayedCall(delay3, callback, params, scope) {
        return new Tween2(callback, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay: delay3,
          onComplete: callback,
          onReverseComplete: callback,
          onCompleteParams: params,
          onReverseCompleteParams: params,
          callbackScope: scope
        });
      };
      Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
        return _createTweenType(2, arguments);
      };
      Tween2.set = function set(targets, vars) {
        vars.duration = 0;
        vars.repeatDelay || (vars.repeat = 0);
        return new Tween2(targets, vars);
      };
      Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        return _globalTimeline.killTweensOf(targets, props, onlyActive);
      };
      return Tween2;
    }(Animation);
    _setDefaults(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    });
    _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
      Tween[name] = function() {
        var tl = new Timeline(), params = _slice.call(arguments, 0);
        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
        return tl[name].apply(tl, params);
      };
    });
    var _setterPlain = function _setterPlain2(target, property, value) {
      return target[property] = value;
    };
    var _setterFunc = function _setterFunc2(target, property, value) {
      return target[property](value);
    };
    var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
      return target[property](data.fp, value);
    };
    var _setterAttribute = function _setterAttribute2(target, property, value) {
      return target.setAttribute(property, value);
    };
    var _getSetter = function _getSetter2(target, property) {
      return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
    };
    var _renderPlain = function _renderPlain2(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
    };
    var _renderBoolean = function _renderBoolean2(ratio, data) {
      return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
    };
    var _renderComplexString = function _renderComplexString2(ratio, data) {
      var pt = data._pt, s = "";
      if (!ratio && data.b) {
        s = data.b;
      } else if (ratio === 1 && data.e) {
        s = data.e;
      } else {
        while (pt) {
          s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
          pt = pt._next;
        }
        s += data.c;
      }
      data.set(data.t, data.p, s, data);
    };
    var _renderPropTweens = function _renderPropTweens2(ratio, data) {
      var pt = data._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    };
    var _addPluginModifier = function _addPluginModifier2(modifier2, tween, target, property) {
      var pt = this._pt, next2;
      while (pt) {
        next2 = pt._next;
        pt.p === property && pt.modifier(modifier2, tween, target);
        pt = next2;
      }
    };
    var _killPropTweensOf = function _killPropTweensOf2(property) {
      var pt = this._pt, hasNonDependentRemaining, next2;
      while (pt) {
        next2 = pt._next;
        if (pt.p === property && !pt.op || pt.op === property) {
          _removeLinkedListItem(this, pt, "_pt");
        } else if (!pt.dep) {
          hasNonDependentRemaining = 1;
        }
        pt = next2;
      }
      return !hasNonDependentRemaining;
    };
    var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
      data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
    };
    var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
      var pt = parent2._pt, next2, pt2, first, last;
      while (pt) {
        next2 = pt._next;
        pt2 = first;
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
        pt = next2;
      }
      parent2._pt = first;
    };
    var PropTween = /* @__PURE__ */ function() {
      function PropTween2(next2, target, prop, start, change2, renderer, data, setter, priority) {
        this.t = target;
        this.s = start;
        this.c = change2;
        this.p = prop;
        this.r = renderer || _renderPlain;
        this.d = data || this;
        this.set = setter || _setterPlain;
        this.pr = priority || 0;
        this._next = next2;
        if (next2) {
          next2._prev = this;
        }
      }
      var _proto4 = PropTween2.prototype;
      _proto4.modifier = function modifier2(func, tween, target) {
        this.mSet = this.mSet || this.set;
        this.set = _setterWithModifier;
        this.m = func;
        this.mt = target;
        this.tween = tween;
      };
      return PropTween2;
    }();
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
      return _reservedProps[name] = 1;
    });
    _globals.TweenMax = _globals.TweenLite = Tween;
    _globals.TimelineLite = _globals.TimelineMax = Timeline;
    _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    });
    _config.stringFilter = _colorStringFilter;
    var _media = [];
    var _listeners = {};
    var _emptyArray = [];
    var _lastMediaTime = 0;
    var _dispatch = function _dispatch2(type) {
      return (_listeners[type] || _emptyArray).map(function(f) {
        return f();
      });
    };
    var _onMediaChange = function _onMediaChange2() {
      var time = Date.now(), matches2 = [];
      if (time - _lastMediaTime > 2) {
        _dispatch("matchMediaInit");
        _media.forEach(function(c) {
          var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
          for (p in queries) {
            match = _win.matchMedia(queries[p]).matches;
            match && (anyMatch = 1);
            if (match !== conditions[p]) {
              conditions[p] = match;
              toggled = 1;
            }
          }
          if (toggled) {
            c.revert();
            anyMatch && matches2.push(c);
          }
        });
        _dispatch("matchMediaRevert");
        matches2.forEach(function(c) {
          return c.onMatch(c);
        });
        _lastMediaTime = time;
        _dispatch("matchMedia");
      }
    };
    var Context = /* @__PURE__ */ function() {
      function Context2(func, scope) {
        this.selector = scope && selector(scope);
        this.data = [];
        this._r = [];
        this.isReverted = false;
        func && this.add(func);
      }
      var _proto5 = Context2.prototype;
      _proto5.add = function add(name, func, scope) {
        if (_isFunction(name)) {
          scope = func;
          func = name;
          name = _isFunction;
        }
        var self2 = this, f = function f2() {
          var prev2 = _context, prevSelector = self2.selector, result;
          prev2 && prev2 !== self2 && prev2.data.push(self2);
          scope && (self2.selector = selector(scope));
          _context = self2;
          result = func.apply(self2, arguments);
          _isFunction(result) && self2._r.push(result);
          _context = prev2;
          self2.selector = prevSelector;
          self2.isReverted = false;
          return result;
        };
        self2.last = f;
        return name === _isFunction ? f(self2) : name ? self2[name] = f : f;
      };
      _proto5.ignore = function ignore(func) {
        var prev2 = _context;
        _context = null;
        func(this);
        _context = prev2;
      };
      _proto5.getTweens = function getTweens() {
        var a = [];
        this.data.forEach(function(e) {
          return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
        });
        return a;
      };
      _proto5.clear = function clear() {
        this._r.length = this.data.length = 0;
      };
      _proto5.kill = function kill(revert, matchMedia2) {
        var _this4 = this;
        if (revert) {
          var tweens = this.getTweens();
          this.data.forEach(function(t) {
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          });
          tweens.map(function(t) {
            return {
              g: t.globalTime(0),
              t
            };
          }).sort(function(a, b) {
            return b.g - a.g || -1;
          }).forEach(function(o) {
            return o.t.revert(revert);
          });
          this.data.forEach(function(e) {
            return !(e instanceof Animation) && e.revert && e.revert(revert);
          });
          this._r.forEach(function(f) {
            return f(revert, _this4);
          });
          this.isReverted = true;
        } else {
          this.data.forEach(function(e) {
            return e.kill && e.kill();
          });
        }
        this.clear();
        if (matchMedia2) {
          var i2 = _media.indexOf(this);
          !!~i2 && _media.splice(i2, 1);
        }
      };
      _proto5.revert = function revert(config3) {
        this.kill(config3 || {});
      };
      return Context2;
    }();
    var MatchMedia = /* @__PURE__ */ function() {
      function MatchMedia2(scope) {
        this.contexts = [];
        this.scope = scope;
      }
      var _proto6 = MatchMedia2.prototype;
      _proto6.add = function add(conditions, func, scope) {
        _isObject(conditions) || (conditions = {
          matches: conditions
        });
        var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
        this.contexts.push(context3);
        func = context3.add("onMatch", func);
        context3.queries = conditions;
        for (p in conditions) {
          if (p === "all") {
            active = 1;
          } else {
            mq = _win.matchMedia(conditions[p]);
            if (mq) {
              _media.indexOf(context3) < 0 && _media.push(context3);
              (cond[p] = mq.matches) && (active = 1);
              mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
            }
          }
        }
        active && func(context3);
        return this;
      };
      _proto6.revert = function revert(config3) {
        this.kill(config3 || {});
      };
      _proto6.kill = function kill(revert) {
        this.contexts.forEach(function(c) {
          return c.kill(revert, true);
        });
      };
      return MatchMedia2;
    }();
    var _gsap = {
      registerPlugin: function registerPlugin() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        args.forEach(function(config3) {
          return _createPlugin(config3);
        });
      },
      timeline: function timeline(vars) {
        return new Timeline(vars);
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
        return _globalTimeline.getTweensOf(targets, onlyActive);
      },
      getProperty: function getProperty(target, property, unit, uncache) {
        _isString(target) && (target = toArray(target)[0]);
        var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
        unit === "native" && (unit = "");
        return !target ? target : !property ? function(property2, unit2, uncache2) {
          return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      },
      quickSetter: function quickSetter(target, property, unit) {
        target = toArray(target);
        if (target.length > 1) {
          var setters = target.map(function(t) {
            return gsap.quickSetter(t, property, unit);
          }), l = setters.length;
          return function(value) {
            var i2 = l;
            while (i2--) {
              setters[i2](value);
            }
          };
        }
        target = target[0] || {};
        var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
          var p2 = new Plugin();
          _quickTween._pt = 0;
          p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
          p2.render(1, p2);
          _quickTween._pt && _renderPropTweens(1, _quickTween);
        } : cache.set(target, p);
        return Plugin ? setter : function(value) {
          return setter(target, p, unit ? value + unit : value, cache, 1);
        };
      },
      quickTo: function quickTo(target, property, vars) {
        var _merge22;
        var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
          return tween.resetTo(property, value, start, startIsRelative);
        };
        func.tween = tween;
        return func;
      },
      isTweening: function isTweening(targets) {
        return _globalTimeline.getTweensOf(targets, true).length > 0;
      },
      defaults: function defaults(value) {
        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
        return _mergeDeep(_defaults, value || {});
      },
      config: function config2(value) {
        return _mergeDeep(_config, value || {});
      },
      registerEffect: function registerEffect(_ref3) {
        var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults3 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
        (plugins || "").split(",").forEach(function(pluginName) {
          return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
        });
        _effects[name] = function(targets, vars, tl) {
          return effect(toArray(targets), _setDefaults(vars || {}, defaults3), tl);
        };
        if (extendTimeline) {
          Timeline.prototype[name] = function(targets, vars, position) {
            return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
          };
        }
      },
      registerEase: function registerEase(name, ease) {
        _easeMap[name] = _parseEase(ease);
      },
      parseEase: function parseEase(ease, defaultEase) {
        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
      },
      getById: function getById(id2) {
        return _globalTimeline.getById(id2);
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
        if (vars === void 0) {
          vars = {};
        }
        var tl = new Timeline(vars), child, next2;
        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
        _globalTimeline.remove(tl);
        tl._dp = 0;
        tl._time = tl._tTime = _globalTimeline._time;
        child = _globalTimeline._first;
        while (child) {
          next2 = child._next;
          if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
            _addToTimeline(tl, child, child._start - child._delay);
          }
          child = next2;
        }
        _addToTimeline(_globalTimeline, tl, 0);
        return tl;
      },
      context: function context(func, scope) {
        return func ? new Context(func, scope) : _context;
      },
      matchMedia: function matchMedia(scope) {
        return new MatchMedia(scope);
      },
      matchMediaRefresh: function matchMediaRefresh() {
        return _media.forEach(function(c) {
          var cond = c.conditions, found, p;
          for (p in cond) {
            if (cond[p]) {
              cond[p] = false;
              found = 1;
            }
          }
          found && c.revert();
        }) || _onMediaChange();
      },
      addEventListener: function addEventListener(type, callback) {
        var a = _listeners[type] || (_listeners[type] = []);
        ~a.indexOf(callback) || a.push(callback);
      },
      removeEventListener: function removeEventListener(type, callback) {
        var a = _listeners[type], i2 = a && a.indexOf(callback);
        i2 >= 0 && a.splice(i2, 1);
      },
      utils: {
        wrap,
        wrapYoyo,
        distribute,
        random,
        snap,
        normalize,
        getUnit,
        clamp,
        splitColor,
        toArray,
        selector,
        mapRange,
        pipe,
        unitize,
        interpolate,
        shuffle
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
        PropTween,
        globals: _addGlobal,
        Tween,
        Timeline,
        Animation,
        getCache: _getCache,
        _removeLinkedListItem,
        reverting: function reverting() {
          return _reverting;
        },
        context: function context2(toAdd) {
          if (toAdd && _context) {
            _context.data.push(toAdd);
            toAdd._ctx = _context;
          }
          return _context;
        },
        suppressOverwrites: function suppressOverwrites(value) {
          return _suppressOverwrites = value;
        }
      }
    };
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
      return _gsap[name] = Tween[name];
    });
    _ticker.add(Timeline.updateRoot);
    _quickTween = _gsap.to({}, {
      duration: 0
    });
    var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
      var pt = plugin._pt;
      while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
        pt = pt._next;
      }
      return pt;
    };
    var _addModifiers = function _addModifiers2(tween, modifiers) {
      var targets = tween._targets, p, i2, pt;
      for (p in modifiers) {
        i2 = targets.length;
        while (i2--) {
          pt = tween._ptLookup[i2][p];
          if (pt && (pt = pt.d)) {
            if (pt._pt) {
              pt = _getPluginPropTween(pt, p);
            }
            pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i2], p);
          }
        }
      }
    };
    var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier2) {
      return {
        name,
        rawVars: 1,
        init: function init6(target, vars, tween) {
          tween._onInit = function(tween2) {
            var temp, p;
            if (_isString(vars)) {
              temp = {};
              _forEachName(vars, function(name2) {
                return temp[name2] = 1;
              });
              vars = temp;
            }
            if (modifier2) {
              temp = {};
              for (p in vars) {
                temp[p] = modifier2(vars[p]);
              }
              vars = temp;
            }
            _addModifiers(tween2, vars);
          };
        }
      };
    };
    var gsap = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index2, targets) {
        var p, pt, v;
        this.tween = tween;
        for (p in vars) {
          v = target.getAttribute(p) || "";
          pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index2, targets, 0, 0, p);
          pt.op = p;
          pt.b = v;
          this._props.push(p);
        }
      },
      render: function render(ratio, data) {
        var pt = data._pt;
        while (pt) {
          _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
          pt = pt._next;
        }
      }
    }, {
      name: "endArray",
      init: function init2(target, value) {
        var i2 = value.length;
        while (i2--) {
          this.add(target, i2, target[i2] || 0, value[i2], 0, 0, 0, 0, 0, 1);
        }
      }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap.version = "3.11.3";
    _coreReady = 1;
    _windowExists() && _wake();
    var Power0 = _easeMap.Power0;
    var Power1 = _easeMap.Power1;
    var Power2 = _easeMap.Power2;
    var Power3 = _easeMap.Power3;
    var Power4 = _easeMap.Power4;
    var Linear = _easeMap.Linear;
    var Quad = _easeMap.Quad;
    var Cubic = _easeMap.Cubic;
    var Quart = _easeMap.Quart;
    var Quint = _easeMap.Quint;
    var Strong = _easeMap.Strong;
    var Elastic = _easeMap.Elastic;
    var Back = _easeMap.Back;
    var SteppedEase = _easeMap.SteppedEase;
    var Bounce = _easeMap.Bounce;
    var Sine = _easeMap.Sine;
    var Expo = _easeMap.Expo;
    var Circ = _easeMap.Circ;
  
    // node_modules/gsap/CSSPlugin.js
    var _win2;
    var _doc2;
    var _docElement;
    var _pluginInitted;
    var _tempDiv;
    var _tempDivStyler;
    var _recentSetterPlugin;
    var _reverting2;
    var _windowExists3 = function _windowExists4() {
      return typeof window !== "undefined";
    };
    var _transformProps = {};
    var _RAD2DEG = 180 / Math.PI;
    var _DEG2RAD = Math.PI / 180;
    var _atan2 = Math.atan2;
    var _bigNum2 = 1e8;
    var _capsExp = /([A-Z])/g;
    var _horizontalExp = /(left|right|width|margin|padding|x)/i;
    var _complexExp = /[\s,\(]\S/;
    var _propertyAliases = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    };
    var _renderCSSProp = function _renderCSSProp2(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
    };
    var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
      return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
    };
    var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
      return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
    };
    var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
      var value = data.s + data.c * ratio;
      data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
    };
    var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
      return data.set(data.t, data.p, ratio ? data.e : data.b, data);
    };
    var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
      return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
    };
    var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
      return target.style[property] = value;
    };
    var _setterCSSProp = function _setterCSSProp2(target, property, value) {
      return target.style.setProperty(property, value);
    };
    var _setterTransform = function _setterTransform2(target, property, value) {
      return target._gsap[property] = value;
    };
    var _setterScale = function _setterScale2(target, property, value) {
      return target._gsap.scaleX = target._gsap.scaleY = value;
    };
    var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache.scaleX = cache.scaleY = value;
      cache.renderTransform(ratio, cache);
    };
    var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache[property] = value;
      cache.renderTransform(ratio, cache);
    };
    var _transformProp = "transform";
    var _transformOriginProp = _transformProp + "Origin";
    var _saveStyle = function _saveStyle2(property, isNotCSS) {
      var _this = this;
      var target = this.target, style = target.style;
      if (property in _transformProps) {
        this.tfm = this.tfm || {};
        if (property !== "transform") {
          property = _propertyAliases[property] || property;
          ~property.indexOf(",") ? property.split(",").forEach(function(a) {
            return _this.tfm[a] = _get(target, a);
          }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
        }
        if (this.props.indexOf(_transformProp) >= 0) {
          return;
        }
        if (target._gsap.svg) {
          this.svgo = target.getAttribute("data-svg-origin");
          this.props.push(_transformOriginProp, isNotCSS, "");
        }
        property = _transformProp;
      }
      (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
    };
    var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
      if (style.translate) {
        style.removeProperty("translate");
        style.removeProperty("scale");
        style.removeProperty("rotate");
      }
    };
    var _revertStyle = function _revertStyle2() {
      var props = this.props, target = this.target, style = target.style, cache = target._gsap, i2, p;
      for (i2 = 0; i2 < props.length; i2 += 3) {
        props[i2 + 1] ? target[props[i2]] = props[i2 + 2] : props[i2 + 2] ? style[props[i2]] = props[i2 + 2] : style.removeProperty(props[i2].replace(_capsExp, "-$1").toLowerCase());
      }
      if (this.tfm) {
        for (p in this.tfm) {
          cache[p] = this.tfm[p];
        }
        if (cache.svg) {
          cache.renderTransform();
          target.setAttribute("data-svg-origin", this.svgo || "");
        }
        i2 = _reverting2();
        if (i2 && !i2.isStart && !style[_transformProp]) {
          _removeIndependentTransforms(style);
          cache.uncache = 1;
        }
      }
    };
    var _getStyleSaver = function _getStyleSaver2(target, properties) {
      var saver = {
        target,
        props: [],
        revert: _revertStyle,
        save: _saveStyle
      };
      properties && properties.split(",").forEach(function(p) {
        return saver.save(p);
      });
      return saver;
    };
    var _supports3D;
    var _createElement = function _createElement2(type, ns) {
      var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
      return e.style ? e : _doc2.createElement(type);
    };
    var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
      var cs = getComputedStyle(target);
      return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
    };
    var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
    var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
      var e = element || _tempDiv, s = e.style, i2 = 5;
      if (property in s && !preferPrefix) {
        return property;
      }
      property = property.charAt(0).toUpperCase() + property.substr(1);
      while (i2-- && !(_prefixes[i2] + property in s)) {
      }
      return i2 < 0 ? null : (i2 === 3 ? "ms" : i2 >= 0 ? _prefixes[i2] : "") + property;
    };
    var _initCore = function _initCore2() {
      if (_windowExists3() && window.document) {
        _win2 = window;
        _doc2 = _win2.document;
        _docElement = _doc2.documentElement;
        _tempDiv = _createElement("div") || {
          style: {}
        };
        _tempDivStyler = _createElement("div");
        _transformProp = _checkPropPrefix(_transformProp);
        _transformOriginProp = _transformProp + "Origin";
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
        _supports3D = !!_checkPropPrefix("perspective");
        _reverting2 = gsap.core.reverting;
        _pluginInitted = 1;
      }
    };
    var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
      var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
      _docElement.appendChild(svg);
      svg.appendChild(this);
      this.style.display = "block";
      if (swapIfPossible) {
        try {
          bbox = this.getBBox();
          this._gsapBBox = this.getBBox;
          this.getBBox = _getBBoxHack2;
        } catch (e) {
        }
      } else if (this._gsapBBox) {
        bbox = this._gsapBBox();
      }
      if (oldParent) {
        if (oldSibling) {
          oldParent.insertBefore(this, oldSibling);
        } else {
          oldParent.appendChild(this);
        }
      }
      _docElement.removeChild(svg);
      this.style.cssText = oldCSS;
      return bbox;
    };
    var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
      var i2 = attributesArray.length;
      while (i2--) {
        if (target.hasAttribute(attributesArray[i2])) {
          return target.getAttribute(attributesArray[i2]);
        }
      }
    };
    var _getBBox = function _getBBox2(target) {
      var bounds;
      try {
        bounds = target.getBBox();
      } catch (error) {
        bounds = _getBBoxHack.call(target, true);
      }
      bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
      return bounds && !bounds.width && !bounds.x && !bounds.y ? {
        x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
        y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      } : bounds;
    };
    var _isSVG = function _isSVG2(e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
    };
    var _removeProperty = function _removeProperty2(target, property) {
      if (property) {
        var style = target.style;
        if (property in _transformProps && property !== _transformOriginProp) {
          property = _transformProp;
        }
        if (style.removeProperty) {
          if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
            property = "-" + property;
          }
          style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
        } else {
          style.removeAttribute(property);
        }
      }
    };
    var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
      var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
      plugin._pt = pt;
      pt.b = beginning;
      pt.e = end;
      plugin._props.push(property);
      return pt;
    };
    var _nonConvertibleUnits = {
      deg: 1,
      rad: 1,
      turn: 1
    };
    var _nonStandardLayouts = {
      grid: 1,
      flex: 1
    };
    var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
      var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px2, parent2, cache, isSVG;
      if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
        return curValue;
      }
      curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
      isSVG = target.getCTM && _isSVG(target);
      if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
        px2 = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
        return _round(toPercent ? curValue / px2 * amount : curValue / 100 * px2);
      }
      style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
      parent2 = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
      if (isSVG) {
        parent2 = (target.ownerSVGElement || {}).parentNode;
      }
      if (!parent2 || parent2 === _doc2 || !parent2.appendChild) {
        parent2 = _doc2.body;
      }
      cache = parent2._gsap;
      if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
        return _round(curValue / cache.width * amount);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent2 === target && (style.position = "static");
        parent2.appendChild(_tempDiv);
        px2 = _tempDiv[measureProperty];
        parent2.removeChild(_tempDiv);
        style.position = "absolute";
        if (horizontal && toPercent) {
          cache = _getCache(parent2);
          cache.time = _ticker.time;
          cache.width = parent2[measureProperty];
        }
      }
      return _round(toPixels ? px2 * curValue / amount : px2 && curValue ? amount / px2 * curValue : 0);
    };
    var _get = function _get2(target, property, unit, uncache) {
      var value;
      _pluginInitted || _initCore();
      if (property in _propertyAliases && property !== "transform") {
        property = _propertyAliases[property];
        if (~property.indexOf(",")) {
          property = property.split(",")[0];
        }
      }
      if (_transformProps[property] && property !== "transform") {
        value = _parseTransform(target, uncache);
        value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
      } else {
        value = target.style[property];
        if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
          value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
        }
      }
      return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
    };
    var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
      if (!start || start === "none") {
        var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
        if (s && s !== start) {
          prop = p;
          start = s;
        } else if (prop === "borderColor") {
          start = _getComputedProperty(target, "borderTopColor");
        }
      }
      var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index2 = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
      if (end === "auto") {
        target.style[prop] = end;
        end = _getComputedProperty(target, prop) || end;
        target.style[prop] = start;
      }
      a = [start, end];
      _colorStringFilter(a);
      start = a[0];
      end = a[1];
      startValues = start.match(_numWithUnitExp) || [];
      endValues = end.match(_numWithUnitExp) || [];
      if (endValues.length) {
        while (result = _numWithUnitExp.exec(end)) {
          endValue = result[0];
          chunk = end.substring(index2, result.index);
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
            color = 1;
          }
          if (endValue !== (startValue = startValues[matchIndex++] || "")) {
            startNum = parseFloat(startValue) || 0;
            startUnit = startValue.substr((startNum + "").length);
            endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
            endNum = parseFloat(endValue);
            endUnit = endValue.substr((endNum + "").length);
            index2 = _numWithUnitExp.lastIndex - endUnit.length;
            if (!endUnit) {
              endUnit = endUnit || _config.units[prop] || startUnit;
              if (index2 === end.length) {
                end += endUnit;
                pt.e += endUnit;
              }
            }
            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
            }
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              s: startNum,
              c: endNum - startNum,
              m: color && color < 4 || prop === "zIndex" ? Math.round : 0
            };
          }
        }
        pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
      } else {
        pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
      }
      _relExp.test(end) && (pt.e = 0);
      this._pt = pt;
      return pt;
    };
    var _keywordToPercent = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    };
    var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
      var split = value.split(" "), x = split[0], y = split[1] || "50%";
      if (x === "top" || x === "bottom" || y === "left" || y === "right") {
        value = x;
        x = y;
        y = value;
      }
      split[0] = _keywordToPercent[x] || x;
      split[1] = _keywordToPercent[y] || y;
      return split.join(" ");
    };
    var _renderClearProps = function _renderClearProps2(ratio, data) {
      if (data.tween && data.tween._time === data.tween._dur) {
        var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i2;
        if (props === "all" || props === true) {
          style.cssText = "";
          clearTransforms = 1;
        } else {
          props = props.split(",");
          i2 = props.length;
          while (--i2 > -1) {
            prop = props[i2];
            if (_transformProps[prop]) {
              clearTransforms = 1;
              prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
            }
            _removeProperty(target, prop);
          }
        }
        if (clearTransforms) {
          _removeProperty(target, _transformProp);
          if (cache) {
            cache.svg && target.removeAttribute("transform");
            _parseTransform(target, 1);
            cache.uncache = 1;
            _removeIndependentTransforms(style);
          }
        }
      }
    };
    var _specialProps = {
      clearProps: function clearProps(plugin, target, property, endValue, tween) {
        if (tween.data !== "isFromStart") {
          var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
          pt.u = endValue;
          pt.pr = -10;
          pt.tween = tween;
          plugin._props.push(property);
          return 1;
        }
      }
    };
    var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
    var _rotationalProperties = {};
    var _isNullTransform = function _isNullTransform2(value) {
      return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
    };
    var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
      var matrixString = _getComputedProperty(target, _transformProp);
      return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
    };
    var _getMatrix = function _getMatrix2(target, force2D) {
      var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
      if (cache.svg && target.getAttribute("transform")) {
        temp = target.transform.baseVal.consolidate().matrix;
        matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
        return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
      } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
        temp = style.display;
        style.display = "block";
        parent2 = target.parentNode;
        if (!parent2 || !target.offsetParent) {
          addedToDOM = 1;
          nextSibling = target.nextElementSibling;
          _docElement.appendChild(target);
        }
        matrix = _getComputedTransformMatrixAsArray(target);
        temp ? style.display = temp : _removeProperty(target, "display");
        if (addedToDOM) {
          nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
        }
      }
      return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
    };
    var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
      var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
      if (!originIsAbsolute) {
        bounds = _getBBox(target);
        xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
      } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = x;
        yOrigin = y;
      }
      if (smooth || smooth !== false && cache.smooth) {
        tx = xOrigin - xOriginOld;
        ty = yOrigin - yOriginOld;
        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
      } else {
        cache.xOffset = cache.yOffset = 0;
      }
      cache.xOrigin = xOrigin;
      cache.yOrigin = yOrigin;
      cache.smooth = !!smooth;
      cache.origin = origin;
      cache.originIsAbsolute = !!originIsAbsolute;
      target.style[_transformOriginProp] = "0px 0px";
      if (pluginToAddPropTweensTo) {
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
      }
      target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
    };
    var _parseTransform = function _parseTransform2(target, uncache) {
      var cache = target._gsap || new GSCache(target);
      if ("x" in cache && !uncache && !cache.uncache) {
        return cache;
      }
      var style = target.style, invertedScaleX = cache.scaleX < 0, px2 = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
      x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
      scaleX = scaleY = 1;
      cache.svg = !!(target.getCTM && _isSVG(target));
      if (cs.translate) {
        if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
          style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
        }
        style.scale = style.rotate = style.translate = "none";
      }
      matrix = _getMatrix(target, cache.svg);
      if (cache.svg) {
        if (cache.uncache) {
          t2 = target.getBBox();
          origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
          t1 = "";
        } else {
          t1 = !uncache && target.getAttribute("data-svg-origin");
        }
        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
      }
      xOrigin = cache.xOrigin || 0;
      yOrigin = cache.yOrigin || 0;
      if (matrix !== _identity2DMatrix) {
        a = matrix[0];
        b = matrix[1];
        c = matrix[2];
        d = matrix[3];
        x = a12 = matrix[4];
        y = a22 = matrix[5];
        if (matrix.length === 6) {
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
          skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
          skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
          if (cache.svg) {
            x -= xOrigin - (xOrigin * a + yOrigin * c);
            y -= yOrigin - (xOrigin * b + yOrigin * d);
          }
        } else {
          a32 = matrix[6];
          a42 = matrix[7];
          a13 = matrix[8];
          a23 = matrix[9];
          a33 = matrix[10];
          a43 = matrix[11];
          x = matrix[12];
          y = matrix[13];
          z = matrix[14];
          angle = _atan2(a32, a33);
          rotationX = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a12 * cos + a13 * sin;
            t2 = a22 * cos + a23 * sin;
            t3 = a32 * cos + a33 * sin;
            a13 = a12 * -sin + a13 * cos;
            a23 = a22 * -sin + a23 * cos;
            a33 = a32 * -sin + a33 * cos;
            a43 = a42 * -sin + a43 * cos;
            a12 = t1;
            a22 = t2;
            a32 = t3;
          }
          angle = _atan2(-c, a33);
          rotationY = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a * cos - a13 * sin;
            t2 = b * cos - a23 * sin;
            t3 = c * cos - a33 * sin;
            a43 = d * sin + a43 * cos;
            a = t1;
            b = t2;
            c = t3;
          }
          angle = _atan2(b, a);
          rotation = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            t1 = a * cos + b * sin;
            t2 = a12 * cos + a22 * sin;
            b = b * cos - a * sin;
            a22 = a22 * cos - a12 * sin;
            a = t1;
            a12 = t2;
          }
          if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
            rotationX = rotation = 0;
            rotationY = 180 - rotationY;
          }
          scaleX = _round(Math.sqrt(a * a + b * b + c * c));
          scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
          angle = _atan2(a12, a22);
          skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
          perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        }
        if (cache.svg) {
          t1 = target.getAttribute("transform");
          cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
          t1 && target.setAttribute("transform", t1);
        }
      }
      if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
        if (invertedScaleX) {
          scaleX *= -1;
          skewX += rotation <= 0 ? 180 : -180;
          rotation += rotation <= 0 ? 180 : -180;
        } else {
          scaleY *= -1;
          skewX += skewX <= 0 ? 180 : -180;
        }
      }
      uncache = uncache || cache.uncache;
      cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px2;
      cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px2;
      cache.z = z + px2;
      cache.scaleX = _round(scaleX);
      cache.scaleY = _round(scaleY);
      cache.rotation = _round(rotation) + deg;
      cache.rotationX = _round(rotationX) + deg;
      cache.rotationY = _round(rotationY) + deg;
      cache.skewX = skewX + deg;
      cache.skewY = skewY + deg;
      cache.transformPerspective = perspective + px2;
      if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
        style[_transformOriginProp] = _firstTwoOnly(origin);
      }
      cache.xOffset = cache.yOffset = 0;
      cache.force3D = _config.force3D;
      cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
      cache.uncache = 0;
      return cache;
    };
    var _firstTwoOnly = function _firstTwoOnly2(value) {
      return (value = value.split(" "))[0] + " " + value[1];
    };
    var _addPxTranslate = function _addPxTranslate2(target, start, value) {
      var unit = getUnit(start);
      return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
    };
    var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
      cache.z = "0px";
      cache.rotationY = cache.rotationX = "0deg";
      cache.force3D = 0;
      _renderCSSTransforms(ratio, cache);
    };
    var _zeroDeg = "0deg";
    var _zeroPx = "0px";
    var _endParenthesis = ") ";
    var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
      var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
      if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
        var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
        angle = parseFloat(rotationX) * _DEG2RAD;
        cos = Math.cos(angle);
        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
      }
      if (transformPerspective !== _zeroPx) {
        transforms += "perspective(" + transformPerspective + _endParenthesis;
      }
      if (xPercent || yPercent) {
        transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
      }
      if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
        transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
      }
      if (rotation !== _zeroDeg) {
        transforms += "rotate(" + rotation + _endParenthesis;
      }
      if (rotationY !== _zeroDeg) {
        transforms += "rotateY(" + rotationY + _endParenthesis;
      }
      if (rotationX !== _zeroDeg) {
        transforms += "rotateX(" + rotationX + _endParenthesis;
      }
      if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
        transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
      }
      if (scaleX !== 1 || scaleY !== 1) {
        transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
      }
      target.style[_transformProp] = transforms || "translate(0, 0)";
    };
    var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
      var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
      rotation = parseFloat(rotation);
      skewX = parseFloat(skewX);
      skewY = parseFloat(skewY);
      if (skewY) {
        skewY = parseFloat(skewY);
        skewX += skewY;
        rotation += skewY;
      }
      if (rotation || skewX) {
        rotation *= _DEG2RAD;
        skewX *= _DEG2RAD;
        a11 = Math.cos(rotation) * scaleX;
        a21 = Math.sin(rotation) * scaleX;
        a12 = Math.sin(rotation - skewX) * -scaleY;
        a22 = Math.cos(rotation - skewX) * scaleY;
        if (skewX) {
          skewY *= _DEG2RAD;
          temp = Math.tan(skewX - skewY);
          temp = Math.sqrt(1 + temp * temp);
          a12 *= temp;
          a22 *= temp;
          if (skewY) {
            temp = Math.tan(skewY);
            temp = Math.sqrt(1 + temp * temp);
            a11 *= temp;
            a21 *= temp;
          }
        }
        a11 = _round(a11);
        a21 = _round(a21);
        a12 = _round(a12);
        a22 = _round(a22);
      } else {
        a11 = scaleX;
        a22 = scaleY;
        a21 = a12 = 0;
      }
      if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
        tx = _convertToUnit(target, "x", x, "px");
        ty = _convertToUnit(target, "y", y, "px");
      }
      if (xOrigin || yOrigin || xOffset || yOffset) {
        tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
        ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
      }
      if (xPercent || yPercent) {
        temp = target.getBBox();
        tx = _round(tx + xPercent / 100 * temp.width);
        ty = _round(ty + yPercent / 100 * temp.height);
      }
      temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
      target.setAttribute("transform", temp);
      forceCSS && (target.style[_transformProp] = temp);
    };
    var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
      var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change2 = endNum - startNum, finalValue = startNum + change2 + "deg", direction, pt;
      if (isString) {
        direction = endValue.split("_")[1];
        if (direction === "short") {
          change2 %= cap;
          if (change2 !== change2 % (cap / 2)) {
            change2 += change2 < 0 ? cap : -cap;
          }
        }
        if (direction === "cw" && change2 < 0) {
          change2 = (change2 + cap * _bigNum2) % cap - ~~(change2 / cap) * cap;
        } else if (direction === "ccw" && change2 > 0) {
          change2 = (change2 - cap * _bigNum2) % cap - ~~(change2 / cap) * cap;
        }
      }
      plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change2, _renderPropWithEnd);
      pt.e = finalValue;
      pt.u = "deg";
      plugin._props.push(property);
      return pt;
    };
    var _assign = function _assign2(target, source) {
      for (var p in source) {
        target[p] = source[p];
      }
      return target;
    };
    var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
      var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
      if (startCache.svg) {
        startValue = target.getAttribute("transform");
        target.setAttribute("transform", "");
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        _removeProperty(target, _transformProp);
        target.setAttribute("transform", startValue);
      } else {
        startValue = getComputedStyle(target)[_transformProp];
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        style[_transformProp] = startValue;
      }
      for (p in _transformProps) {
        startValue = startCache[p];
        endValue = endCache[p];
        if (startValue !== endValue && exclude.indexOf(p) < 0) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
          startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
          endNum = parseFloat(endValue);
          plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
          plugin._pt.u = endUnit || 0;
          plugin._props.push(p);
        }
      }
      _assign(endCache, startCache);
    };
    _forEachName("padding,margin,Width,Radius", function(name, index2) {
      var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index2 < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
        return index2 < 2 ? name + side : "border" + side + name;
      });
      _specialProps[index2 > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
        var a, vars;
        if (arguments.length < 4) {
          a = props.map(function(prop) {
            return _get(plugin, prop, property);
          });
          vars = a.join(" ");
          return vars.split(a[0]).length === 5 ? a[0] : vars;
        }
        a = (endValue + "").split(" ");
        vars = {};
        props.forEach(function(prop, i2) {
          return vars[prop] = a[i2] = a[i2] || a[(i2 - 1) / 2 | 0];
        });
        plugin.init(target, vars, tween);
      };
    });
    var CSSPlugin = {
      name: "css",
      register: _initCore,
      targetTest: function targetTest(target) {
        return target.style && target.nodeType;
      },
      init: function init3(target, vars, tween, index2, targets) {
        var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
        _pluginInitted || _initCore();
        this.styles = this.styles || _getStyleSaver(target);
        inlineProps = this.styles.props;
        this.tween = tween;
        for (p in vars) {
          if (p === "autoRound") {
            continue;
          }
          endValue = vars[p];
          if (_plugins[p] && _checkPlugin(p, vars, tween, index2, target, targets)) {
            continue;
          }
          type = typeof endValue;
          specialProp = _specialProps[p];
          if (type === "function") {
            endValue = endValue.call(tween, index2, target, targets);
            type = typeof endValue;
          }
          if (type === "string" && ~endValue.indexOf("random(")) {
            endValue = _replaceRandom(endValue);
          }
          if (specialProp) {
            specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
          } else if (p.substr(0, 2) === "--") {
            startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
            endValue += "";
            _colorExp.lastIndex = 0;
            if (!_colorExp.test(startValue)) {
              startUnit = getUnit(startValue);
              endUnit = getUnit(endValue);
            }
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
            this.add(style, "setProperty", startValue, endValue, index2, targets, 0, 0, p);
            props.push(p);
            inlineProps.push(p, 0, style[p]);
          } else if (type !== "undefined") {
            if (startAt && p in startAt) {
              startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index2, target, targets) : startAt[p];
              _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
              getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
              (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
            } else {
              startValue = _get(target, p);
            }
            startNum = parseFloat(startValue);
            relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
            relative && (endValue = endValue.substr(2));
            endNum = parseFloat(endValue);
            if (p in _propertyAliases) {
              if (p === "autoAlpha") {
                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                  startNum = 0;
                }
                inlineProps.push("visibility", 0, style.visibility);
                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
              }
              if (p !== "scale" && p !== "transform") {
                p = _propertyAliases[p];
                ~p.indexOf(",") && (p = p.split(",")[0]);
              }
            }
            isTransformRelated = p in _transformProps;
            if (isTransformRelated) {
              this.styles.save(p);
              if (!transformPropTween) {
                cache = target._gsap;
                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                smooth = vars.smoothOrigin !== false && cache.smooth;
                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                transformPropTween.dep = 1;
              }
              if (p === "scale") {
                this._pt = new PropTween(this._pt, cache, "scaleY", startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum || 0, _renderCSSProp);
                this._pt.u = 0;
                props.push("scaleY", p);
                p += "X";
              } else if (p === "transformOrigin") {
                inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                endValue = _convertKeywordsToPercentages(endValue);
                if (cache.svg) {
                  _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                } else {
                  endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                  endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                  _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                }
                continue;
              } else if (p === "svgOrigin") {
                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                continue;
              } else if (p in _rotationalProperties) {
                _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                continue;
              } else if (p === "smoothOrigin") {
                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                continue;
              } else if (p === "force3D") {
                cache[p] = endValue;
                continue;
              } else if (p === "transform") {
                _addRawTransformPTs(this, endValue, target);
                continue;
              }
            } else if (!(p in style)) {
              p = _checkPropPrefix(p) || p;
            }
            if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
              startUnit = (startValue + "").substr((startNum + "").length);
              endNum || (endNum = 0);
              endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
              startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
              this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
              this._pt.u = endUnit || 0;
              if (startUnit !== endUnit && endUnit !== "%") {
                this._pt.b = startValue;
                this._pt.r = _renderCSSPropWithBeginning;
              }
            } else if (!(p in style)) {
              if (p in target) {
                this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index2, targets);
              } else {
                _missingPlugin(p, endValue);
                continue;
              }
            } else {
              _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
            }
            isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
            props.push(p);
          }
        }
        hasPriority && _sortPropTweensByPriority(this);
      },
      render: function render2(ratio, data) {
        if (data.tween._time || !_reverting2()) {
          var pt = data._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
        } else {
          data.styles.revert();
        }
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
        var p = _propertyAliases[property];
        p && p.indexOf(",") < 0 && (property = p);
        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
      },
      core: {
        _removeProperty,
        _getMatrix
      }
    };
    gsap.utils.checkPrefix = _checkPropPrefix;
    gsap.core.getStyleSaver = _getStyleSaver;
    (function(positionAndScale, rotation, others, aliases) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
        _transformProps[name] = 1;
      });
      _forEachName(rotation, function(name) {
        _config.units[name] = "deg";
        _rotationalProperties[name] = 1;
      });
      _propertyAliases[all[13]] = positionAndScale + "," + rotation;
      _forEachName(aliases, function(name) {
        var split = name.split(":");
        _propertyAliases[split[1]] = all[split[0]];
      });
    })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
      _config.units[name] = "px";
    });
    gsap.registerPlugin(CSSPlugin);
  
    // node_modules/gsap/index.js
    var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
    var TweenMaxWithCSS = gsapWithCSS.core.Tween;
  
    // assets/scripts/modules/AnimateIllustration.js
    var AnimateIllustration_default = class extends _default {
      constructor(m) {
        super(m);
        this.$el = this.el;
        this.$paths = this.$("path");
      }
      init() {
        this.computeData();
      }
      destroy() {
        super.destroy();
      }
      computeData() {
        for (var i2 = this.$paths.length - 1; i2 >= 0; i2--) {
          const length = this.$paths[i2].getTotalLength();
          const duration = gsapWithCSS.utils.random(7, 9, 0.1);
          this.$paths[i2].style.setProperty("--length", `${length}px`);
          this.$paths[i2].style.setProperty("--index", i2);
          this.$paths[i2].style.setProperty("--duration", duration);
        }
      }
    };
  
    // node_modules/gsap/utils/strings.js
    var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
    function getText(e) {
      var type = e.nodeType, result = "";
      if (type === 1 || type === 9 || type === 11) {
        if (typeof e.textContent === "string") {
          return e.textContent;
        } else {
          for (e = e.firstChild; e; e = e.nextSibling) {
            result += getText(e);
          }
        }
      } else if (type === 3 || type === 4) {
        return e.nodeValue;
      }
      return result;
    }
  
    // node_modules/gsap/DrawSVGPlugin.js
    var gsap2;
    var _toArray;
    var _doc3;
    var _win3;
    var _isEdge;
    var _coreInitted2;
    var _warned;
    var _getStyleSaver3;
    var _reverting3;
    var _windowExists5 = function _windowExists6() {
      return typeof window !== "undefined";
    };
    var _getGSAP = function _getGSAP2() {
      return gsap2 || _windowExists5() && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
    };
    var _numExp2 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi;
    var _types = {
      rect: ["width", "height"],
      circle: ["r", "r"],
      ellipse: ["rx", "ry"],
      line: ["x2", "y2"]
    };
    var _round3 = function _round4(value) {
      return Math.round(value * 1e4) / 1e4;
    };
    var _parseNum = function _parseNum2(value) {
      return parseFloat(value) || 0;
    };
    var _parseSingleVal = function _parseSingleVal2(value, length) {
      var num = _parseNum(value);
      return ~value.indexOf("%") ? num / 100 * length : num;
    };
    var _getAttributeAsNumber = function _getAttributeAsNumber2(target, attr2) {
      return _parseNum(target.getAttribute(attr2));
    };
    var _sqrt2 = Math.sqrt;
    var _getDistance = function _getDistance2(x1, y1, x2, y2, scaleX, scaleY) {
      return _sqrt2(Math.pow((_parseNum(x2) - _parseNum(x1)) * scaleX, 2) + Math.pow((_parseNum(y2) - _parseNum(y1)) * scaleY, 2));
    };
    var _warn3 = function _warn4(message) {
      return console.warn(message);
    };
    var _hasNonScalingStroke = function _hasNonScalingStroke2(target) {
      return target.getAttribute("vector-effect") === "non-scaling-stroke";
    };
    var _bonusValidated = 1;
    var _parse = function _parse2(value, length, defaultStart) {
      var i2 = value.indexOf(" "), s, e;
      if (i2 < 0) {
        s = defaultStart !== void 0 ? defaultStart + "" : value;
        e = value;
      } else {
        s = value.substr(0, i2);
        e = value.substr(i2 + 1);
      }
      s = _parseSingleVal(s, length);
      e = _parseSingleVal(e, length);
      return s > e ? [e, s] : [s, e];
    };
    var _getLength = function _getLength2(target) {
      target = _toArray(target)[0];
      if (!target) {
        return 0;
      }
      var type = target.tagName.toLowerCase(), style = target.style, scaleX = 1, scaleY = 1, length, bbox, points, prevPoint, i2, rx, ry;
      if (_hasNonScalingStroke(target)) {
        scaleY = target.getScreenCTM();
        scaleX = _sqrt2(scaleY.a * scaleY.a + scaleY.b * scaleY.b);
        scaleY = _sqrt2(scaleY.d * scaleY.d + scaleY.c * scaleY.c);
      }
      try {
        bbox = target.getBBox();
      } catch (e) {
        _warn3("Some browsers won't measure invisible elements (like display:none or masks inside defs).");
      }
      var _ref = bbox || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height;
      if ((!bbox || !width && !height) && _types[type]) {
        width = _getAttributeAsNumber(target, _types[type][0]);
        height = _getAttributeAsNumber(target, _types[type][1]);
        if (type !== "rect" && type !== "line") {
          width *= 2;
          height *= 2;
        }
        if (type === "line") {
          x = _getAttributeAsNumber(target, "x1");
          y = _getAttributeAsNumber(target, "y1");
          width = Math.abs(width - x);
          height = Math.abs(height - y);
        }
      }
      if (type === "path") {
        prevPoint = style.strokeDasharray;
        style.strokeDasharray = "none";
        length = target.getTotalLength() || 0;
        _round3(scaleX) !== _round3(scaleY) && !_warned && (_warned = 1) && _warn3("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.");
        length *= (scaleX + scaleY) / 2;
        style.strokeDasharray = prevPoint;
      } else if (type === "rect") {
        length = width * 2 * scaleX + height * 2 * scaleY;
      } else if (type === "line") {
        length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);
      } else if (type === "polyline" || type === "polygon") {
        points = target.getAttribute("points").match(_numExp2) || [];
        type === "polygon" && points.push(points[0], points[1]);
        length = 0;
        for (i2 = 2; i2 < points.length; i2 += 2) {
          length += _getDistance(points[i2 - 2], points[i2 - 1], points[i2], points[i2 + 1], scaleX, scaleY) || 0;
        }
      } else if (type === "circle" || type === "ellipse") {
        rx = width / 2 * scaleX;
        ry = height / 2 * scaleY;
        length = Math.PI * (3 * (rx + ry) - _sqrt2((3 * rx + ry) * (rx + 3 * ry)));
      }
      return length || 0;
    };
    var _getPosition = function _getPosition2(target, length) {
      target = _toArray(target)[0];
      if (!target) {
        return [0, 0];
      }
      length || (length = _getLength(target) + 1);
      var cs = _win3.getComputedStyle(target), dash = cs.strokeDasharray || "", offset2 = _parseNum(cs.strokeDashoffset), i2 = dash.indexOf(",");
      i2 < 0 && (i2 = dash.indexOf(" "));
      dash = i2 < 0 ? length : _parseNum(dash.substr(0, i2));
      dash > length && (dash = length);
      return [-offset2 || 0, dash - offset2 || 0];
    };
    var _initCore3 = function _initCore4() {
      if (_windowExists5()) {
        _doc3 = document;
        _win3 = window;
        _coreInitted2 = gsap2 = _getGSAP();
        _toArray = gsap2.utils.toArray;
        _getStyleSaver3 = gsap2.core.getStyleSaver;
        _reverting3 = gsap2.core.reverting || function() {
        };
        _isEdge = ((_win3.navigator || {}).userAgent || "").indexOf("Edge") !== -1;
      }
    };
    var DrawSVGPlugin = {
      version: "3.11.3",
      name: "drawSVG",
      register: function register(core) {
        gsap2 = core;
        _initCore3();
      },
      init: function init4(target, value, tween, index2, targets) {
        if (!target.getBBox) {
          return false;
        }
        _coreInitted2 || _initCore3();
        var length = _getLength(target), start, end, cs;
        this.styles = _getStyleSaver3 && _getStyleSaver3(target, "strokeDashoffset,strokeDasharray,strokeMiterlimit");
        this.tween = tween;
        this._style = target.style;
        this._target = target;
        if (value + "" === "true") {
          value = "0 100%";
        } else if (!value) {
          value = "0 0";
        } else if ((value + "").indexOf(" ") === -1) {
          value = "0 " + value;
        }
        start = _getPosition(target, length);
        end = _parse(value, length, start[0]);
        this._length = _round3(length);
        this._dash = _round3(start[1] - start[0]);
        this._offset = _round3(-start[0]);
        this._dashPT = this.add(this, "_dash", this._dash, _round3(end[1] - end[0]), 0, 0, 0, 0, 0, 1);
        this._offsetPT = this.add(this, "_offset", this._offset, _round3(-end[0]), 0, 0, 0, 0, 0, 1);
        if (_isEdge) {
          cs = _win3.getComputedStyle(target);
          if (cs.strokeLinecap !== cs.strokeLinejoin) {
            end = _parseNum(cs.strokeMiterlimit);
            this.add(target.style, "strokeMiterlimit", end, end + 0.01);
          }
        }
        this._live = _hasNonScalingStroke(target) || ~(value + "").indexOf("live");
        this._nowrap = ~(value + "").indexOf("nowrap");
        this._props.push("drawSVG");
        return _bonusValidated;
      },
      render: function render3(ratio, data) {
        if (data.tween._time || !_reverting3()) {
          var pt = data._pt, style = data._style, length, lengthRatio, dash, offset2;
          if (pt) {
            if (data._live) {
              length = _getLength(data._target);
              if (length !== data._length) {
                lengthRatio = length / data._length;
                data._length = length;
                if (data._offsetPT) {
                  data._offsetPT.s *= lengthRatio;
                  data._offsetPT.c *= lengthRatio;
                }
                if (data._dashPT) {
                  data._dashPT.s *= lengthRatio;
                  data._dashPT.c *= lengthRatio;
                } else {
                  data._dash *= lengthRatio;
                }
              }
            }
            while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next;
            }
            dash = data._dash || ratio && ratio !== 1 && 1e-4 || 0;
            length = data._length - dash + 0.1;
            offset2 = data._offset;
            dash && offset2 && dash + Math.abs(offset2 % data._length) > data._length - 0.2 && (offset2 += offset2 < 0 ? 0.1 : -0.1) && (length += 0.1);
            style.strokeDashoffset = dash ? offset2 : offset2 + 1e-3;
            style.strokeDasharray = length < 0.2 ? "none" : dash ? dash + "px," + (data._nowrap ? 999999 : length) + "px" : "0px, 999999px";
          }
        } else {
          data.styles.revert();
        }
      },
      getLength: _getLength,
      getPosition: _getPosition
    };
    _getGSAP() && gsap2.registerPlugin(DrawSVGPlugin);
  
    // node_modules/gsap/SplitText.js
    var _doc4;
    var _win4;
    var _coreInitted3;
    var _stripExp = /(?:\r|\n|\t\t)/g;
    var _multipleSpacesExp = /(?:\s\s+)/g;
    var _initCore5 = function _initCore6() {
      _doc4 = document;
      _win4 = window;
      _coreInitted3 = 1;
    };
    var _bonusValidated2 = 1;
    var _getComputedStyle = function _getComputedStyle2(element) {
      return _win4.getComputedStyle(element);
    };
    var _isArray2 = Array.isArray;
    var _slice2 = [].slice;
    var _toArray2 = function _toArray3(value, leaveStrings) {
      var type;
      return _isArray2(value) ? value : (type = typeof value) === "string" && !leaveStrings && value ? _slice2.call(_doc4.querySelectorAll(value), 0) : value && type === "object" && "length" in value ? _slice2.call(value, 0) : value ? [value] : [];
    };
    var _isAbsolute = function _isAbsolute2(vars) {
      return vars.position === "absolute" || vars.absolute === true;
    };
    var _findSpecialChars = function _findSpecialChars2(text2, chars) {
      var i2 = chars.length, s;
      while (--i2 > -1) {
        s = chars[i2];
        if (text2.substr(0, s.length) === s) {
          return s.length;
        }
      }
    };
    var _divStart = " style='position:relative;display:inline-block;'";
    var _cssClassFunc = function _cssClassFunc2(cssClass, tag) {
      if (cssClass === void 0) {
        cssClass = "";
      }
      var iterate = ~cssClass.indexOf("++"), num = 1;
      if (iterate) {
        cssClass = cssClass.split("++").join("");
      }
      return function() {
        return "<" + tag + _divStart + (cssClass ? " class='" + cssClass + (iterate ? num++ : "") + "'>" : ">");
      };
    };
    var _swapText = function _swapText2(element, oldText, newText) {
      var type = element.nodeType;
      if (type === 1 || type === 9 || type === 11) {
        for (element = element.firstChild; element; element = element.nextSibling) {
          _swapText2(element, oldText, newText);
        }
      } else if (type === 3 || type === 4) {
        element.nodeValue = element.nodeValue.split(oldText).join(newText);
      }
    };
    var _pushReversed = function _pushReversed2(a, merge) {
      var i2 = merge.length;
      while (--i2 > -1) {
        a.push(merge[i2]);
      }
    };
    var _isBeforeWordDelimiter = function _isBeforeWordDelimiter2(e, root, wordDelimiter) {
      var next2;
      while (e && e !== root) {
        next2 = e._next || e.nextSibling;
        if (next2) {
          return next2.textContent.charAt(0) === wordDelimiter;
        }
        e = e.parentNode || e._parent;
      }
    };
    var _deWordify = function _deWordify2(e) {
      var children2 = _toArray2(e.childNodes), l = children2.length, i2, child;
      for (i2 = 0; i2 < l; i2++) {
        child = children2[i2];
        if (child._isSplit) {
          _deWordify2(child);
        } else {
          if (i2 && child.previousSibling && child.previousSibling.nodeType === 3) {
            child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;
            e.removeChild(child);
          } else if (child.nodeType !== 3) {
            e.insertBefore(child.firstChild, child);
            e.removeChild(child);
          }
        }
      }
    };
    var _getStyleAsNumber = function _getStyleAsNumber2(name, computedStyle) {
      return parseFloat(computedStyle[name]) || 0;
    };
    var _setPositionsAfterSplit = function _setPositionsAfterSplit2(element, vars, allChars, allWords, allLines, origWidth, origHeight) {
      var cs = _getComputedStyle(element), paddingLeft = _getStyleAsNumber("paddingLeft", cs), lineOffsetY = -999, borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs), borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs), padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs), padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs), lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || 0.2), textAlign = cs.textAlign, charArray = [], wordArray = [], lineArray = [], wordDelimiter = vars.wordDelimiter || " ", tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", lines = allLines && ~types.indexOf("lines") ? [] : null, words = ~types.indexOf("words"), chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), linesClass = vars.linesClass, iterateLine = ~(linesClass || "").indexOf("++"), spaceNodesToRemove = [], isFlex = cs.display === "flex", prevInlineDisplay = element.style.display, i2, j, l, node, nodes, isChild, curLine, addWordSpaces, style, lineNode, lineWidth, offset2;
      iterateLine && (linesClass = linesClass.split("++").join(""));
      isFlex && (element.style.display = "block");
      j = element.getElementsByTagName("*");
      l = j.length;
      nodes = [];
      for (i2 = 0; i2 < l; i2++) {
        nodes[i2] = j[i2];
      }
      if (lines || absolute) {
        for (i2 = 0; i2 < l; i2++) {
          node = nodes[i2];
          isChild = node.parentNode === element;
          if (isChild || absolute || chars && !words) {
            offset2 = node.offsetTop;
            if (lines && isChild && Math.abs(offset2 - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i2 === 0)) {
              curLine = [];
              lines.push(curLine);
              lineOffsetY = offset2;
            }
            if (absolute) {
              node._x = node.offsetLeft;
              node._y = offset2;
              node._w = node.offsetWidth;
              node._h = node.offsetHeight;
            }
            if (lines) {
              if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {
                curLine.push(node);
                node._x -= paddingLeft;
                if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {
                  node._wordEnd = true;
                }
              }
              if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i2 === 0)) {
                lines.push([]);
              }
            }
          }
        }
      }
      for (i2 = 0; i2 < l; i2++) {
        node = nodes[i2];
        isChild = node.parentNode === element;
        if (node.nodeName === "BR") {
          if (lines || absolute) {
            node.parentNode && node.parentNode.removeChild(node);
            nodes.splice(i2--, 1);
            l--;
          } else if (!words) {
            element.appendChild(node);
          }
          continue;
        }
        if (absolute) {
          style = node.style;
          if (!words && !isChild) {
            node._x += node.parentNode._x;
            node._y += node.parentNode._y;
          }
          style.left = node._x + "px";
          style.top = node._y + "px";
          style.position = "absolute";
          style.display = "block";
          style.width = node._w + 1 + "px";
          style.height = node._h + "px";
        }
        if (!words && chars) {
          if (node._isSplit) {
            node._next = j = node.nextSibling;
            node.parentNode.appendChild(node);
            while (j && j.nodeType === 3 && j.textContent === " ") {
              node._next = j.nextSibling;
              node.parentNode.appendChild(j);
              j = j.nextSibling;
            }
          } else if (node.parentNode._isSplit) {
            node._parent = node.parentNode;
            if (!node.previousSibling && node.firstChild) {
              node.firstChild._isFirst = true;
            }
            if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {
              spaceNodesToRemove.push(node.nextSibling);
            }
            node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;
            node.parentNode.removeChild(node);
            nodes.splice(i2--, 1);
            l--;
          } else if (!isChild) {
            offset2 = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter);
            node.parentNode._parent && node.parentNode._parent.appendChild(node);
            offset2 && node.parentNode.appendChild(_doc4.createTextNode(" "));
            if (tag === "span") {
              node.style.display = "inline";
            }
            charArray.push(node);
          }
        } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {
          wordArray.push(node);
        } else if (chars && !node._isSplit) {
          if (tag === "span") {
            node.style.display = "inline";
          }
          charArray.push(node);
        }
      }
      i2 = spaceNodesToRemove.length;
      while (--i2 > -1) {
        spaceNodesToRemove[i2].parentNode.removeChild(spaceNodesToRemove[i2]);
      }
      if (lines) {
        if (absolute) {
          lineNode = _doc4.createElement(tag);
          element.appendChild(lineNode);
          lineWidth = lineNode.offsetWidth + "px";
          offset2 = lineNode.offsetParent === element ? 0 : element.offsetLeft;
          element.removeChild(lineNode);
        }
        style = element.style.cssText;
        element.style.cssText = "display:none;";
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
        addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);
        for (i2 = 0; i2 < lines.length; i2++) {
          curLine = lines[i2];
          lineNode = _doc4.createElement(tag);
          lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");
          if (linesClass) {
            lineNode.className = linesClass + (iterateLine ? i2 + 1 : "");
          }
          lineArray.push(lineNode);
          l = curLine.length;
          for (j = 0; j < l; j++) {
            if (curLine[j].nodeName !== "BR") {
              node = curLine[j];
              lineNode.appendChild(node);
              addWordSpaces && node._wordEnd && lineNode.appendChild(_doc4.createTextNode(" "));
              if (absolute) {
                if (j === 0) {
                  lineNode.style.top = node._y + "px";
                  lineNode.style.left = paddingLeft + offset2 + "px";
                }
                node.style.top = "0px";
                if (offset2) {
                  node.style.left = node._x - offset2 + "px";
                }
              }
            }
          }
          if (l === 0) {
            lineNode.innerHTML = "&nbsp;";
          } else if (!words && !chars) {
            _deWordify(lineNode);
            _swapText(lineNode, String.fromCharCode(160), " ");
          }
          if (absolute) {
            lineNode.style.width = lineWidth;
            lineNode.style.height = node._h + "px";
          }
          element.appendChild(lineNode);
        }
        element.style.cssText = style;
      }
      if (absolute) {
        if (origHeight > element.clientHeight) {
          element.style.height = origHeight - padTopAndBottom + "px";
          if (element.clientHeight < origHeight) {
            element.style.height = origHeight + borderTopAndBottom + "px";
          }
        }
        if (origWidth > element.clientWidth) {
          element.style.width = origWidth - padLeftAndRight + "px";
          if (element.clientWidth < origWidth) {
            element.style.width = origWidth + borderLeftAndRight + "px";
          }
        }
      }
      isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display"));
      _pushReversed(allChars, charArray);
      words && _pushReversed(allWords, wordArray);
      _pushReversed(allLines, lineArray);
    };
    var _splitRawText = function _splitRawText2(element, vars, wordStart, charStart) {
      var tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), wordDelimiter = vars.wordDelimiter || " ", space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ", wordEnd = "</" + tag + ">", wordIsOpen = 1, specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null, text2, splitText, i2, j, l, character, hasTagStart, testResult, container = _doc4.createElement("div"), parent2 = element.parentNode;
      parent2.insertBefore(container, element);
      container.textContent = element.nodeValue;
      parent2.removeChild(element);
      element = container;
      text2 = getText(element);
      hasTagStart = text2.indexOf("<") !== -1;
      if (vars.reduceWhiteSpace !== false) {
        text2 = text2.replace(_multipleSpacesExp, " ").replace(_stripExp, "");
      }
      if (hasTagStart) {
        text2 = text2.split("<").join("{{LT}}");
      }
      l = text2.length;
      splitText = (text2.charAt(0) === " " ? space : "") + wordStart();
      for (i2 = 0; i2 < l; i2++) {
        character = text2.charAt(i2);
        if (specialChars && (testResult = specialChars(text2.substr(i2), vars.specialChars))) {
          character = text2.substr(i2, testResult || 1);
          splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
          i2 += testResult - 1;
        } else if (character === wordDelimiter && text2.charAt(i2 - 1) !== wordDelimiter && i2) {
          splitText += wordIsOpen ? wordEnd : "";
          wordIsOpen = 0;
          while (text2.charAt(i2 + 1) === wordDelimiter) {
            splitText += space;
            i2++;
          }
          if (i2 === l - 1) {
            splitText += space;
          } else if (text2.charAt(i2 + 1) !== ")") {
            splitText += space + wordStart();
            wordIsOpen = 1;
          }
        } else if (character === "{" && text2.substr(i2, 6) === "{{LT}}") {
          splitText += chars ? charStart() + "{{LT}}</" + tag + ">" : "{{LT}}";
          i2 += 5;
        } else if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text2.charCodeAt(i2 + 1) >= 65024 && text2.charCodeAt(i2 + 1) <= 65039) {
          j = ((text2.substr(i2, 12).split(emojiExp) || [])[1] || "").length || 2;
          splitText += chars && character !== " " ? charStart() + text2.substr(i2, j) + "</" + tag + ">" : text2.substr(i2, j);
          i2 += j - 1;
        } else {
          splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
        }
      }
      element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");
      hasTagStart && _swapText(parent2, "{{LT}}", "<");
    };
    var _split = function _split2(element, vars, wordStart, charStart) {
      var children2 = _toArray2(element.childNodes), l = children2.length, absolute = _isAbsolute(vars), i2, child;
      if (element.nodeType !== 3 || l > 1) {
        vars.absolute = false;
        for (i2 = 0; i2 < l; i2++) {
          child = children2[i2];
          child._next = child._isFirst = child._parent = child._wordEnd = null;
          if (child.nodeType !== 3 || /\S+/.test(child.nodeValue)) {
            if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {
              child.style.display = "inline-block";
              child.style.position = "relative";
            }
            child._isSplit = true;
            _split2(child, vars, wordStart, charStart);
          }
        }
        vars.absolute = absolute;
        element._isSplit = true;
        return;
      }
      _splitRawText(element, vars, wordStart, charStart);
    };
    var SplitText = /* @__PURE__ */ function() {
      function SplitText2(element, vars) {
        _coreInitted3 || _initCore5();
        this.elements = _toArray2(element);
        this.chars = [];
        this.words = [];
        this.lines = [];
        this._originals = [];
        this.vars = vars || {};
        _bonusValidated2 && this.split(vars);
      }
      var _proto = SplitText2.prototype;
      _proto.split = function split(vars) {
        this.isSplit && this.revert();
        this.vars = vars = vars || this.vars;
        this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        var i2 = this.elements.length, tag = vars.tag ? vars.tag : vars.span ? "span" : "div", wordStart = _cssClassFunc(vars.wordsClass, tag), charStart = _cssClassFunc(vars.charsClass, tag), origHeight, origWidth, e;
        while (--i2 > -1) {
          e = this.elements[i2];
          this._originals[i2] = e.innerHTML;
          origHeight = e.clientHeight;
          origWidth = e.clientWidth;
          _split(e, vars, wordStart, charStart);
          _setPositionsAfterSplit(e, vars, this.chars, this.words, this.lines, origWidth, origHeight);
        }
        this.chars.reverse();
        this.words.reverse();
        this.lines.reverse();
        this.isSplit = true;
        return this;
      };
      _proto.revert = function revert() {
        var originals = this._originals;
        if (!originals) {
          throw "revert() call wasn't scoped properly.";
        }
        this.elements.forEach(function(e, i2) {
          return e.innerHTML = originals[i2];
        });
        this.chars = [];
        this.words = [];
        this.lines = [];
        this.isSplit = false;
        return this;
      };
      SplitText2.create = function create(element, vars) {
        return new SplitText2(element, vars);
      };
      return SplitText2;
    }();
    SplitText.version = "3.11.3";
  
    // node_modules/gsap/all.js
    var gsapWithCSS2 = gsap.registerPlugin(CSSPlugin) || gsap;
    var TweenMaxWithCSS2 = gsapWithCSS2.core.Tween;
  
    // assets/scripts/modules/CarouselQuote.js
    var EXPERIENCE_MASK_TEXTURE_WIDTH = 1440;
    var EXPERIENCE_MASK_TEXTURE_HEIGHT = 794;
    var DEFAULT_PORTAL_WIDTH = 259;
    var CarouselQuote_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.onKeyBind = (e) => {
          if (e.key === "ArrowLeft" && this.isInview) {
            this.onPrev();
          } else if (e.key === "ArrowRight" && this.isInview) {
            this.onNext();
          }
        };
        this.$el = this.el;
        this.$wrapper = this.$("wrapper")[0];
        this.$slides = this.$("item");
        this.$images = this.$("image");
        this.$sentences = this.$("sentence");
        this.events = {
          click: {
            prev: "onPrev",
            next: "onNext"
          }
        };
        this.progressIndex = 0;
        this.oldIndex = null;
        this.currentIndex = 0;
        this.direction = 1;
        this.splitInstances = [];
      }
      init() {
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
        document.addEventListener("keyup", this.onKeyBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
        document.removeEventListener("keyup", this.onKeyBind);
      }
      onResize() {
        this.computePortal();
        requestAnimationFrame(() => {
          this.computeWrapperHeight();
          requestAnimationFrame(() => {
            this.call("update", null, "Scroll");
          });
        });
      }
      onFontsLoaded() {
        this.computePortal();
        requestAnimationFrame(() => {
          this.computeWrapperHeight();
          requestAnimationFrame(() => {
            this.call("update", null, "Scroll");
          });
        });
      }
      onPrev() {
        if (this.isAnimating)
          return;
        this.progressIndex = (this.progressIndex - 1) % this.$slides.length;
        this.oldIndex = this.currentIndex;
        this.currentIndex = Math.abs(this.progressIndex);
        this.direction = -1;
        this.animeExit();
        this.animeHeight();
        this.animeEnter();
        this.$slides[this.oldIndex].classList.remove("is-active");
        this.$slides[this.oldIndex].classList.add("is-old");
        this.$slides[this.currentIndex].classList.remove("is-old");
        this.$slides[this.currentIndex].classList.add("is-active");
      }
      onNext() {
        if (this.isAnimating)
          return;
        this.progressIndex = (this.progressIndex + 1) % this.$slides.length;
        this.oldIndex = this.currentIndex;
        this.currentIndex = Math.abs(this.progressIndex);
        this.direction = 1;
        this.animeExit();
        this.animeHeight();
        this.animeEnter();
        this.$slides[this.oldIndex].classList.remove("is-active");
        this.$slides[this.oldIndex].classList.add("is-old");
        this.$slides[this.currentIndex].classList.remove("is-old");
        this.$slides[this.currentIndex].classList.add("is-active");
      }
      onEnterInView() {
        if (!this.isEntered) {
          this.animeEnter();
          this.$slides[this.currentIndex].classList.add("is-active");
          this.isEntered = true;
        }
        this.isInview = true;
      }
      onExitInView() {
        this.isInview = false;
      }
      computeWrapperHeight() {
        const $currentItem = this.$slides[this.currentIndex];
        const currentHeight = $currentItem.offsetHeight;
        this.$wrapper.style.height = `${currentHeight}px`;
      }
      computePortal() {
        const maskTextureScale = this.computeMaskTextureScale();
        this.setPictureWidth(maskTextureScale);
      }
      computeMaskTextureScale() {
        const canvasWidth = window.innerWidth;
        const canvasHeight = window.innerHeight;
        const originalTexWidth = EXPERIENCE_MASK_TEXTURE_WIDTH;
        const originalTexHeight = EXPERIENCE_MASK_TEXTURE_HEIGHT;
        const tAspect = originalTexWidth / originalTexHeight;
        const pAspect = canvasWidth / canvasHeight;
        const pwidth = canvasWidth;
        const pheight = canvasHeight;
        let currentTexWidth = 0;
        if (tAspect > pAspect) {
          currentTexWidth = pheight * tAspect;
        } else {
          currentTexWidth = pwidth;
        }
        return currentTexWidth / originalTexWidth;
      }
      setPictureWidth(textureScale) {
        const portalWidth = Math.round(DEFAULT_PORTAL_WIDTH * textureScale);
        let imageIndex = 0;
        while (imageIndex < this.$images.length) {
          const $image = this.$images[imageIndex];
          $image.style.minWidth = `${portalWidth}px`;
          requestAnimationFrame(() => {
            const width = $image.offsetWidth;
            const portalRadius = width * 0.5;
            $image.style.borderRadius = `${portalRadius}px ${portalRadius}px 0 0`;
          });
          imageIndex++;
        }
      }
      animeEnter() {
        this.isAnimating = true;
        const translateX = 100 * this.direction;
        const translateY = 30;
        const $selectedImage = this.$images[this.currentIndex];
        gsapWithCSS2.fromTo($selectedImage, {
          x: `${translateX}%`,
          y: `${translateY}%`,
          rotate: "15deg",
          autoAlpha: 0
        }, {
          x: 0,
          y: 0,
          rotate: 0,
          autoAlpha: 1,
          duration: 1.2,
          ease: "power3.out",
          onComplete: () => {
            this.isAnimating = false;
          }
        });
      }
      animeExit() {
        const translateX = -100 * this.direction;
        const translateY = 30;
        const $selectedImage = this.$images[this.oldIndex];
        gsapWithCSS2.fromTo($selectedImage, {
          x: 0,
          y: 0,
          rotate: 0,
          autoAlpha: 1
        }, {
          x: `${translateX}%`,
          y: `${translateY}%`,
          rotate: "-15deg",
          autoAlpha: 0,
          duration: 1.2,
          ease: "power3.out"
        });
      }
      animeHeight() {
        const $currentItem = this.$slides[this.currentIndex];
        const currentHeight = $currentItem.offsetHeight;
        gsapWithCSS2.to(this.$wrapper, {
          height: currentHeight,
          duration: 1,
          ease: "power2.out",
          onComplete: () => {
            this.call("update", null, "Scroll");
          }
        });
      }
    };
  
    // assets/scripts/utils/isMobile.js
    function isMobile() {
      var a = {};
      var f = /iPhone/i, h = /iPod/i, i2 = /iPad/i, r = /\biOS-universal(?:.+)Mac\b/i, g = /\bAndroid(?:.+)Mobile\b/i, j = /Android/i, c = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, d = /Silk/i, b = /Windows Phone/i, k = /\bWindows(?:.+)ARM\b/i, m = /BlackBerry/i, n = /BB10/i, o = /Opera Mini/i, p = /\b(CriOS|Chrome)(?:.+)Mobile/i, q = /Mobile(?:.+)Firefox\b/i;
      function s(l) {
        return function($2) {
          return $2.test(l);
        };
      }
      function e(l) {
        var $2 = (l = l || (typeof navigator != "undefined" ? navigator.userAgent : "")).split("[FBAN");
        $2[1] !== void 0 && (l = $2[0]), ($2 = l.split("Twitter"))[1] !== void 0 && (l = $2[0]);
        var a2 = s(l), e2 = {
          apple: {
            phone: a2(f) && !a2(b),
            ipod: a2(h),
            tablet: !a2(f) && a2(i2) && !a2(b),
            universal: a2(r),
            device: (a2(f) || a2(h) || a2(i2)) && !a2(b)
          },
          amazon: {
            phone: a2(c),
            tablet: !a2(c) && a2(d),
            device: a2(c) || a2(d)
          },
          android: {
            phone: !a2(b) && a2(c) || !a2(b) && a2(g),
            tablet: !a2(b) && !a2(c) && !a2(g) && (a2(d) || a2(j)),
            device: !a2(b) && (a2(c) || a2(d) || a2(g) || a2(j)) || a2(/\bokhttp\b/i)
          },
          windows: {
            phone: a2(b),
            tablet: a2(k),
            device: a2(b) || a2(k)
          },
          other: {
            blackberry: a2(m),
            blackberry10: a2(n),
            opera: a2(o),
            firefox: a2(q),
            chrome: a2(p),
            device: a2(m) || a2(n) || a2(o) || a2(q) || a2(p)
          },
          any: false,
          phone: false,
          tablet: false
        };
        return e2.any = e2.apple.universal || e2.apple.device || e2.android.device || e2.windows.device || e2.other.device, e2.phone = e2.apple.phone || e2.android.phone || e2.windows.phone, e2.tablet = e2.apple.tablet || e2.android.tablet || e2.windows.tablet, e2;
      }
      a = e();
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = a;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return a;
        });
      } else {
        return a;
      }
    }
  
    // assets/scripts/classes/Mouse/Mouse.js
    var isMobileObj = isMobile();
    var IS_TOUCH_DEVICE = (isMobileObj == null ? void 0 : isMobileObj.phone) || (isMobileObj == null ? void 0 : isMobileObj.tablet);
    var translate = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5,
      smoothX: window.innerWidth * 0.5,
      smoothY: window.innerHeight * 0.5,
      lerp: 0.08
    };
    var isPlaying = false;
    var bindEvents = () => {
      window.addEventListener("mousemove", onMouseMove);
    };
    var onMouseMove = (e) => {
      translate.x = e.clientX;
      translate.y = e.clientY;
      Mouse.x = translate.x;
      Mouse.y = translate.y;
    };
    var onUpdate = () => {
      translate.smoothX += (translate.x - translate.smoothX) * translate.lerp;
      translate.smoothX = (100 * (translate.smoothX + 0.01) | 0) / 100;
      translate.smoothY += (translate.y - translate.smoothY) * translate.lerp;
      translate.smoothY = (100 * (translate.smoothY + 0.01) | 0) / 100;
      Mouse.smoothX = translate.smoothX;
      Mouse.smoothY = translate.smoothY;
    };
    var _Mouse = class {
      static play() {
        if (isPlaying)
          return;
        isPlaying = true;
        gsapWithCSS2.ticker.add(onUpdate);
      }
      static pause() {
        if (!isPlaying)
          return;
        isPlaying = false;
        gsapWithCSS2.ticker.remove(onUpdate);
      }
    };
    var Mouse = _Mouse;
    (() => {
      if (!IS_TOUCH_DEVICE) {
        bindEvents();
        _Mouse.play();
      }
    })();
    __publicField(Mouse, "x", translate.x);
    __publicField(Mouse, "y", translate.y);
    __publicField(Mouse, "smoothX", translate.smoothX);
    __publicField(Mouse, "smoothY", translate.smoothY);
    var Mouse_default = Mouse;
  
    // assets/scripts/modules/Cursor.js
    var isMobileObj2 = isMobile();
    var IS_TOUCH_DEVICE2 = (isMobileObj2 == null ? void 0 : isMobileObj2.phone) || (isMobileObj2 == null ? void 0 : isMobileObj2.tablet);
    var Cursor_default = class extends _default {
      constructor(m) {
        super(m);
        this.prevCursorState = "";
        this.holdPrevCursorState = "";
        this.cursorState = "default";
        this.isPlaying = false;
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.onResetCursorBind = this.onResetCursor.bind(this);
        this.onUpdateBind = this.onUpdate.bind(this);
        this.$el = this.el;
        this.$holdCircle = this.$("holdCircle")[0];
      }
      init() {
        this.initCursor();
      }
      destroy() {
        super.destroy();
        this.destroyCursor();
      }
      bindEvents() {
        const $items = document.querySelectorAll(`[data-cursor]`);
        let itemIndex = 0;
        while (itemIndex < $items.length) {
          const $item = $items[itemIndex];
          $item.addEventListener("mouseenter", this.onMouseEnterBind);
          $item.addEventListener("mouseleave", this.onMouseLeaveBind);
          itemIndex++;
        }
        window.addEventListener("resetCursorBind", this.onResetCursorBind);
      }
      unbindEvents() {
        const $items = document.querySelectorAll(`[data-cursor]`);
        let itemIndex = 0;
        while (itemIndex < $items.length) {
          const $item = $items[itemIndex];
          $item.addEventListener("mouseenter", this.onMouseEnterBind);
          $item.addEventListener("mouseleave", this.onMouseLeaveBind);
          itemIndex++;
        }
        window.removeEventListener("resetCursorBind", this.onResetCursorBind);
      }
      onMouseEnter(e) {
        var _a;
        const $target = e.target;
        const state = (_a = $target == null ? void 0 : $target.dataset) == null ? void 0 : _a.cursor;
        if (state) {
          this.setCursorState(state);
        }
      }
      onMouseLeave() {
        this.setCursorState("default");
      }
      onUpdate() {
        this.translateCursor(Mouse_default.smoothX, Mouse_default.smoothY);
      }
      onResetCursor() {
        this.setCursorState("default");
      }
      initCursor() {
        if (IS_TOUCH_DEVICE2)
          return;
        this.bindEvents();
        this.translateCursor(Mouse_default.x, Mouse_default.y);
        this.setCursorState("default");
        requestAnimationFrame(() => {
          this.play();
        });
      }
      destroyCursor() {
        if (IS_TOUCH_DEVICE2)
          return;
        this.unbindEvents();
        requestAnimationFrame(() => {
          this.setCursorState("");
          this.pause();
        });
      }
      play() {
        if (this.isPlaying)
          return;
        this.isPlaying = true;
        gsapWithCSS2.ticker.add(this.onUpdateBind);
      }
      pause() {
        if (!this.isPlaying)
          return;
        this.isPlaying = false;
        gsapWithCSS2.ticker.remove(this.onUpdateBind);
      }
      translateCursor(x, y) {
        this.$el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      }
      setCursorState(state) {
        this.prevCursorState = this.cursorState;
        this.cursorState = state;
        this.$el.classList.remove(`-${this.prevCursorState}`);
        this.$el.classList.add(`-${this.cursorState}`);
      }
      holdDown(duration) {
        var _a;
        if (IS_TOUCH_DEVICE2)
          return;
        this.holdPrevCursorState = this.cursorState;
        this.setCursorState("hold");
        (_a = this.holdAnimation) == null ? void 0 : _a.kill();
        this.holdAnimation = gsapWithCSS2.to(this.$holdCircle, {
          duration: duration / 1e3,
          attr: {
            "stroke-dashoffset": 0
          },
          ease: "linear"
        });
      }
      holdUp() {
        var _a;
        if (IS_TOUCH_DEVICE2)
          return;
        this.setCursorState(this.holdPrevCursorState);
        (_a = this.holdAnimation) == null ? void 0 : _a.kill();
        this.holdAnimation = gsapWithCSS2.to(this.$holdCircle, {
          duration: 0.3,
          attr: {
            "stroke-dashoffset": 91
          },
          ease: "power2.out"
        });
      }
    };
  
    // assets/scripts/modules/DrawSvg.js
    gsapWithCSS.registerPlugin(DrawSVGPlugin);
    var DrawSvg_default = class extends _default {
      constructor(m) {
        super(m);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.$el = this.el;
        this.$path = this.$("path");
      }
      init() {
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
        this.tl && this.tl.kill();
      }
      bindEvents() {
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onFontsLoaded() {
        this.setTimeline();
      }
      setTimeline() {
        requestAnimationFrame(() => {
          this.tl = gsapWithCSS.timeline({ repeat: -1, repeatDelay: 1 });
          this.tl.fromTo(this.$path, { drawSVG: "0% 0%" }, { duration: 1, drawSVG: "0% 100%", ease: "power2.out" });
          this.tl.to(this.$path, { duration: 1, drawSVG: "100% 100%", ease: "power2.in" }, "+=2");
        });
      }
    };
  
    // assets/scripts/modules/FollowingHover.js
    var FollowingHover_default = class extends _default {
      constructor(m) {
        super(m);
        this.onEnterBind = this.onEnter.bind(this);
        this.onLeaveBind = this.onLeave.bind(this);
        this.onListEnterBind = this.onListEnter.bind(this);
        this.onListLeaveBind = this.onListLeave.bind(this);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.$el = this.el;
        this.$items = this.$("item");
        this.$indicator = this.$("indicator")[0];
        this.metrics = [];
      }
      init() {
        this.setMetrics();
        this.currentIndex = 0;
        this.setDefaultValues(this.currentIndex);
        this.bindEvents();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        this.$el.addEventListener("mouseenter", this.onListEnterBind);
        this.$el.addEventListener("mouseleave", this.onListLeaveBind);
        this.$items.forEach(($item) => {
          $item.addEventListener("mouseenter", this.onEnterBind);
          $item.addEventListener("mouseleave", this.onLeaveBind);
        });
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        this.$el.removeEventListener("mouseenter", this.onListEnterBind);
        this.$el.removeEventListener("mouseleave", this.onListLeaveBind);
        this.$items.forEach(($item) => {
          $item.removeEventListener("mouseenter", this.onEnterBind);
          $item.removeEventListener("mouseleave", this.onLeaveBind);
        });
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onEnter(e) {
        const $target = e.currentTarget;
        this.currentIndex = Array.from(this.$items).indexOf($target);
        this.setIndicatorTranslate(this.currentIndex);
        this.setActiveClass(this.currentIndex);
      }
      onLeave() {
      }
      onListEnter() {
        this.setIndicatorVisibility(true);
      }
      onListLeave() {
        this.setIndicatorVisibility(false);
      }
      onResize() {
        this.setMetrics();
        this.setDefaultValues(this.currentIndex);
      }
      onFontsLoaded() {
        this.setMetrics();
        this.setDefaultValues(this.currentIndex);
      }
      setMetrics() {
        this.metrics = [];
        this.$items.forEach(($item) => {
          this.metrics.push($item.offsetHeight);
        });
      }
      setDefaultValues(index2) {
        this.setActiveClass(index2);
        this.setIndicatorTranslate(index2);
        this.setIndicatorHeight(index2);
      }
      setActiveClass(activeIndex) {
        this.$items.forEach(($item, itemIndex) => {
          if (itemIndex === activeIndex) {
            $item.classList.add("is-active");
          } else {
            $item.classList.remove("is-active");
          }
        });
      }
      setIndicatorHeight(index2) {
        const height = this.metrics[index2];
        this.$indicator.style.height = `${height}px`;
      }
      setIndicatorTranslate(index2) {
        if (index2 < 0)
          return;
        const metrics = [...this.metrics];
        metrics.length = index2;
        const translateY = metrics.reduce((a, b) => a + b, 0);
        this.$indicator.style.transform = `translate3d(0, ${translateY}px, 0)`;
      }
      setIndicatorVisibility(isVisible) {
        if (isVisible) {
          this.$indicator.classList.add("is-active");
        } else {
          this.$indicator.classList.remove("is-active");
        }
      }
      resetItems(items) {
        this.unbindEvents();
        this.$items = items;
        requestAnimationFrame(() => {
          this.init();
        });
      }
    };
  
    // assets/scripts/utils/maths.js
    function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }
    function map(value, min0, max0, min1, max1) {
      return min1 + (value - min0) / (max0 - min0) * (max1 - min1);
    }
    function clamp3(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }
  
    // assets/scripts/utils/environment.js
    var html = document.documentElement;
    var body = document.body;
    var isDebug = html.hasAttribute("data-debug");
    var lang = html.getAttribute("lang");
    var assetsVersion = html.getAttribute("data-assets-version");
  
    // assets/scripts/modules/FooterReveal.js
    var FooterReveal_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.$el = this.el;
        this.$inner = this.$("inner")[0];
        this.speed = 0.5;
      }
      init() {
        this.bindEvents();
        this.getValues();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        this.$el.addEventListener("mouseenter", this.onMouseEnterBind);
        this.$el.addEventListener("mouseleave", this.onMouseLeaveBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        this.$el.removeEventListener("mouseenter", this.onMouseEnterBind);
        this.$el.removeEventListener("mouseleave", this.onMouseLeaveBind);
      }
      onResize() {
        this.getValues();
      }
      onMouseEnter() {
        html.classList.add("is-footer-hovering");
      }
      onMouseLeave() {
        html.classList.remove("is-footer-hovering");
      }
      onProgress(progress) {
        requestAnimationFrame(() => {
          this.computeProgress(progress);
        });
      }
      onFontsLoaded() {
        this.getValues();
      }
      getValues() {
        this.footerHeight = this.$el.offsetHeight;
        this.ratio = this.footerHeight / (window.innerHeight + this.footerHeight);
      }
      computeProgress(progress) {
        if (progress > 0.4) {
          html.setAttribute("data-scroll-theme", "light");
        } else if (html.getAttribute("data-scroll-theme-main") != "light") {
          html.setAttribute("data-scroll-theme", "");
        }
        const translate2 = this.speed * (this.footerHeight * (clamp3(progress / this.ratio, 0, 1) - 1));
        this.$inner.style.transform = `translate3d(0, ${translate2}px, 0)`;
      }
    };
  
    // assets/scripts/utils/is.js
    function isEmail(email) {
      return email.match(/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
    }
    function isWebGL2Ready() {
      if (window.isWebGL2Ready == void 0) {
        const gl = document.createElement("canvas").getContext("webgl2");
        window.isWebGL2Ready = gl ? true : false;
      }
      return window.isWebGL2Ready;
    }
  
    // assets/scripts/utils/html.js
    function queryClosestParent(elem, selector3) {
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
          var matches2 = (this.document || this.ownerDocument).querySelectorAll(s), i2 = matches2.length;
          while (--i2 >= 0 && matches2.item(i2) !== this) {
          }
          return i2 > -1;
        };
      }
      for (; elem && elem !== document; elem = elem.parentNode) {
        if (elem.matches(selector3))
          return elem;
      }
      return null;
    }
    function openFileDialog(accept, callback) {
      const inputElement = document.createElement("input");
      inputElement.type = "file";
      inputElement.accept = accept;
      const changeCallback = () => {
        inputElement.removeEventListener("change", changeCallback);
        callback.call(this, inputElement);
      };
      inputElement.addEventListener("change", callback);
      inputElement.dispatchEvent(new MouseEvent("click"));
    }
  
    // assets/scripts/modules/Form.js
    var STATE = {
      IDLE: "-idle",
      PROCESSING: "-processing",
      SENDING: "-sending",
      INVALID: "-invalid",
      ERRORED: "-errored",
      COMPLETED: "-completed"
    };
    var GENERIC_MESSAGES = {
      CRITICAL: "An error occured. Please try again later"
    };
    var SUCCESS_MESSAGE_DURATION = 2e3;
    var Form_default = class extends _default {
      constructor(m) {
        super(m);
        this.onHandleSubmitBind = this.onHandleSubmit.bind(this);
        this.$el = this.el;
        this.$submit = this.$("submit")[0];
        this.$form = this.$("form")[0];
        this.$error = this.$("error")[0];
        this.$success = this.$("success")[0];
      }
      init() {
        this.bindEvents();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        this.$form.addEventListener("submit", this.onHandleSubmitBind);
      }
      unbindEvents() {
        this.$form.removeEventListener("submit", this.onHandleSubmitBind);
      }
      onHandleSubmit(event2) {
        event2.preventDefault();
        this.submitEvent = event2;
        this.formData = this.getFormData(event2.target);
        if (!this.validateForm()) {
          return false;
        }
        if (this.useRecaptcha && this.sitekey) {
        } else {
          this.processForm();
        }
      }
      validateForm() {
        let isValid = true;
        [...this.submitEvent.target.elements].forEach((el) => {
          const elIsRequired = el.getAttribute("required");
          const elValue = this.formData.get(el.getAttribute("name"));
          const elType = el.getAttribute("type") || "text";
          const $parentEl = queryClosestParent(el, ".c-form_item") || el;
          if ($parentEl.classList.contains("has-error")) {
            $parentEl.classList.remove("has-error");
            $parentEl.querySelector(".c-form_error").ariaHidden = "true";
          }
          if (elIsRequired === null || elType !== "email" && elValue && elValue.length !== 0 || elType === "email" && isEmail(elValue)) {
            return;
          }
          isValid = false;
          $parentEl.classList.add("has-error");
          $parentEl.querySelector(".c-form_error").ariaHidden = "false";
          requestAnimationFrame(() => {
            this.call("update", null, "Scroll");
          });
        });
        return isValid;
      }
      processForm(token) {
        if ([STATE.PROCESSING, STATE.SENDING].includes(this.formState)) {
          console.warn("Form is busy");
          return false;
        }
        if (token) {
          this.formData.append("g-recaptcha-response", token);
        }
        this.setState(STATE.PROCESSING);
        this.clearErrorMessage();
        try {
          this.submitForm();
        } catch (error) {
          console.error("[App.Form.handleSubmit]", error);
          this.setState(STATE.ERRORED);
          this.setErrorMessage(GENERIC_MESSAGES.CRITICAL);
        }
      }
      submitForm() {
        if (this.formState === STATE.SENDING) {
          console.warn("Form is already sending");
          return false;
        }
        if (!this.submitEvent) {
          throw new Error("Missing submit event object");
        }
        this.setState(STATE.SENDING);
        const form = this.submitEvent.target;
        const formUrl = form.action;
        const controller = new AbortController();
        const badgeContainerId = this.badgeContainerId;
        fetch(formUrl, {
          method: form.method,
          body: this.formData,
          signal: controller.signal
        }).then((response) => {
          return response.json();
        }).then((response) => {
          if (response && response.success) {
            controller.abort();
            this.setState(STATE.COMPLETED);
            this.$success.ariaHidden = "false";
            this.$form.reset();
            setTimeout(() => {
              this.setState(STATE.IDLE);
              this.$success.ariaHidden = "true";
            }, SUCCESS_MESSAGE_DURATION);
          }
          if (response && response.errors != "") {
            this.serverErrorMessages = __spreadValues({}, response.errors);
            this.serverErrors = response.errors;
            this.setState(STATE.ERRORED);
            this.setErrorMessage(GENERIC_MESSAGES.CRITICAL);
            this.$error.ariaHidden = "false";
          }
        }).catch((error) => {
          this.setState(STATE.ERRORED);
          this.setErrorMessage(GENERIC_MESSAGES.CRITICAL);
          this.$error.ariaHidden = "false";
        });
      }
      getFormData(form) {
        const submission = form.dataset.submission;
        const formData = new FormData(form);
        formData.append("submission", submission);
        return formData;
      }
      setState(stateValue) {
        const prevState = this.formState;
        this.formState = stateValue;
        this.$form.classList.remove(prevState);
        this.$form.classList.add(this.formState);
        if (stateValue === STATE.ERRORED || stateValue === STATE.COMPLETED) {
          requestAnimationFrame(() => {
            this.call("update", null, "Scroll");
          });
        }
      }
      setErrorMessage(message) {
        if (this.$error) {
          this.$error.innerHTML = message;
        } else {
          console.warn(message);
        }
      }
      clearErrorMessage() {
        if (this.$error) {
          this.$error.innerHTML = "";
          this.$error.ariaHidden = "true";
        }
      }
      suspendForm() {
      }
      resumeForm() {
      }
    };
  
    // node_modules/three/build/three.module.js
    var REVISION = "134";
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var VSMShadowMap = 3;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var CineonToneMapping = 3;
    var ACESFilmicToneMapping = 4;
    var CustomToneMapping = 5;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1e3;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipmapNearestFilter = 1004;
    var NearestMipmapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipmapNearestFilter = 1007;
    var LinearMipmapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RedFormat = 1028;
    var RedIntegerFormat = 1029;
    var RGFormat = 1030;
    var RGIntegerFormat = 1031;
    var RGBIntegerFormat = 1032;
    var RGBAIntegerFormat = 1033;
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGB_ETC2_Format = 37492;
    var RGBA_ETC2_EAC_Format = 37496;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var RGBA_BPTC_Format = 36492;
    var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
    var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
    var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
    var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
    var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
    var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
    var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
    var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
    var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
    var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
    var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
    var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
    var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
    var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var NormalAnimationBlendMode = 2500;
    var AdditiveAnimationBlendMode = 2501;
    var TrianglesDrawMode = 0;
    var LinearEncoding = 3e3;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var TangentSpaceNormalMap = 0;
    var ObjectSpaceNormalMap = 1;
    var KeepStencilOp = 7680;
    var AlwaysStencilFunc = 519;
    var StaticDrawUsage = 35044;
    var DynamicDrawUsage = 35048;
    var GLSL3 = "300 es";
    var EventDispatcher = class {
      addEventListener(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
      hasEventListener(type, listener) {
        if (this._listeners === void 0)
          return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      removeEventListener(type, listener) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index2 = listenerArray.indexOf(listener);
          if (index2 !== -1) {
            listenerArray.splice(index2, 1);
          }
        }
      }
      dispatchEvent(event2) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[event2.type];
        if (listenerArray !== void 0) {
          event2.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l = array.length; i2 < l; i2++) {
            array[i2].call(this, event2);
          }
          event2.target = null;
        }
      }
    };
    var DEG2RAD = Math.PI / 180;
    var RAD2DEG = 180 / Math.PI;
    var _lut = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
    }
    var hasRandomUUID = typeof crypto !== "undefined" && "randomUUID" in crypto;
    function generateUUID() {
      if (hasRandomUUID) {
        return crypto.randomUUID().toUpperCase();
      }
      const d0 = Math.random() * 4294967295 | 0;
      const d1 = Math.random() * 4294967295 | 0;
      const d2 = Math.random() * 4294967295 | 0;
      const d3 = Math.random() * 4294967295 | 0;
      const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
      return uuid.toUpperCase();
    }
    function clamp4(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    function euclideanModulo(n, m) {
      return (n % m + m) % m;
    }
    function lerp2(x, y, t) {
      return (1 - t) * x + t * y;
    }
    function isPowerOfTwo(value) {
      return (value & value - 1) === 0 && value !== 0;
    }
    function floorPowerOfTwo(value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }
    var Vector2 = class {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y) {
        this.y = y;
        return this;
      }
      setComponent(index2, value) {
        switch (index2) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      }
      getComponent(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index2);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y;
      }
      cross(v) {
        return this.x * v.y - this.y * v.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y;
      }
      fromArray(array, offset2 = 0) {
        this.x = array[offset2];
        this.y = array[offset2 + 1];
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this.x;
        array[offset2 + 1] = this.y;
        return array;
      }
      fromBufferAttribute(attribute, index2, offset2) {
        if (offset2 !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        return this;
      }
      rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    Vector2.prototype.isVector2 = true;
    var Matrix3 = class {
      constructor() {
        this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
      setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
      multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      transpose() {
        let tmp2;
        const m = this.elements;
        tmp2 = m[1];
        m[1] = m[3];
        m[3] = tmp2;
        tmp2 = m[2];
        m[2] = m[6];
        m[6] = tmp2;
        tmp2 = m[5];
        m[5] = m[7];
        m[7] = tmp2;
        return this;
      }
      getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
      transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      }
      setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
      }
      scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      }
      rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
      }
      translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      }
      equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      }
      fromArray(array, offset2 = 0) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset2];
        }
        return this;
      }
      toArray(array = [], offset2 = 0) {
        const te = this.elements;
        array[offset2] = te[0];
        array[offset2 + 1] = te[1];
        array[offset2 + 2] = te[2];
        array[offset2 + 3] = te[3];
        array[offset2 + 4] = te[4];
        array[offset2 + 5] = te[5];
        array[offset2 + 6] = te[6];
        array[offset2 + 7] = te[7];
        array[offset2 + 8] = te[8];
        return array;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    };
    Matrix3.prototype.isMatrix3 = true;
    function arrayMax(array) {
      if (array.length === 0)
        return -Infinity;
      let max = array[0];
      for (let i2 = 1, l = array.length; i2 < l; ++i2) {
        if (array[i2] > max)
          max = array[i2];
      }
      return max;
    }
    function createElementNS(name) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", name);
    }
    function hashString(str, seed = 0) {
      let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
      for (let i2 = 0, ch; i2 < str.length; i2++) {
        ch = str.charCodeAt(i2);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
      }
      h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
      h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
      return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    }
    var _canvas;
    var ImageUtils = class {
      static getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0)
            _canvas = createElementNS("canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          const context3 = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context3.putImageData(image, 0, 0);
          } else {
            context3.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
    };
    var textureId = 0;
    var Texture = class extends EventDispatcher {
      constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
        super();
        Object.defineProperty(this, "id", { value: textureId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.image = image;
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (this.image !== void 0) {
          const image = this.image;
          if (image.uuid === void 0) {
            image.uuid = generateUUID();
          }
          if (!isRootObject && meta.images[image.uuid] === void 0) {
            let url;
            if (Array.isArray(image)) {
              url = [];
              for (let i2 = 0, l = image.length; i2 < l; i2++) {
                if (image[i2].isDataTexture) {
                  url.push(serializeImage(image[i2].image));
                } else {
                  url.push(serializeImage(image[i2]));
                }
              }
            } else {
              url = serializeImage(image);
            }
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url
            };
          }
          output.image = image.uuid;
        }
        if (JSON.stringify(this.userData) !== "{}")
          output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(uv) {
        if (this.mapping !== UVMapping)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
    };
    Texture.DEFAULT_IMAGE = void 0;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype.isTexture = true;
    function serializeImage(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        return ImageUtils.getDataURL(image);
      } else {
        if (image.data) {
          return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
          };
        } else {
          console.warn("THREE.Texture: Unable to serialize Texture.");
          return {};
        }
      }
    }
    var Vector4 = class {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      get width() {
        return this.z;
      }
      set width(value) {
        this.z = value;
      }
      get height() {
        return this.w;
      }
      set height(value) {
        this.w = value;
      }
      set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y) {
        this.y = y;
        return this;
      }
      setZ(z) {
        this.z = z;
        return this;
      }
      setW(w) {
        this.w = w;
        return this;
      }
      setComponent(index2, value) {
        switch (index2) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      }
      getComponent(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index2);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== void 0 ? v.w : 1;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
      applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      setAxisAngleFromQuaternion(q) {
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      }
      setAxisAngleFromRotationMatrix(m) {
        let angle, x, y, z;
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          const xx = (m11 + 1) / 2;
          const yy = (m22 + 1) / 2;
          const zz = (m33 + 1) / 2;
          const xy = (m12 + m21) / 4;
          const xz = (m13 + m31) / 4;
          const yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 1e-3)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      }
      fromArray(array, offset2 = 0) {
        this.x = array[offset2];
        this.y = array[offset2 + 1];
        this.z = array[offset2 + 2];
        this.w = array[offset2 + 3];
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this.x;
        array[offset2 + 1] = this.y;
        array[offset2 + 2] = this.z;
        array[offset2 + 3] = this.w;
        return array;
      }
      fromBufferAttribute(attribute, index2, offset2) {
        if (offset2 !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        this.z = attribute.getZ(index2);
        this.w = attribute.getW(index2);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
      }
    };
    Vector4.prototype.isVector4 = true;
    var WebGLRenderTarget = class extends EventDispatcher {
      constructor(width, height, options = {}) {
        super();
        this.width = width;
        this.height = height;
        this.depth = 1;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.image = { width, height, depth: 1 };
        this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
        this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
        this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
      }
      setTexture(texture) {
        texture.image = {
          width: this.width,
          height: this.height,
          depth: this.depth
        };
        this.texture = texture;
      }
      setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          this.texture.image.width = width;
          this.texture.image.height = height;
          this.texture.image.depth = depth;
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.texture.image = __spreadValues({}, this.texture.image);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
    var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
      constructor(width, height, count) {
        super(width, height);
        const texture = this.texture;
        this.texture = [];
        for (let i2 = 0; i2 < count; i2++) {
          this.texture[i2] = texture.clone();
        }
      }
      setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
            this.texture[i2].image.width = width;
            this.texture[i2].image.height = height;
            this.texture[i2].image.depth = depth;
          }
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
        return this;
      }
      copy(source) {
        this.dispose();
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.set(0, 0, this.width, this.height);
        this.scissor.set(0, 0, this.width, this.height);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        this.texture.length = 0;
        for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
          this.texture[i2] = source.texture[i2].clone();
        }
        return this;
      }
    };
    WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
    var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
      constructor(width, height, options) {
        super(width, height, options);
        this.samples = 4;
      }
      copy(source) {
        super.copy.call(this, source);
        this.samples = source.samples;
        return this;
      }
    };
    WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
    var Quaternion = class {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      static slerp(qa, qb, qm, t) {
        console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
        return qm.slerpQuaternions(qa, qb, t);
      }
      static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          let s = 1 - t;
          const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t = Math.sin(t * len) / sin;
          }
          const tDir = t * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir;
          if (s === 1 - t) {
            const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
      static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(value) {
        this._w = value;
        this._onChangeCallback();
      }
      set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      }
      setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y / 2);
        const s3 = sin(z / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false)
          this._onChangeCallback();
        return this;
      }
      setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m) {
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
          const s = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
      }
      setFromUnitVectors(vFrom, vTo) {
        let r = vFrom.dot(vTo) + 1;
        if (r < Number.EPSILON) {
          r = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r;
        }
        return this.normalize();
      }
      angleTo(q) {
        return 2 * Math.acos(Math.abs(clamp4(this.dot(q), -1, 1)));
      }
      rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0)
          return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      }
      dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      }
      multiply(q, p) {
        if (p !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      }
      premultiply(q) {
        return this.multiplyQuaternions(q, this);
      }
      multiplyQuaternions(a, b) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      }
      slerp(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        const x = this._x, y = this._y, z = this._z, w = this._w;
        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          const s = 1 - t;
          this._w = s * w + t * this._w;
          this._x = s * x + t * this._x;
          this._y = s * y + t * this._y;
          this._z = s * z + t * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      }
      slerpQuaternions(qa, qb, t) {
        this.copy(qa).slerp(qb, t);
      }
      random() {
        const u1 = Math.random();
        const sqrt1u1 = Math.sqrt(1 - u1);
        const sqrtu1 = Math.sqrt(u1);
        const u2 = 2 * Math.PI * Math.random();
        const u3 = 2 * Math.PI * Math.random();
        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
      }
      equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      }
      fromArray(array, offset2 = 0) {
        this._x = array[offset2];
        this._y = array[offset2 + 1];
        this._z = array[offset2 + 2];
        this._w = array[offset2 + 3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this._x;
        array[offset2 + 1] = this._y;
        array[offset2 + 2] = this._z;
        array[offset2 + 3] = this._w;
        return array;
      }
      fromBufferAttribute(attribute, index2) {
        this._x = attribute.getX(index2);
        this._y = attribute.getY(index2);
        this._z = attribute.getZ(index2);
        this._w = attribute.getW(index2);
        return this;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
    };
    Quaternion.prototype.isQuaternion = true;
    var Vector3 = class {
      constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      set(x, y, z) {
        if (z === void 0)
          z = this.z;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y) {
        this.y = y;
        return this;
      }
      setZ(z) {
        this.z = z;
        return this;
      }
      setComponent(index2, value) {
        switch (index2) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      }
      getComponent(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index2);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      }
      multiply(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
      multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      }
      applyEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      }
      applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      }
      applyMatrix3(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      }
      applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      }
      applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
      }
      applyQuaternion(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      }
      project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      transformDirection(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      }
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      }
      cross(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
      }
      crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
      projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0)
          return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
      }
      projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
      }
      reflect(normal) {
        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
      angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0)
          return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        return Math.acos(clamp4(theta, -1, 1));
      }
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      }
      setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      }
      setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
      setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      }
      setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
      }
      setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      }
      setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
      setFromMatrixColumn(m, index2) {
        return this.fromArray(m.elements, index2 * 4);
      }
      setFromMatrix3Column(m, index2) {
        return this.fromArray(m.elements, index2 * 3);
      }
      equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      }
      fromArray(array, offset2 = 0) {
        this.x = array[offset2];
        this.y = array[offset2 + 1];
        this.z = array[offset2 + 2];
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this.x;
        array[offset2 + 1] = this.y;
        array[offset2 + 2] = this.z;
        return array;
      }
      fromBufferAttribute(attribute, index2, offset2) {
        if (offset2 !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        this.z = attribute.getZ(index2);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
      randomDirection() {
        const u = (Math.random() - 0.5) * 2;
        const t = Math.random() * Math.PI * 2;
        const f = Math.sqrt(1 - __pow(u, 2));
        this.x = f * Math.cos(t);
        this.y = f * Math.sin(t);
        this.z = u;
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
      }
    };
    Vector3.prototype.isVector3 = true;
    var _vector$c = /* @__PURE__ */ new Vector3();
    var _quaternion$4 = /* @__PURE__ */ new Quaternion();
    var Box3 = class {
      constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
          const x = array[i2];
          const y = array[i2 + 1];
          const z = array[i2 + 2];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
          const x = attribute.getX(i2);
          const y = attribute.getY(i2);
          const z = attribute.getZ(i2);
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      expandByObject(object) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== void 0) {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
        const children2 = object.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          this.expandByObject(children2[i2]);
        }
        return this;
      }
      containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      }
      getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      }
      intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector$b);
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      }
      intersectsPlane(plane) {
        let min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      }
      intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0$2.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$3.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$7, _v0$2);
        _f1.subVectors(_v2$3, _v1$7);
        _f2.subVectors(_v0$2, _v2$3);
        let axes = [
          0,
          -_f0.z,
          _f0.y,
          0,
          -_f1.z,
          _f1.y,
          0,
          -_f2.z,
          _f2.y,
          _f0.z,
          0,
          -_f0.x,
          _f1.z,
          0,
          -_f1.x,
          _f2.z,
          0,
          -_f2.x,
          -_f0.y,
          _f0.x,
          0,
          -_f1.y,
          _f1.x,
          0,
          -_f2.y,
          _f2.x,
          0
        ];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
      }
      clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      }
      getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
        return target;
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      applyMatrix4(matrix) {
        if (this.isEmpty())
          return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
      }
      translate(offset2) {
        this.min.add(offset2);
        this.max.add(offset2);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    Box3.prototype.isBox3 = true;
    var _points = [
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3()
    ];
    var _vector$b = /* @__PURE__ */ new Vector3();
    var _box$3 = /* @__PURE__ */ new Box3();
    var _v0$2 = /* @__PURE__ */ new Vector3();
    var _v1$7 = /* @__PURE__ */ new Vector3();
    var _v2$3 = /* @__PURE__ */ new Vector3();
    var _f0 = /* @__PURE__ */ new Vector3();
    var _f1 = /* @__PURE__ */ new Vector3();
    var _f2 = /* @__PURE__ */ new Vector3();
    var _center = /* @__PURE__ */ new Vector3();
    var _extents = /* @__PURE__ */ new Vector3();
    var _triangleNormal = /* @__PURE__ */ new Vector3();
    var _testAxis = /* @__PURE__ */ new Vector3();
    function satForAxes(axes, v0, v1, v2, extents) {
      for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
        _testAxis.fromArray(axes, i2);
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          return false;
        }
      }
      return true;
    }
    var _box$2 = /* @__PURE__ */ new Box3();
    var _v1$6 = /* @__PURE__ */ new Vector3();
    var _toFarthestPoint = /* @__PURE__ */ new Vector3();
    var _toPoint = /* @__PURE__ */ new Vector3();
    var Sphere = class {
      constructor(center = new Vector3(), radius = -1) {
        this.center = center;
        this.radius = radius;
      }
      set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      }
      setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$2.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      }
      copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      }
      containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      }
      intersectsBox(box) {
        return box.intersectsSphere(this);
      }
      intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      }
      getBoundingBox(target) {
        if (this.isEmpty()) {
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      }
      applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      }
      translate(offset2) {
        this.center.add(offset2);
        return this;
      }
      expandByPoint(point) {
        _toPoint.subVectors(point, this.center);
        const lengthSq = _toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
          const length = Math.sqrt(lengthSq);
          const missingRadiusHalf = (length - this.radius) * 0.5;
          this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
          this.radius += missingRadiusHalf;
        }
        return this;
      }
      union(sphere) {
        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
        return this;
      }
      equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    var _vector$a = /* @__PURE__ */ new Vector3();
    var _segCenter = /* @__PURE__ */ new Vector3();
    var _segDir = /* @__PURE__ */ new Vector3();
    var _diff = /* @__PURE__ */ new Vector3();
    var _edge1 = /* @__PURE__ */ new Vector3();
    var _edge2 = /* @__PURE__ */ new Vector3();
    var _normal$1 = /* @__PURE__ */ new Vector3();
    var Ray = class {
      constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
        this.origin = origin;
        this.direction = direction;
      }
      set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      }
      copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      }
      at(t, target) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
      }
      lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      }
      recast(t) {
        this.origin.copy(this.at(t, _vector$a));
        return this;
      }
      closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      }
      distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      }
      distanceSqToPoint(point) {
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$a.distanceToSquared(point);
      }
      distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                const invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
      }
      intersectSphere(sphere, target) {
        _vector$a.subVectors(sphere.center, this.origin);
        const tca = _vector$a.dot(this.direction);
        const d2 = _vector$a.dot(_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      }
      intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      }
      distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      }
      intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, target);
      }
      intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      }
      intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      }
      intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
      }
      intersectTriangle(a, b, c, backfaceCulling, target) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal$1.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal$1);
        let sign2;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign2 = 1;
        } else if (DdN < 0) {
          sign2 = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        const QdN = -sign2 * _diff.dot(_normal$1);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      }
      applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      }
      equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    var Matrix4 = class {
      constructor() {
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      clone() {
        return new Matrix4().fromArray(this.elements);
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      }
      copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      }
      setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      }
      extractRotation(m) {
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
          const ae = a * e, af = a * f, be = b * e, bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          const ce = c * e, cf = c * f, de = d * e, df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          const ce = c * e, cf = c * f, de = d * e, df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          const ae = a * e, af = a * f, be = b * e, bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
      }
      lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 1e-4;
          } else {
            _z.z += 1e-4;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      }
      multiply(m, n) {
        if (n !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      }
      transpose() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
      }
      setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y;
          te[14] = z;
        }
        return this;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      }
      scale(v) {
        const te = this.elements;
        const x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      }
      getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      }
      makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationAxis(axis, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      }
      makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      }
      makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
      }
      compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
      decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$5.set(te[0], te[1], te[2]).length();
        const sy = _v1$5.set(te[4], te[5], te[6]).length();
        const sz = _v1$5.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$2.elements[0] *= invSX;
        _m1$2.elements[1] *= invSX;
        _m1$2.elements[2] *= invSX;
        _m1$2.elements[4] *= invSY;
        _m1$2.elements[5] *= invSY;
        _m1$2.elements[6] *= invSY;
        _m1$2.elements[8] *= invSZ;
        _m1$2.elements[9] *= invSZ;
        _m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
      makePerspective(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      }
      makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      }
      equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 16; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      }
      fromArray(array, offset2 = 0) {
        for (let i2 = 0; i2 < 16; i2++) {
          this.elements[i2] = array[i2 + offset2];
        }
        return this;
      }
      toArray(array = [], offset2 = 0) {
        const te = this.elements;
        array[offset2] = te[0];
        array[offset2 + 1] = te[1];
        array[offset2 + 2] = te[2];
        array[offset2 + 3] = te[3];
        array[offset2 + 4] = te[4];
        array[offset2 + 5] = te[5];
        array[offset2 + 6] = te[6];
        array[offset2 + 7] = te[7];
        array[offset2 + 8] = te[8];
        array[offset2 + 9] = te[9];
        array[offset2 + 10] = te[10];
        array[offset2 + 11] = te[11];
        array[offset2 + 12] = te[12];
        array[offset2 + 13] = te[13];
        array[offset2 + 14] = te[14];
        array[offset2 + 15] = te[15];
        return array;
      }
    };
    Matrix4.prototype.isMatrix4 = true;
    var _v1$5 = /* @__PURE__ */ new Vector3();
    var _m1$2 = /* @__PURE__ */ new Matrix4();
    var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
    var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
    var _x = /* @__PURE__ */ new Vector3();
    var _y = /* @__PURE__ */ new Vector3();
    var _z = /* @__PURE__ */ new Vector3();
    var _matrix$1 = /* @__PURE__ */ new Matrix4();
    var _quaternion$3 = /* @__PURE__ */ new Quaternion();
    var Euler = class {
      constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(value) {
        this._order = value;
        this._onChangeCallback();
      }
      set(x, y, z, order = this._order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m, order = this._order, update = true) {
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp4(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp4(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp4(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp4(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp4(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp4(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update === true)
          this._onChangeCallback();
        return this;
      }
      setFromQuaternion(q, order, update) {
        _matrix$1.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix$1, order, update);
      }
      setFromVector3(v, order = this._order) {
        return this.set(v.x, v.y, v.z, order);
      }
      reorder(newOrder) {
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      }
      equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      }
      fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0)
          this._order = array[3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this._x;
        array[offset2 + 1] = this._y;
        array[offset2 + 2] = this._z;
        array[offset2 + 3] = this._order;
        return array;
      }
      toVector3(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new Vector3(this._x, this._y, this._z);
        }
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
    };
    Euler.prototype.isEuler = true;
    Euler.DefaultOrder = "XYZ";
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    var Layers = class {
      constructor() {
        this.mask = 1 | 0;
      }
      set(channel) {
        this.mask = 1 << channel | 0;
      }
      enable(channel) {
        this.mask |= 1 << channel | 0;
      }
      enableAll() {
        this.mask = 4294967295 | 0;
      }
      toggle(channel) {
        this.mask ^= 1 << channel | 0;
      }
      disable(channel) {
        this.mask &= ~(1 << channel | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(layers) {
        return (this.mask & layers.mask) !== 0;
      }
    };
    var _object3DId = 0;
    var _v1$4 = /* @__PURE__ */ new Vector3();
    var _q1 = /* @__PURE__ */ new Quaternion();
    var _m1$1 = /* @__PURE__ */ new Matrix4();
    var _target = /* @__PURE__ */ new Vector3();
    var _position$3 = /* @__PURE__ */ new Vector3();
    var _scale$2 = /* @__PURE__ */ new Vector3();
    var _quaternion$2 = /* @__PURE__ */ new Quaternion();
    var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
    var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
    var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
    var _addedEvent = { type: "added" };
    var _removedEvent = { type: "removed" };
    var Object3D = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: _object3DId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        const position = new Vector3();
        const rotation = new Euler();
        const quaternion = new Quaternion();
        const scale = new Vector3(1, 1, 1);
        function onRotationChange() {
          quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
          rotation.setFromQuaternion(quaternion, void 0, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
          position: {
            configurable: true,
            enumerable: true,
            value: position
          },
          rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
          },
          quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
          },
          scale: {
            configurable: true,
            enumerable: true,
            value: scale
          },
          modelViewMatrix: {
            value: new Matrix4()
          },
          normalMatrix: {
            value: new Matrix3()
          }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
      }
      onBeforeRender() {
      }
      onAfterRender() {
      }
      applyMatrix4(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
      }
      setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      }
      setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      }
      setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
      }
      setRotationFromQuaternion(q) {
        this.quaternion.copy(q);
      }
      rotateOnAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      }
      rotateOnWorldAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      }
      rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      }
      rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      }
      rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      }
      translateOnAxis(axis, distance) {
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      }
      translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
      }
      translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
      }
      translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
      }
      localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(vector) {
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
      }
      lookAt(x, y, z) {
        if (x.isVector3) {
          _target.copy(x);
        } else {
          _target.set(x, y, z);
        }
        const parent2 = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$1.lookAt(_position$3, _target, this.up);
        } else {
          _m1$1.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent2) {
          _m1$1.extractRotation(parent2.matrixWorld);
          _q1.setFromRotationMatrix(_m1$1);
          this.quaternion.premultiply(_q1.invert());
        }
      }
      add(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      }
      remove(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.remove(arguments[i2]);
          }
          return this;
        }
        const index2 = this.children.indexOf(object);
        if (index2 !== -1) {
          object.parent = null;
          this.children.splice(index2, 1);
          object.dispatchEvent(_removedEvent);
        }
        return this;
      }
      removeFromParent() {
        const parent2 = this.parent;
        if (parent2 !== null) {
          parent2.remove(this);
        }
        return this;
      }
      clear() {
        for (let i2 = 0; i2 < this.children.length; i2++) {
          const object = this.children[i2];
          object.parent = null;
          object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
      }
      attach(object) {
        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
      }
      getObjectById(id2) {
        return this.getObjectByProperty("id", id2);
      }
      getObjectByName(name) {
        return this.getObjectByProperty("name", name);
      }
      getObjectByProperty(name, value) {
        if (this[name] === value)
          return this;
        for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
          const child = this.children[i2];
          const object = child.getObjectByProperty(name, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      }
      getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
      }
      getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {
      }
      traverse(callback) {
        callback(this);
        const children2 = this.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          children2[i2].traverse(callback);
        }
      }
      traverseVisible(callback) {
        if (this.visible === false)
          return;
        callback(this);
        const children2 = this.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          children2[i2].traverseVisible(callback);
        }
      }
      traverseAncestors(callback) {
        const parent2 = this.parent;
        if (parent2 !== null) {
          callback(parent2);
          parent2.traverseAncestors(callback);
        }
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        const children2 = this.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          children2[i2].updateMatrixWorld(force);
        }
      }
      updateWorldMatrix(updateParents, updateChildren) {
        const parent2 = this.parent;
        if (updateParents === true && parent2 !== null) {
          parent2.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          const children2 = this.children;
          for (let i2 = 0, l = children2.length; i2 < l; i2++) {
            children2[i2].updateWorldMatrix(false, true);
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        const output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
          if (this.instanceColor !== null)
            object.instanceColor = this.instanceColor.toJSON();
        }
        function serialize(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isScene) {
          if (this.background) {
            if (this.background.isColor) {
              object.background = this.background.toJSON();
            } else if (this.background.isTexture) {
              object.background = this.background.toJSON(meta).uuid;
            }
          }
          if (this.environment && this.environment.isTexture) {
            object.environment = this.environment.toJSON(meta).uuid;
          }
        } else if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          const parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            const shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                const shape = shapes[i2];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== void 0) {
            serialize(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            const uuids = [];
            for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
              uuids.push(serialize(meta.materials, this.material[i2]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (let i2 = 0; i2 < this.children.length; i2++) {
            object.children.push(this.children[i2].toJSON(meta).object);
          }
        }
        if (this.animations.length > 0) {
          object.animations = [];
          for (let i2 = 0; i2 < this.animations.length; i2++) {
            const animation = this.animations[i2];
            object.animations.push(serialize(meta.animations, animation));
          }
        }
        if (isRootObject) {
          const geometries = extractFromCache(meta.geometries);
          const materials = extractFromCache(meta.materials);
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          const shapes = extractFromCache(meta.shapes);
          const skeletons = extractFromCache(meta.skeletons);
          const animations = extractFromCache(meta.animations);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (shapes.length > 0)
            output.shapes = shapes;
          if (skeletons.length > 0)
            output.skeletons = skeletons;
          if (animations.length > 0)
            output.animations = animations;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      }
      clone(recursive) {
        return new this.constructor().copy(this, recursive);
      }
      copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (let i2 = 0; i2 < source.children.length; i2++) {
            const child = source.children[i2];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype.isObject3D = true;
    var _v0$1 = /* @__PURE__ */ new Vector3();
    var _v1$3 = /* @__PURE__ */ new Vector3();
    var _v2$2 = /* @__PURE__ */ new Vector3();
    var _v3$1 = /* @__PURE__ */ new Vector3();
    var _vab = /* @__PURE__ */ new Vector3();
    var _vac = /* @__PURE__ */ new Vector3();
    var _vbc = /* @__PURE__ */ new Vector3();
    var _vap = /* @__PURE__ */ new Vector3();
    var _vbp = /* @__PURE__ */ new Vector3();
    var _vcp = /* @__PURE__ */ new Vector3();
    var Triangle = class {
      constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
        this.a = a;
        this.b = b;
        this.c = c;
      }
      static getNormal(a, b, c, target) {
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      }
      static getBarycoord(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$2.subVectors(point, a);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$2);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      }
      static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, _v3$1);
        return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
      }
      static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3$1.x);
        target.addScaledVector(uv2, _v3$1.y);
        target.addScaledVector(uv3, _v3$1.z);
        return target;
      }
      static isFrontFacing(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
      set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      }
      setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      }
      setFromAttributeAndIndices(attribute, i0, i1, i2) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i1);
        this.c.fromBufferAttribute(attribute, i2);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      }
      getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
      }
      getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
      getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      }
      getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      }
      getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      }
      containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      }
      isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      }
      intersectsBox(box) {
        return box.intersectsTriangle(this);
      }
      closestPointToPoint(p, target) {
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b).addScaledVector(_vbc, w);
        }
        const denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
      }
      equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    var materialId = 0;
    var Material = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: materialId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Material";
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.vertexColors = false;
        this.opacity = 1;
        this.format = RGBAFormat;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) {
          this.version++;
        }
        this._alphaTest = value;
      }
      onBuild() {
      }
      onBeforeRender() {
      }
      onBeforeCompile() {
      }
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(values) {
        if (values === void 0)
          return;
        for (const key in values) {
          const newValue = values[key];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading ? true : false;
            continue;
          }
          const currentValue = this[key];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      }
      toJSON(meta) {
        const isRoot = meta === void 0 || typeof meta === "string";
        if (isRoot) {
          meta = {
            textures: {},
            images: {}
          };
        }
        const data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen !== void 0)
          data.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor)
          data.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== void 0)
          data.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.specularIntensity !== void 0)
          data.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor)
          data.specularColor = this.specularColor.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
          data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture)
          data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          if (this.combine !== void 0)
            data.combine = this.combine;
        }
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== void 0)
          data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== void 0)
          data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.transmission !== void 0)
          data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture)
          data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== void 0)
          data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture)
          data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== void 0)
          data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== void 0)
          data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== void 0)
          data.size = this.size;
        if (this.shadowSide !== null)
          data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
          data.blending = this.blending;
        if (this.side !== FrontSide)
          data.side = this.side;
        if (this.vertexColors)
          data.vertexColors = true;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.format !== RGBAFormat)
          data.format = this.format;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.colorWrite = this.colorWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true)
          data.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data2 = cache[key];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRoot) {
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.format = source.format;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
          const n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2) {
            dstPlanes[i2] = srcPlanes[i2].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
    };
    Material.prototype.isMaterial = true;
    var _colorKeywords = {
      "aliceblue": 15792383,
      "antiquewhite": 16444375,
      "aqua": 65535,
      "aquamarine": 8388564,
      "azure": 15794175,
      "beige": 16119260,
      "bisque": 16770244,
      "black": 0,
      "blanchedalmond": 16772045,
      "blue": 255,
      "blueviolet": 9055202,
      "brown": 10824234,
      "burlywood": 14596231,
      "cadetblue": 6266528,
      "chartreuse": 8388352,
      "chocolate": 13789470,
      "coral": 16744272,
      "cornflowerblue": 6591981,
      "cornsilk": 16775388,
      "crimson": 14423100,
      "cyan": 65535,
      "darkblue": 139,
      "darkcyan": 35723,
      "darkgoldenrod": 12092939,
      "darkgray": 11119017,
      "darkgreen": 25600,
      "darkgrey": 11119017,
      "darkkhaki": 12433259,
      "darkmagenta": 9109643,
      "darkolivegreen": 5597999,
      "darkorange": 16747520,
      "darkorchid": 10040012,
      "darkred": 9109504,
      "darksalmon": 15308410,
      "darkseagreen": 9419919,
      "darkslateblue": 4734347,
      "darkslategray": 3100495,
      "darkslategrey": 3100495,
      "darkturquoise": 52945,
      "darkviolet": 9699539,
      "deeppink": 16716947,
      "deepskyblue": 49151,
      "dimgray": 6908265,
      "dimgrey": 6908265,
      "dodgerblue": 2003199,
      "firebrick": 11674146,
      "floralwhite": 16775920,
      "forestgreen": 2263842,
      "fuchsia": 16711935,
      "gainsboro": 14474460,
      "ghostwhite": 16316671,
      "gold": 16766720,
      "goldenrod": 14329120,
      "gray": 8421504,
      "green": 32768,
      "greenyellow": 11403055,
      "grey": 8421504,
      "honeydew": 15794160,
      "hotpink": 16738740,
      "indianred": 13458524,
      "indigo": 4915330,
      "ivory": 16777200,
      "khaki": 15787660,
      "lavender": 15132410,
      "lavenderblush": 16773365,
      "lawngreen": 8190976,
      "lemonchiffon": 16775885,
      "lightblue": 11393254,
      "lightcoral": 15761536,
      "lightcyan": 14745599,
      "lightgoldenrodyellow": 16448210,
      "lightgray": 13882323,
      "lightgreen": 9498256,
      "lightgrey": 13882323,
      "lightpink": 16758465,
      "lightsalmon": 16752762,
      "lightseagreen": 2142890,
      "lightskyblue": 8900346,
      "lightslategray": 7833753,
      "lightslategrey": 7833753,
      "lightsteelblue": 11584734,
      "lightyellow": 16777184,
      "lime": 65280,
      "limegreen": 3329330,
      "linen": 16445670,
      "magenta": 16711935,
      "maroon": 8388608,
      "mediumaquamarine": 6737322,
      "mediumblue": 205,
      "mediumorchid": 12211667,
      "mediumpurple": 9662683,
      "mediumseagreen": 3978097,
      "mediumslateblue": 8087790,
      "mediumspringgreen": 64154,
      "mediumturquoise": 4772300,
      "mediumvioletred": 13047173,
      "midnightblue": 1644912,
      "mintcream": 16121850,
      "mistyrose": 16770273,
      "moccasin": 16770229,
      "navajowhite": 16768685,
      "navy": 128,
      "oldlace": 16643558,
      "olive": 8421376,
      "olivedrab": 7048739,
      "orange": 16753920,
      "orangered": 16729344,
      "orchid": 14315734,
      "palegoldenrod": 15657130,
      "palegreen": 10025880,
      "paleturquoise": 11529966,
      "palevioletred": 14381203,
      "papayawhip": 16773077,
      "peachpuff": 16767673,
      "peru": 13468991,
      "pink": 16761035,
      "plum": 14524637,
      "powderblue": 11591910,
      "purple": 8388736,
      "rebeccapurple": 6697881,
      "red": 16711680,
      "rosybrown": 12357519,
      "royalblue": 4286945,
      "saddlebrown": 9127187,
      "salmon": 16416882,
      "sandybrown": 16032864,
      "seagreen": 3050327,
      "seashell": 16774638,
      "sienna": 10506797,
      "silver": 12632256,
      "skyblue": 8900331,
      "slateblue": 6970061,
      "slategray": 7372944,
      "slategrey": 7372944,
      "snow": 16775930,
      "springgreen": 65407,
      "steelblue": 4620980,
      "tan": 13808780,
      "teal": 32896,
      "thistle": 14204888,
      "tomato": 16737095,
      "turquoise": 4251856,
      "violet": 15631086,
      "wheat": 16113331,
      "white": 16777215,
      "whitesmoke": 16119285,
      "yellow": 16776960,
      "yellowgreen": 10145074
    };
    var _hslA = { h: 0, s: 0, l: 0 };
    var _hslB = { h: 0, s: 0, l: 0 };
    function hue2rgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }
    function SRGBToLinear(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB(c) {
      return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }
    var Color = class {
      constructor(r, g, b) {
        if (g === void 0 && b === void 0) {
          return this.set(r);
        }
        return this.setRGB(r, g, b);
      }
      set(value) {
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
        return this;
      }
      setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      }
      setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      }
      setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      }
      setHSL(h, s, l) {
        h = euclideanModulo(h, 1);
        s = clamp4(s, 0, 1);
        l = clamp4(l, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          const q = 2 * l - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
      }
      setStyle(style) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
          let color;
          const name = m[1];
          const components = m[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[4]);
                return this;
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[4]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                const h = parseFloat(color[1]) / 360;
                const s = parseInt(color[2], 10) / 100;
                const l = parseInt(color[3], 10) / 100;
                handleAlpha(color[4]);
                return this.setHSL(h, s, l);
              }
              break;
          }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          const hex = m[1];
          const size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style);
        }
        return this;
      }
      setColorName(style) {
        const hex = _colorKeywords[style.toLowerCase()];
        if (hex !== void 0) {
          this.setHex(hex);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      }
      copyGammaToLinear(color, gammaFactor = 2) {
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      }
      copyLinearToGamma(color, gammaFactor = 2) {
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      }
      convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
      }
      convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
      }
      copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      }
      copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      }
      convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      }
      convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      }
      getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(target) {
        const r = this.r, g = this.g, b = this.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          const delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      }
      getStyle() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
      }
      offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
      }
      add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      }
      addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      }
      addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      }
      sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      }
      multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      }
      multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      }
      lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      }
      lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      }
      lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = lerp2(_hslA.h, _hslB.h, alpha);
        const s = lerp2(_hslA.s, _hslB.s, alpha);
        const l = lerp2(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
      }
      equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      }
      fromArray(array, offset2 = 0) {
        this.r = array[offset2];
        this.g = array[offset2 + 1];
        this.b = array[offset2 + 2];
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this.r;
        array[offset2 + 1] = this.g;
        array[offset2 + 2] = this.b;
        return array;
      }
      fromBufferAttribute(attribute, index2) {
        this.r = attribute.getX(index2);
        this.g = attribute.getY(index2);
        this.b = attribute.getZ(index2);
        if (attribute.normalized === true) {
          this.r /= 255;
          this.g /= 255;
          this.b /= 255;
        }
        return this;
      }
      toJSON() {
        return this.getHex();
      }
    };
    Color.NAMES = _colorKeywords;
    Color.prototype.isColor = true;
    Color.prototype.r = 1;
    Color.prototype.g = 1;
    Color.prototype.b = 1;
    var MeshBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    var _vector$9 = /* @__PURE__ */ new Vector3();
    var _vector2$1 = /* @__PURE__ */ new Vector2();
    var BufferAttribute = class {
      constructor(array, itemSize, normalized) {
        if (Array.isArray(array)) {
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        }
        this.name = "";
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== void 0 ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      copyArray(array) {
        this.array.set(array);
        return this;
      }
      copyColorsArray(colors) {
        const array = this.array;
        let offset2 = 0;
        for (let i2 = 0, l = colors.length; i2 < l; i2++) {
          let color = colors[i2];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
            color = new Color();
          }
          array[offset2++] = color.r;
          array[offset2++] = color.g;
          array[offset2++] = color.b;
        }
        return this;
      }
      copyVector2sArray(vectors) {
        const array = this.array;
        let offset2 = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
            vector = new Vector2();
          }
          array[offset2++] = vector.x;
          array[offset2++] = vector.y;
        }
        return this;
      }
      copyVector3sArray(vectors) {
        const array = this.array;
        let offset2 = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
            vector = new Vector3();
          }
          array[offset2++] = vector.x;
          array[offset2++] = vector.y;
          array[offset2++] = vector.z;
        }
        return this;
      }
      copyVector4sArray(vectors) {
        const array = this.array;
        let offset2 = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
            vector = new Vector4();
          }
          array[offset2++] = vector.x;
          array[offset2++] = vector.y;
          array[offset2++] = vector.z;
          array[offset2++] = vector.w;
        }
        return this;
      }
      applyMatrix3(m) {
        if (this.itemSize === 2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector2$1.fromBufferAttribute(this, i2);
            _vector2$1.applyMatrix3(m);
            this.setXY(i2, _vector2$1.x, _vector2$1.y);
          }
        } else if (this.itemSize === 3) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.fromBufferAttribute(this, i2);
            _vector$9.applyMatrix3(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
        }
        return this;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.x = this.getX(i2);
          _vector$9.y = this.getY(i2);
          _vector$9.z = this.getZ(i2);
          _vector$9.applyMatrix4(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.x = this.getX(i2);
          _vector$9.y = this.getY(i2);
          _vector$9.z = this.getZ(i2);
          _vector$9.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.x = this.getX(i2);
          _vector$9.y = this.getY(i2);
          _vector$9.z = this.getZ(i2);
          _vector$9.transformDirection(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      set(value, offset2 = 0) {
        this.array.set(value, offset2);
        return this;
      }
      getX(index2) {
        return this.array[index2 * this.itemSize];
      }
      setX(index2, x) {
        this.array[index2 * this.itemSize] = x;
        return this;
      }
      getY(index2) {
        return this.array[index2 * this.itemSize + 1];
      }
      setY(index2, y) {
        this.array[index2 * this.itemSize + 1] = y;
        return this;
      }
      getZ(index2) {
        return this.array[index2 * this.itemSize + 2];
      }
      setZ(index2, z) {
        this.array[index2 * this.itemSize + 2] = z;
        return this;
      }
      getW(index2) {
        return this.array[index2 * this.itemSize + 3];
      }
      setW(index2, w) {
        this.array[index2 * this.itemSize + 3] = w;
        return this;
      }
      setXY(index2, x, y) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y;
        return this;
      }
      setXYZ(index2, x, y, z) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y;
        this.array[index2 + 2] = z;
        return this;
      }
      setXYZW(index2, x, y, z, w) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y;
        this.array[index2 + 2] = z;
        this.array[index2 + 3] = w;
        return this;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const data = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
        if (this.name !== "")
          data.name = this.name;
        if (this.usage !== StaticDrawUsage)
          data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
          data.updateRange = this.updateRange;
        return data;
      }
    };
    BufferAttribute.prototype.isBufferAttribute = true;
    var Uint16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
      }
    };
    var Uint32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint32Array(array), itemSize, normalized);
      }
    };
    var Float16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
      }
    };
    Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
    var Float32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Float32Array(array), itemSize, normalized);
      }
    };
    var _id = 0;
    var _m1 = /* @__PURE__ */ new Matrix4();
    var _obj = /* @__PURE__ */ new Object3D();
    var _offset = /* @__PURE__ */ new Vector3();
    var _box$1 = /* @__PURE__ */ new Box3();
    var _boxMorphTargets = /* @__PURE__ */ new Box3();
    var _vector$8 = /* @__PURE__ */ new Vector3();
    var BufferGeometry = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: _id++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(index2) {
        if (Array.isArray(index2)) {
          this.index = new (arrayMax(index2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
        } else {
          this.index = index2;
        }
        return this;
      }
      getAttribute(name) {
        return this.attributes[name];
      }
      setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      }
      deleteAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      hasAttribute(name) {
        return this.attributes[name] !== void 0;
      }
      addGroup(start, count, materialIndex = 0) {
        this.groups.push({
          start,
          count,
          materialIndex
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      }
      applyMatrix4(matrix) {
        const position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== void 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
      applyQuaternion(q) {
        _m1.makeRotationFromQuaternion(q);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateX(angle) {
        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateY(angle) {
        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateZ(angle) {
        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      translate(x, y, z) {
        _m1.makeTranslation(x, y, z);
        this.applyMatrix4(_m1);
        return this;
      }
      scale(x, y, z) {
        _m1.makeScale(x, y, z);
        this.applyMatrix4(_m1);
        return this;
      }
      lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      }
      center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      }
      setFromPoints(points) {
        const position = [];
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
          return;
        }
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _box$1.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                this.boundingBox.expandByPoint(_vector$8);
                _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                this.boundingBox.expandByPoint(_vector$8);
              } else {
                this.boundingBox.expandByPoint(_box$1.min);
                this.boundingBox.expandByPoint(_box$1.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingSphere.set(new Vector3(), Infinity);
          return;
        }
        if (position) {
          const center = this.boundingSphere.center;
          _box$1.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                _box$1.expandByPoint(_vector$8);
                _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                _box$1.expandByPoint(_vector$8);
              } else {
                _box$1.expandByPoint(_boxMorphTargets.min);
                _box$1.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$1.getCenter(center);
          let maxRadiusSq = 0;
          for (let i2 = 0, il = position.count; i2 < il; i2++) {
            _vector$8.fromBufferAttribute(position, i2);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              const morphTargetsRelative = this.morphTargetsRelative;
              for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                _vector$8.fromBufferAttribute(morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j);
                  _vector$8.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      }
      computeTangents() {
        const index2 = this.index;
        const attributes = this.attributes;
        if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        const indices = index2.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (attributes.tangent === void 0) {
          this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        const tangents = attributes.tangent.array;
        const tan1 = [], tan2 = [];
        for (let i2 = 0; i2 < nVertices; i2++) {
          tan1[i2] = new Vector3();
          tan2[i2] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a, b, c) {
          vA.fromArray(positions, a * 3);
          vB.fromArray(positions, b * 3);
          vC.fromArray(positions, c * 3);
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b * 2);
          uvC.fromArray(uvs, c * 2);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
          if (!isFinite(r))
            return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.length
          }];
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
          }
        }
        const tmp2 = new Vector3(), tmp22 = new Vector3();
        const n = new Vector3(), n2 = new Vector3();
        function handleVertex(v) {
          n.fromArray(normals, v * 3);
          n2.copy(n);
          const t = tan1[v];
          tmp2.copy(t);
          tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
          tmp22.crossVectors(n2, t);
          const test = tmp22.dot(tan2[v]);
          const w = test < 0 ? -1 : 1;
          tangents[v * 4] = tmp2.x;
          tangents[v * 4 + 1] = tmp2.y;
          tangents[v * 4 + 2] = tmp2.z;
          tangents[v * 4 + 3] = w;
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            handleVertex(indices[j + 0]);
            handleVertex(indices[j + 1]);
            handleVertex(indices[j + 2]);
          }
        }
      }
      computeVertexNormals() {
        const index2 = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          let normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
              normalAttribute.setXYZ(i2, 0, 0, 0);
            }
          }
          const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
          const cb = new Vector3(), ab = new Vector3();
          if (index2) {
            for (let i2 = 0, il = index2.count; i2 < il; i2 += 3) {
              const vA = index2.getX(i2 + 0);
              const vB = index2.getX(i2 + 1);
              const vC = index2.getX(i2 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
              pA.fromBufferAttribute(positionAttribute, i2 + 0);
              pB.fromBufferAttribute(positionAttribute, i2 + 1);
              pC.fromBufferAttribute(positionAttribute, i2 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      }
      merge(geometry, offset2) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset2 === void 0) {
          offset2 = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          if (geometry.attributes[key] === void 0)
            continue;
          const attribute1 = attributes[key];
          const attributeArray1 = attribute1.array;
          const attribute2 = geometry.attributes[key];
          const attributeArray2 = attribute2.array;
          const attributeOffset = attribute2.itemSize * offset2;
          const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
            attributeArray1[j] = attributeArray2[i2];
          }
        }
        return this;
      }
      normalizeNormals() {
        const normals = this.attributes.normal;
        for (let i2 = 0, il = normals.count; i2 < il; i2++) {
          _vector$8.fromBufferAttribute(normals, i2);
          _vector$8.normalize();
          normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
      }
      toNonIndexed() {
        function convertBufferAttribute(attribute, indices2) {
          const array = attribute.array;
          const itemSize = attribute.itemSize;
          const normalized = attribute.normalized;
          const array2 = new array.constructor(indices2.length * itemSize);
          let index2 = 0, index22 = 0;
          for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
            if (attribute.isInterleavedBufferAttribute) {
              index2 = indices2[i2] * attribute.data.stride + attribute.offset;
            } else {
              index2 = indices2[i2] * itemSize;
            }
            for (let j = 0; j < itemSize; j++) {
              array2[index22++] = array[index2++];
            }
          }
          return new BufferAttribute(array2, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
          return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          const newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for (const name in morphAttributes) {
          const morphArray = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
            const attribute = morphAttribute[i2];
            const newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = { attributes: {} };
        const index2 = this.index;
        if (index2 !== null) {
          data.data.index = {
            type: index2.array.constructor.name,
            array: Array.prototype.slice.call(index2.array)
          };
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for (const key in this.morphAttributes) {
          const attributeArray = this.morphAttributes[key];
          const array = [];
          for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
            const attribute = attributeArray[i2];
            array.push(attribute.toJSON(data.data));
          }
          if (array.length > 0) {
            morphAttributes[key] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index2 = source.index;
        if (index2 !== null) {
          this.setIndex(index2.clone(data));
        }
        const attributes = source.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for (const name in morphAttributes) {
          const array = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
            array.push(morphAttribute[i2].clone(data));
          }
          this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        if (source.parameters !== void 0)
          this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    BufferGeometry.prototype.isBufferGeometry = true;
    var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
    var _ray$2 = /* @__PURE__ */ new Ray();
    var _sphere$3 = /* @__PURE__ */ new Sphere();
    var _vA$1 = /* @__PURE__ */ new Vector3();
    var _vB$1 = /* @__PURE__ */ new Vector3();
    var _vC$1 = /* @__PURE__ */ new Vector3();
    var _tempA = /* @__PURE__ */ new Vector3();
    var _tempB = /* @__PURE__ */ new Vector3();
    var _tempC = /* @__PURE__ */ new Vector3();
    var _morphA = /* @__PURE__ */ new Vector3();
    var _morphB = /* @__PURE__ */ new Vector3();
    var _morphC = /* @__PURE__ */ new Vector3();
    var _uvA$1 = /* @__PURE__ */ new Vector2();
    var _uvB$1 = /* @__PURE__ */ new Vector2();
    var _uvC$1 = /* @__PURE__ */ new Vector2();
    var _intersectionPoint = /* @__PURE__ */ new Vector3();
    var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
    var Mesh = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
        super();
        this.type = "Mesh";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
          return;
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        if (geometry.boundingBox !== null) {
          if (_ray$2.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
          const index2 = geometry.index;
          const position = geometry.attributes.position;
          const morphPosition = geometry.morphAttributes.position;
          const morphTargetsRelative = geometry.morphTargetsRelative;
          const uv = geometry.attributes.uv;
          const uv2 = geometry.attributes.uv2;
          const groups = geometry.groups;
          const drawRange = geometry.drawRange;
          if (index2 !== null) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = index2.getX(j);
                  const b = index2.getX(j + 1);
                  const c = index2.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index2.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = index2.getX(i2);
                const b = index2.getX(i2 + 1);
                const c = index2.getX(i2 + 2);
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = j;
                  const b = j + 1;
                  const c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(position.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = i2;
                const b = i2 + 1;
                const c = i2 + 2;
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    };
    Mesh.prototype.isMesh = true;
    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
      let intersect;
      if (material.side === BackSide) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
      }
      if (intersect === null)
        return null;
      _intersectionPointWorld.copy(point);
      _intersectionPointWorld.applyMatrix4(object.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far)
        return null;
      return {
        distance,
        point: _intersectionPointWorld.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
      _vA$1.fromBufferAttribute(position, a);
      _vB$1.fromBufferAttribute(position, b);
      _vC$1.fromBufferAttribute(position, c);
      const morphInfluences = object.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
          const influence = morphInfluences[i2];
          const morphAttribute = morphPosition[i2];
          if (influence === 0)
            continue;
          _tempA.fromBufferAttribute(morphAttribute, a);
          _tempB.fromBufferAttribute(morphAttribute, b);
          _tempC.fromBufferAttribute(morphAttribute, c);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
            _morphB.addScaledVector(_tempB, influence);
            _morphC.addScaledVector(_tempC, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
            _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
            _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
          }
        }
        _vA$1.add(_morphA);
        _vB$1.add(_morphB);
        _vC$1.add(_morphC);
      }
      if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA$1);
        object.boneTransform(b, _vB$1);
        object.boneTransform(c, _vC$1);
      }
      const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
      if (intersection) {
        if (uv) {
          _uvA$1.fromBufferAttribute(uv, a);
          _uvB$1.fromBufferAttribute(uv, b);
          _uvC$1.fromBufferAttribute(uv, c);
          intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
        }
        if (uv2) {
          _uvA$1.fromBufferAttribute(uv2, a);
          _uvB$1.fromBufferAttribute(uv2, b);
          _uvC$1.fromBufferAttribute(uv2, c);
          intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
        }
        const face = {
          a,
          b,
          c,
          normal: new Vector3(),
          materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
        intersection.face = face;
      }
      return intersection;
    }
    var BoxGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          const segmentWidth = width2 / gridX;
          const segmentHeight = height2 / gridY;
          const widthHalf = width2 / 2;
          const heightHalf = height2 / 2;
          const depthHalf = depth2 / 2;
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          let vertexCounter = 0;
          let groupCount = 0;
          const vector = new Vector3();
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segmentHeight - heightHalf;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segmentWidth - widthHalf;
              vector[u] = x * udir;
              vector[v] = y * vdir;
              vector[w] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u] = 0;
              vector[v] = 0;
              vector[w] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = numberOfVertices + ix + gridX1 * iy;
              const b = numberOfVertices + ix + gridX1 * (iy + 1);
              const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              const d = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
      static fromJSON(data) {
        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
      }
    };
    function cloneUniforms(src2) {
      const dst = {};
      for (const u in src2) {
        dst[u] = {};
        for (const p in src2[u]) {
          const property = src2[u][p];
          if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
            dst[u][p] = property.clone();
          } else if (Array.isArray(property)) {
            dst[u][p] = property.slice();
          } else {
            dst[u][p] = property;
          }
        }
      }
      return dst;
    }
    function mergeUniforms(uniforms) {
      const merged = {};
      for (let u = 0; u < uniforms.length; u++) {
        const tmp2 = cloneUniforms(uniforms[u]);
        for (const p in tmp2) {
          merged[p] = tmp2[p];
        }
      }
      return merged;
    }
    var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    var ShaderMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.extensions = {
          derivatives: false,
          fragDepth: false,
          drawBuffers: false,
          shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
          "color": [1, 1, 1],
          "uv": [0, 0],
          "uv2": [0, 0]
        };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== void 0) {
          if (parameters.attributes !== void 0) {
            console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
          }
          this.setValues(parameters);
        }
      }
      copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for (const name in this.uniforms) {
          const uniform = this.uniforms[name];
          const value = uniform.value;
          if (value && value.isTexture) {
            data.uniforms[name] = {
              type: "t",
              value: value.toJSON(meta).uuid
            };
          } else if (value && value.isColor) {
            data.uniforms[name] = {
              type: "c",
              value: value.getHex()
            };
          } else if (value && value.isVector2) {
            data.uniforms[name] = {
              type: "v2",
              value: value.toArray()
            };
          } else if (value && value.isVector3) {
            data.uniforms[name] = {
              type: "v3",
              value: value.toArray()
            };
          } else if (value && value.isVector4) {
            data.uniforms[name] = {
              type: "v4",
              value: value.toArray()
            };
          } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
              type: "m3",
              value: value.toArray()
            };
          } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
              type: "m4",
              value: value.toArray()
            };
          } else {
            data.uniforms[name] = {
              value
            };
          }
        }
        if (Object.keys(this.defines).length > 0)
          data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {};
        for (const key in this.extensions) {
          if (this.extensions[key] === true)
            extensions[key] = true;
        }
        if (Object.keys(extensions).length > 0)
          data.extensions = extensions;
        return data;
      }
    };
    ShaderMaterial.prototype.isShaderMaterial = true;
    var Camera = class extends Object3D {
      constructor() {
        super();
        this.type = "Camera";
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Camera.prototype.isCamera = true;
    var PerspectiveCamera = class extends Camera {
      constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
        super();
        this.type = "PerspectiveCamera";
        this.fov = fov2;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect2;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      }
      setFocalLength(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      }
      getFocalLength() {
        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      }
      getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
          const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    };
    PerspectiveCamera.prototype.isPerspectiveCamera = true;
    var fov = 90;
    var aspect = 1;
    var CubeCamera = class extends Object3D {
      constructor(near, far, renderTarget) {
        super();
        this.type = "CubeCamera";
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
          console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          return;
        }
        this.renderTarget = renderTarget;
        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
      }
      update(renderer, scene) {
        if (this.parent === null)
          this.updateMatrixWorld();
        const renderTarget = this.renderTarget;
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
      }
    };
    var CubeTexture = class extends Texture {
      constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== void 0 ? images : [];
        mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images(value) {
        this.image = value;
      }
    };
    CubeTexture.prototype.isCubeTexture = true;
    var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
      constructor(size, options, dummy) {
        if (Number.isInteger(options)) {
          console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
          options = dummy;
        }
        super(size, size, options);
        options = options || {};
        this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        this.texture._needsFlipEnvMap = false;
      }
      fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.format = RGBAFormat;
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: `
  
                  varying vec3 vWorldDirection;
  
                  vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
  
                      return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
  
                  }
  
                  void main() {
  
                      vWorldDirection = transformDirection( position, modelMatrix );
  
                      #include <begin_vertex>
                      #include <project_vertex>
  
                  }
              `,
          fragmentShader: `
  
                  uniform sampler2D tEquirect;
  
                  varying vec3 vWorldDirection;
  
                  #include <common>
  
                  void main() {
  
                      vec3 direction = normalize( vWorldDirection );
  
                      vec2 sampleUV = equirectUv( direction );
  
                      gl_FragColor = texture2D( tEquirect, sampleUV );
  
                  }
              `
        };
        const geometry = new BoxGeometry(5, 5, 5);
        const material = new ShaderMaterial({
          name: "CubemapFromEquirect",
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide,
          blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new Mesh(geometry, material);
        const currentMinFilter = texture.minFilter;
        if (texture.minFilter === LinearMipmapLinearFilter)
          texture.minFilter = LinearFilter;
        const camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      }
      clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for (let i2 = 0; i2 < 6; i2++) {
          renderer.setRenderTarget(this, i2);
          renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
      }
    };
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    var _vector1 = /* @__PURE__ */ new Vector3();
    var _vector2 = /* @__PURE__ */ new Vector3();
    var _normalMatrix = /* @__PURE__ */ new Matrix3();
    var Plane = class {
      constructor(normal = new Vector3(1, 0, 0), constant = 0) {
        this.normal = normal;
        this.constant = constant;
      }
      set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      }
      setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      }
      setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      }
      setFromCoplanarPoints(a, b, c) {
        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      }
      copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      }
      normalize() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      }
      negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      }
      distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      }
      distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      }
      projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      }
      intersectLine(line, target) {
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return null;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return null;
        }
        return target.copy(direction).multiplyScalar(t).add(line.start);
      }
      intersectsLine(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      }
      intersectsBox(box) {
        return box.intersectsPlane(this);
      }
      intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      }
      coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      }
      translate(offset2) {
        this.constant -= offset2.dot(this.normal);
        return this;
      }
      equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Plane.prototype.isPlane = true;
    var _sphere$2 = /* @__PURE__ */ new Sphere();
    var _vector$7 = /* @__PURE__ */ new Vector3();
    var Frustum = class {
      constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
        this.planes = [p0, p1, p2, p3, p4, p5];
      }
      set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      }
      copy(frustum) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          planes[i2].copy(frustum.planes[i2]);
        }
        return this;
      }
      setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      }
      intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSprite(sprite) {
        _sphere$2.center.set(0, 0, 0);
        _sphere$2.radius = 0.7071067811865476;
        _sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for (let i2 = 0; i2 < 6; i2++) {
          const distance = planes[i2].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      }
      intersectsBox(box) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          const plane = planes[i2];
          _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$7) < 0) {
            return false;
          }
        }
        return true;
      }
      containsPoint(point) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          if (planes[i2].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    function WebGLAnimation() {
      let context3 = null;
      let isAnimating = false;
      let animationLoop = null;
      let requestId = null;
      function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context3.requestAnimationFrame(onAnimationFrame);
      }
      return {
        start: function() {
          if (isAnimating === true)
            return;
          if (animationLoop === null)
            return;
          requestId = context3.requestAnimationFrame(onAnimationFrame);
          isAnimating = true;
        },
        stop: function() {
          context3.cancelAnimationFrame(requestId);
          isAnimating = false;
        },
        setAnimationLoop: function(callback) {
          animationLoop = callback;
        },
        setContext: function(value) {
          context3 = value;
        }
      };
    }
    function WebGLAttributes(gl, capabilities) {
      const isWebGL2 = capabilities.isWebGL2;
      const buffers = new WeakMap();
      function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = 5126;
        if (array instanceof Float32Array) {
          type = 5126;
        } else if (array instanceof Float64Array) {
          console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
        } else if (array instanceof Uint16Array) {
          if (attribute.isFloat16BufferAttribute) {
            if (isWebGL2) {
              type = 5131;
            } else {
              console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            }
          } else {
            type = 5123;
          }
        } else if (array instanceof Int16Array) {
          type = 5122;
        } else if (array instanceof Uint32Array) {
          type = 5125;
        } else if (array instanceof Int32Array) {
          type = 5124;
        } else if (array instanceof Int8Array) {
          type = 5120;
        } else if (array instanceof Uint8Array) {
          type = 5121;
        } else if (array instanceof Uint8ClampedArray) {
          type = 5121;
        }
        return {
          buffer,
          type,
          bytesPerElement: array.BYTES_PER_ELEMENT,
          version: attribute.version
        };
      }
      function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) {
          gl.bufferSubData(bufferType, 0, array);
        } else {
          if (isWebGL2) {
            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
          } else {
            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
          }
          updateRange.count = -1;
        }
      }
      function get(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        return buffers.get(attribute);
      }
      function remove2(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
          gl.deleteBuffer(data.buffer);
          buffers.delete(attribute);
        }
      }
      function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
          const cached = buffers.get(attribute);
          if (!cached || cached.version < attribute.version) {
            buffers.set(attribute, {
              buffer: attribute.buffer,
              type: attribute.type,
              bytesPerElement: attribute.elementSize,
              version: attribute.version
            });
          }
          return;
        }
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === void 0) {
          buffers.set(attribute, createBuffer(attribute, bufferType));
        } else if (data.version < attribute.version) {
          updateBuffer(data.buffer, attribute, bufferType);
          data.version = attribute.version;
        }
      }
      return {
        get,
        remove: remove2,
        update
      };
    }
    var PlaneGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
        super();
        this.type = "PlaneGeometry";
        this.parameters = {
          width,
          height,
          widthSegments,
          heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segment_height - height_half;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segment_width - width_half;
            vertices.push(x, -y, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = ix + gridX1 * iy;
            const b = ix + gridX1 * (iy + 1);
            const c = ix + 1 + gridX1 * (iy + 1);
            const d = ix + 1 + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
      }
    };
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
    var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
    var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    var begin_vertex = "vec3 transformed = vec3( position );";
    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
    var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
    var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
    var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
    var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
    var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
    var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
    var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
    var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
    var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
    var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
    var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
    var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
    var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
    var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
    var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
    var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
    var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
    var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
    var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
    var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var ShaderChunk = {
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      alphatest_pars_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      encodings_fragment,
      encodings_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_fragment,
      lightmap_pars_fragment,
      lights_lambert_vertex,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normal_pars_fragment,
      normal_pars_vertex,
      normal_vertex,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment,
      output_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      transmission_fragment,
      transmission_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      uv2_pars_fragment,
      uv2_pars_vertex,
      uv2_vertex,
      worldpos_vertex,
      background_vert: vertex$g,
      background_frag: fragment$g,
      cube_vert: vertex$f,
      cube_frag: fragment$f,
      depth_vert: vertex$e,
      depth_frag: fragment$e,
      distanceRGBA_vert: vertex$d,
      distanceRGBA_frag: fragment$d,
      equirect_vert: vertex$c,
      equirect_frag: fragment$c,
      linedashed_vert: vertex$b,
      linedashed_frag: fragment$b,
      meshbasic_vert: vertex$a,
      meshbasic_frag: fragment$a,
      meshlambert_vert: vertex$9,
      meshlambert_frag: fragment$9,
      meshmatcap_vert: vertex$8,
      meshmatcap_frag: fragment$8,
      meshnormal_vert: vertex$7,
      meshnormal_frag: fragment$7,
      meshphong_vert: vertex$6,
      meshphong_frag: fragment$6,
      meshphysical_vert: vertex$5,
      meshphysical_frag: fragment$5,
      meshtoon_vert: vertex$4,
      meshtoon_frag: fragment$4,
      points_vert: vertex$3,
      points_frag: fragment$3,
      shadow_vert: vertex$2,
      shadow_frag: fragment$2,
      sprite_vert: vertex$1,
      sprite_frag: fragment$1
    };
    var UniformsLib = {
      common: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new Matrix3() },
        uv2Transform: { value: new Matrix3() },
        alphaMap: { value: null },
        alphaTest: { value: 0 }
      },
      specularmap: {
        specularMap: { value: null }
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 }
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 }
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
      },
      emissivemap: {
        emissiveMap: { value: null }
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpScale: { value: 1 }
      },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new Vector2(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: {
        roughnessMap: { value: null }
      },
      metalnessmap: {
        metalnessMap: { value: null }
      },
      gradientmap: {
        gradientMap: { value: null }
      },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Color(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: { value: [], properties: {
          direction: {},
          color: {}
        } },
        directionalLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        } },
        spotLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: { value: [], properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        } },
        pointLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        } },
        rectAreaLights: { value: [], properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        } },
        ltc_1: { value: null },
        ltc_2: { value: null }
      },
      points: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new Matrix3() }
      },
      sprite: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        center: { value: new Vector2(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new Matrix3() }
      }
    };
    var ShaderLib = {
      basic: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            specular: { value: new Color(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.roughnessmap,
          UniformsLib.metalnessmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.gradientmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          {
            matcap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: mergeUniforms([
          UniformsLib.points,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
      },
      sprite: {
        uniforms: mergeUniforms([
          UniformsLib.sprite,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: { value: new Matrix3() },
          t2D: { value: null }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      cube: {
        uniforms: mergeUniforms([
          UniformsLib.envmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap,
          {
            referencePosition: { value: new Vector3() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: mergeUniforms([
          UniformsLib.lights,
          UniformsLib.fog,
          {
            color: { value: new Color(0) },
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new Vector2(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: new Color(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 0 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: new Vector2() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: new Color(0) },
          specularIntensity: { value: 0 },
          specularIntensityMap: { value: null },
          specularColor: { value: new Color(1, 1, 1) },
          specularColorMap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
      const clearColor = new Color(0);
      let clearAlpha = 0;
      let planeMesh;
      let boxMesh;
      let currentBackground = null;
      let currentBackgroundVersion = 0;
      let currentTonemapping = null;
      function render4(renderList, scene) {
        let forceClear = false;
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) {
          background = cubemaps.get(background);
        }
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === "additive") {
          background = null;
        }
        if (background === null) {
          setClear(clearColor, clearAlpha);
        } else if (background && background.isColor) {
          setClear(background, 1);
          forceClear = true;
        }
        if (renderer.autoClear || forceClear) {
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        }
        if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
          if (boxMesh === void 0) {
            boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.cube.uniforms),
              vertexShader: ShaderLib.cube.vertexShader,
              fragmentShader: ShaderLib.cube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            boxMesh.geometry.deleteAttribute("normal");
            boxMesh.geometry.deleteAttribute("uv");
            boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
              this.matrixWorld.copyPosition(camera.matrixWorld);
            };
            Object.defineProperty(boxMesh.material, "envMap", {
              get: function() {
                return this.uniforms.envMap.value;
              }
            });
            objects.update(boxMesh);
          }
          boxMesh.material.uniforms.envMap.value = background;
          boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
          if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
            boxMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = background.version;
            currentTonemapping = renderer.toneMapping;
          }
          renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
          if (planeMesh === void 0) {
            planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            planeMesh.geometry.deleteAttribute("normal");
            Object.defineProperty(planeMesh.material, "map", {
              get: function() {
                return this.uniforms.t2D.value;
              }
            });
            objects.update(planeMesh);
          }
          planeMesh.material.uniforms.t2D.value = background;
          if (background.matrixAutoUpdate === true) {
            background.updateMatrix();
          }
          planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
          if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
            planeMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = background.version;
            currentTonemapping = renderer.toneMapping;
          }
          renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
      }
      function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
      }
      return {
        getClearColor: function() {
          return clearColor;
        },
        setClearColor: function(color, alpha = 1) {
          clearColor.set(color);
          clearAlpha = alpha;
          setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
          return clearAlpha;
        },
        setClearAlpha: function(alpha) {
          clearAlpha = alpha;
          setClear(clearColor, clearAlpha);
        },
        render: render4
      };
    }
    function WebGLBindingStates(gl, extensions, attributes, capabilities) {
      const maxVertexAttributes = gl.getParameter(34921);
      const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
      const vaoAvailable = capabilities.isWebGL2 || extension !== null;
      const bindingStates = {};
      const defaultState = createBindingState(null);
      let currentState = defaultState;
      function setup(object, material, program, geometry, index2) {
        let updateBuffers = false;
        if (vaoAvailable) {
          const state = getBindingState(geometry, program, material);
          if (currentState !== state) {
            currentState = state;
            bindVertexArrayObject(currentState.object);
          }
          updateBuffers = needsUpdate(geometry, index2);
          if (updateBuffers)
            saveCache(geometry, index2);
        } else {
          const wireframe = material.wireframe === true;
          if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
            currentState.geometry = geometry.id;
            currentState.program = program.id;
            currentState.wireframe = wireframe;
            updateBuffers = true;
          }
        }
        if (object.isInstancedMesh === true) {
          updateBuffers = true;
        }
        if (index2 !== null) {
          attributes.update(index2, 34963);
        }
        if (updateBuffers) {
          setupVertexAttributes(object, material, program, geometry);
          if (index2 !== null) {
            gl.bindBuffer(34963, attributes.get(index2).buffer);
          }
        }
      }
      function createVertexArrayObject() {
        if (capabilities.isWebGL2)
          return gl.createVertexArray();
        return extension.createVertexArrayOES();
      }
      function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2)
          return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
      }
      function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2)
          return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
      }
      function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === void 0) {
          programMap = {};
          bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === void 0) {
          stateMap = {};
          programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === void 0) {
          state = createBindingState(createVertexArrayObject());
          stateMap[wireframe] = state;
        }
        return state;
      }
      function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
          newAttributes[i2] = 0;
          enabledAttributes[i2] = 0;
          attributeDivisors[i2] = 0;
        }
        return {
          geometry: null,
          program: null,
          wireframe: false,
          newAttributes,
          enabledAttributes,
          attributeDivisors,
          object: vao,
          attributes: {},
          index: null
        };
      }
      function needsUpdate(geometry, index2) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        let attributesNum = 0;
        for (const key in geometryAttributes) {
          const cachedAttribute = cachedAttributes[key];
          const geometryAttribute = geometryAttributes[key];
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
        if (currentState.attributesNum !== attributesNum)
          return true;
        if (currentState.index !== index2)
          return true;
        return false;
      }
      function saveCache(geometry, index2) {
        const cache = {};
        const attributes2 = geometry.attributes;
        let attributesNum = 0;
        for (const key in attributes2) {
          const attribute = attributes2[key];
          const data = {};
          data.attribute = attribute;
          if (attribute.data) {
            data.data = attribute.data;
          }
          cache[key] = data;
          attributesNum++;
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index2;
      }
      function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
          newAttributes[i2] = 0;
        }
      }
      function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
      }
      function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
          const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
          extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
          attributeDivisors[attribute] = meshPerAttribute;
        }
      }
      function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
          if (enabledAttributes[i2] !== newAttributes[i2]) {
            gl.disableVertexAttribArray(i2);
            enabledAttributes[i2] = 0;
          }
        }
      }
      function vertexAttribPointer(index2, size, type, normalized, stride, offset2) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
          gl.vertexAttribIPointer(index2, size, type, stride, offset2);
        } else {
          gl.vertexAttribPointer(index2, size, type, normalized, stride, offset2);
        }
      }
      function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
          if (extensions.get("ANGLE_instanced_arrays") === null)
            return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for (const name in programAttributes) {
          const programAttribute = programAttributes[name];
          if (programAttribute.location >= 0) {
            let geometryAttribute = geometryAttributes[name];
            if (geometryAttribute === void 0) {
              if (name === "instanceMatrix" && object.instanceMatrix)
                geometryAttribute = object.instanceMatrix;
              if (name === "instanceColor" && object.instanceColor)
                geometryAttribute = object.instanceColor;
            }
            if (geometryAttribute !== void 0) {
              const normalized = geometryAttribute.normalized;
              const size = geometryAttribute.itemSize;
              const attribute = attributes.get(geometryAttribute);
              if (attribute === void 0)
                continue;
              const buffer = attribute.buffer;
              const type = attribute.type;
              const bytesPerElement = attribute.bytesPerElement;
              if (geometryAttribute.isInterleavedBufferAttribute) {
                const data = geometryAttribute.data;
                const stride = data.stride;
                const offset2 = geometryAttribute.offset;
                if (data && data.isInstancedInterleavedBuffer) {
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                  }
                  if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                    geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                  }
                } else {
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    enableAttribute(programAttribute.location + i2);
                  }
                }
                gl.bindBuffer(34962, buffer);
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset2 + size / programAttribute.locationSize * i2) * bytesPerElement);
                }
              } else {
                if (geometryAttribute.isInstancedBufferAttribute) {
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                  }
                  if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                    geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                  }
                } else {
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    enableAttribute(programAttribute.location + i2);
                  }
                }
                gl.bindBuffer(34962, buffer);
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
                }
              }
            } else if (materialDefaultAttributeValues !== void 0) {
              const value = materialDefaultAttributeValues[name];
              if (value !== void 0) {
                switch (value.length) {
                  case 2:
                    gl.vertexAttrib2fv(programAttribute.location, value);
                    break;
                  case 3:
                    gl.vertexAttrib3fv(programAttribute.location, value);
                    break;
                  case 4:
                    gl.vertexAttrib4fv(programAttribute.location, value);
                    break;
                  default:
                    gl.vertexAttrib1fv(programAttribute.location, value);
                }
              }
            }
          }
        }
        disableUnusedAttributes();
      }
      function dispose() {
        reset();
        for (const geometryId in bindingStates) {
          const programMap = bindingStates[geometryId];
          for (const programId in programMap) {
            const stateMap = programMap[programId];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometryId];
        }
      }
      function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === void 0)
          return;
        const programMap = bindingStates[geometry.id];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometry.id];
      }
      function releaseStatesOfProgram(program) {
        for (const geometryId in bindingStates) {
          const programMap = bindingStates[geometryId];
          if (programMap[program.id] === void 0)
            continue;
          const stateMap = programMap[program.id];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[program.id];
        }
      }
      function reset() {
        resetDefaultState();
        if (currentState === defaultState)
          return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
      }
      function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
      }
      return {
        setup,
        reset,
        resetDefaultState,
        dispose,
        releaseStatesOfGeometry,
        releaseStatesOfProgram,
        initAttributes,
        enableAttribute,
        disableUnusedAttributes
      };
    }
    function WebGLBufferRenderer(gl, extensions, info, capabilities) {
      const isWebGL2 = capabilities.isWebGL2;
      let mode;
      function setMode(value) {
        mode = value;
      }
      function render4(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
      }
      function renderInstances(start, count, primcount) {
        if (primcount === 0)
          return;
        let extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawArraysInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawArraysInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.render = render4;
      this.renderInstances = renderInstances;
    }
    function WebGLCapabilities(gl, extensions, parameters) {
      let maxAnisotropy;
      function getMaxAnisotropy() {
        if (maxAnisotropy !== void 0)
          return maxAnisotropy;
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
          const extension = extensions.get("EXT_texture_filter_anisotropic");
          maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
          maxAnisotropy = 0;
        }
        return maxAnisotropy;
      }
      function getMaxPrecision(precision2) {
        if (precision2 === "highp") {
          if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
            return "highp";
          }
          precision2 = "mediump";
        }
        if (precision2 === "mediump") {
          if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
            return "mediump";
          }
        }
        return "lowp";
      }
      const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
      let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
      const maxPrecision = getMaxPrecision(precision);
      if (maxPrecision !== precision) {
        console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
        precision = maxPrecision;
      }
      const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
      const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
      const maxTextures = gl.getParameter(34930);
      const maxVertexTextures = gl.getParameter(35660);
      const maxTextureSize = gl.getParameter(3379);
      const maxCubemapSize = gl.getParameter(34076);
      const maxAttributes = gl.getParameter(34921);
      const maxVertexUniforms = gl.getParameter(36347);
      const maxVaryings = gl.getParameter(36348);
      const maxFragmentUniforms = gl.getParameter(36349);
      const vertexTextures = maxVertexTextures > 0;
      const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
      const floatVertexTextures = vertexTextures && floatFragmentTextures;
      const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
      return {
        isWebGL2,
        drawBuffers,
        getMaxAnisotropy,
        getMaxPrecision,
        precision,
        logarithmicDepthBuffer,
        maxTextures,
        maxVertexTextures,
        maxTextureSize,
        maxCubemapSize,
        maxAttributes,
        maxVertexUniforms,
        maxVaryings,
        maxFragmentUniforms,
        vertexTextures,
        floatFragmentTextures,
        floatVertexTextures,
        maxSamples
      };
    }
    function WebGLClipping(properties) {
      const scope = this;
      let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
      const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
      this.uniform = uniform;
      this.numPlanes = 0;
      this.numIntersection = 0;
      this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
      };
      this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
      };
      this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
      };
      this.setState = function(material, camera, useCache) {
        const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        const materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
          if (renderingShadows) {
            projectPlanes(null);
          } else {
            resetGlobalState();
          }
        } else {
          const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
          let dstArray = materialProperties.clippingState || null;
          uniform.value = dstArray;
          dstArray = projectPlanes(planes, camera, lGlobal, useCache);
          for (let i2 = 0; i2 !== lGlobal; ++i2) {
            dstArray[i2] = globalState[i2];
          }
          materialProperties.clippingState = dstArray;
          this.numIntersection = clipIntersection ? this.numPlanes : 0;
          this.numPlanes += nGlobal;
        }
      };
      function resetGlobalState() {
        if (uniform.value !== globalState) {
          uniform.value = globalState;
          uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
      }
      function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
          dstArray = uniform.value;
          if (skipTransform !== true || dstArray === null) {
            const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
            viewNormalMatrix.getNormalMatrix(viewMatrix);
            if (dstArray === null || dstArray.length < flatSize) {
              dstArray = new Float32Array(flatSize);
            }
            for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
              plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
              plane.normal.toArray(dstArray, i4);
              dstArray[i4 + 3] = plane.constant;
            }
          }
          uniform.value = dstArray;
          uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
      }
    }
    function WebGLCubeMaps(renderer) {
      let cubemaps = new WeakMap();
      function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) {
          texture.mapping = CubeReflectionMapping;
        } else if (mapping === EquirectangularRefractionMapping) {
          texture.mapping = CubeRefractionMapping;
        }
        return texture;
      }
      function get(texture) {
        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
          const mapping = texture.mapping;
          if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
            if (cubemaps.has(texture)) {
              const cubemap = cubemaps.get(texture).texture;
              return mapTextureMapping(cubemap, texture.mapping);
            } else {
              const image = texture.image;
              if (image && image.height > 0) {
                const currentRenderTarget = renderer.getRenderTarget();
                const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                renderTarget.fromEquirectangularTexture(renderer, texture);
                cubemaps.set(texture, renderTarget);
                renderer.setRenderTarget(currentRenderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return mapTextureMapping(renderTarget.texture, texture.mapping);
              } else {
                return null;
              }
            }
          }
        }
        return texture;
      }
      function onTextureDispose(event2) {
        const texture = event2.target;
        texture.removeEventListener("dispose", onTextureDispose);
        const cubemap = cubemaps.get(texture);
        if (cubemap !== void 0) {
          cubemaps.delete(texture);
          cubemap.dispose();
        }
      }
      function dispose() {
        cubemaps = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    var OrthographicCamera = class extends Camera {
      constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
        super();
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      }
      setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      }
    };
    OrthographicCamera.prototype.isOrthographicCamera = true;
    var RawShaderMaterial = class extends ShaderMaterial {
      constructor(parameters) {
        super(parameters);
        this.type = "RawShaderMaterial";
      }
    };
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    var LOD_MIN = 4;
    var LOD_MAX = 8;
    var SIZE_MAX = Math.pow(2, LOD_MAX);
    var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    var MAX_SAMPLES = 20;
    var ENCODINGS = {
      [LinearEncoding]: 0,
      [sRGBEncoding]: 1,
      [RGBEEncoding]: 2,
      [RGBM7Encoding]: 3,
      [RGBM16Encoding]: 4,
      [RGBDEncoding]: 5,
      [GammaEncoding]: 6
    };
    var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
    var { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
    var _clearColor = /* @__PURE__ */ new Color();
    var _oldTarget = null;
    var PHI = (1 + Math.sqrt(5)) / 2;
    var INV_PHI = 1 / PHI;
    var _axisDirections = [
      /* @__PURE__ */ new Vector3(1, 1, 1),
      /* @__PURE__ */ new Vector3(-1, 1, 1),
      /* @__PURE__ */ new Vector3(1, 1, -1),
      /* @__PURE__ */ new Vector3(-1, 1, -1),
      /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
      /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
      /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
      /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
    ];
    var PMREMGenerator = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._blurMaterial = _getBlurShader(MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
      }
      fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          this._blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
      }
      fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
      }
      compileCubemapShader() {
        if (this._cubemapShader === null) {
          this._cubemapShader = _getCubemapShader();
          this._compileMaterial(this._cubemapShader);
        }
      }
      compileEquirectangularShader() {
        if (this._equirectShader === null) {
          this._equirectShader = _getEquirectShader();
          this._compileMaterial(this._equirectShader);
        }
      }
      dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null)
          this._cubemapShader.dispose();
        if (this._equirectShader !== null)
          this._equirectShader.dispose();
        for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
          _lodPlanes[i2].dispose();
        }
      }
      _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
      }
      _fromTexture(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      _allocateTargets(texture) {
        const params = {
          magFilter: NearestFilter,
          minFilter: NearestFilter,
          generateMipmaps: false,
          type: UnsignedByteType,
          format: RGBEFormat,
          encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
          depthBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
      }
      _compileMaterial(material) {
        const tmpMesh = new Mesh(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
      }
      _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov2 = 90;
        const aspect2 = 1;
        const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
        const upSign = [1, -1, 1, 1, 1, 1];
        const forwardSign = [1, 1, 1, -1, -1, -1];
        const renderer = this._renderer;
        const originalAutoClear = renderer.autoClear;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        renderer.getClearColor(_clearColor);
        renderer.toneMapping = NoToneMapping;
        renderer.outputEncoding = LinearEncoding;
        renderer.autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        });
        const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
          if (background.isColor) {
            backgroundMaterial.color.copy(background);
            scene.background = null;
            useSolidColor = true;
          }
        } else {
          backgroundMaterial.color.copy(_clearColor);
          useSolidColor = true;
        }
        for (let i2 = 0; i2 < 6; i2++) {
          const col = i2 % 3;
          if (col == 0) {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(forwardSign[i2], 0, 0);
          } else if (col == 1) {
            cubeCamera.up.set(0, 0, upSign[i2]);
            cubeCamera.lookAt(0, forwardSign[i2], 0);
          } else {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(0, 0, forwardSign[i2]);
          }
          _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
          renderer.setRenderTarget(cubeUVRenderTarget);
          if (useSolidColor) {
            renderer.render(backgroundBox, cubeCamera);
          }
          renderer.render(scene, cubeCamera);
        }
        backgroundBox.geometry.dispose();
        backgroundBox.material.dispose();
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        renderer.autoClear = originalAutoClear;
        scene.background = background;
      }
      _setEncoding(uniform, texture) {
        if (this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding) {
          uniform.value = ENCODINGS[LinearEncoding];
        } else {
          uniform.value = ENCODINGS[texture.encoding];
        }
      }
      _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
        if (isCubeTexture) {
          if (this._cubemapShader == null) {
            this._cubemapShader = _getCubemapShader();
          }
        } else {
          if (this._equirectShader == null) {
            this._equirectShader = _getEquirectShader();
          }
        }
        const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new Mesh(_lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms["envMap"].value = texture;
        if (!isCubeTexture) {
          uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
        }
        this._setEncoding(uniforms["inputEncoding"], texture);
        this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
      }
      _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
          const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
          const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
          this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
      }
      _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
      }
      _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== "latitudinal" && direction !== "longitudinal") {
          console.error("blur direction must be either latitudinal or longitudinal!");
        }
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = _sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
          console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
          const x2 = i2 / sigmaPixels;
          const weight = Math.exp(-x2 * x2 / 2);
          weights.push(weight);
          if (i2 == 0) {
            sum += weight;
          } else if (i2 < samples) {
            sum += 2 * weight;
          }
        }
        for (let i2 = 0; i2 < weights.length; i2++) {
          weights[i2] = weights[i2] / sum;
        }
        blurUniforms["envMap"].value = targetIn.texture;
        blurUniforms["samples"].value = samples;
        blurUniforms["weights"].value = weights;
        blurUniforms["latitudinal"].value = direction === "latitudinal";
        if (poleAxis) {
          blurUniforms["poleAxis"].value = poleAxis;
        }
        blurUniforms["dTheta"].value = radiansPerPixel;
        blurUniforms["mipInt"].value = LOD_MAX - lodIn;
        this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
        this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
        const outputSize = _sizeLods[lodOut];
        const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
      }
    };
    function _isLDR(texture) {
      if (texture === void 0 || texture.type !== UnsignedByteType)
        return false;
      return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
    }
    function _createPlanes() {
      const _lodPlanes2 = [];
      const _sizeLods2 = [];
      const _sigmas2 = [];
      let lod = LOD_MAX;
      for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
        const sizeLod = Math.pow(2, lod);
        _sizeLods2.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i2 > LOD_MAX - LOD_MIN) {
          sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
        } else if (i2 == 0) {
          sigma = 0;
        }
        _sigmas2.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min = -texelSize / 2;
        const max = 1 + texelSize / 2;
        const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for (let face = 0; face < cubeFaces; face++) {
          const x = face % 3 * 2 / 3 - 1;
          const y = face > 2 ? 0 : -1;
          const coordinates = [
            x,
            y,
            0,
            x + 2 / 3,
            y,
            0,
            x + 2 / 3,
            y + 1,
            0,
            x,
            y,
            0,
            x + 2 / 3,
            y + 1,
            0,
            x,
            y + 1,
            0
          ];
          position.set(coordinates, positionSize * vertices * face);
          uv.set(uv1, uvSize * vertices * face);
          const fill = [face, face, face, face, face, face];
          faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new BufferGeometry();
        planes.setAttribute("position", new BufferAttribute(position, positionSize));
        planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
        planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
        _lodPlanes2.push(planes);
        if (lod > LOD_MIN) {
          lod--;
        }
      }
      return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
    }
    function _createRenderTarget(params) {
      const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
      cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
      cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
      cubeUVRenderTarget.scissorTest = true;
      return cubeUVRenderTarget;
    }
    function _setViewport(target, x, y, width, height) {
      target.viewport.set(x, y, width, height);
      target.scissor.set(x, y, width, height);
    }
    function _getBlurShader(maxSamples) {
      const weights = new Float32Array(maxSamples);
      const poleAxis = new Vector3(0, 1, 0);
      const shaderMaterial = new RawShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: { "n": maxSamples },
        uniforms: {
          "envMap": { value: null },
          "samples": { value: 1 },
          "weights": { value: weights },
          "latitudinal": { value: false },
          "dTheta": { value: 0 },
          "mipInt": { value: 0 },
          "poleAxis": { value: poleAxis },
          "inputEncoding": { value: ENCODINGS[LinearEncoding] },
          "outputEncoding": { value: ENCODINGS[LinearEncoding] }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
  
              precision mediump float;
              precision mediump int;
  
              varying vec3 vOutputDirection;
  
              uniform sampler2D envMap;
              uniform int samples;
              uniform float weights[ n ];
              uniform bool latitudinal;
              uniform float dTheta;
              uniform float mipInt;
              uniform vec3 poleAxis;
  
              ${_getEncodings()}
  
              #define ENVMAP_TYPE_CUBE_UV
              #include <cube_uv_reflection_fragment>
  
              vec3 getSample( float theta, vec3 axis ) {
  
                  float cosTheta = cos( theta );
                  // Rodrigues' axis-angle rotation
                  vec3 sampleDirection = vOutputDirection * cosTheta
                      + cross( axis, vOutputDirection ) * sin( theta )
                      + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );
  
                  return bilinearCubeUV( envMap, sampleDirection, mipInt );
  
              }
  
              void main() {
  
                  vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );
  
                  if ( all( equal( axis, vec3( 0.0 ) ) ) ) {
  
                      axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );
  
                  }
  
                  axis = normalize( axis );
  
                  gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
                  gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );
  
                  for ( int i = 1; i < n; i++ ) {
  
                      if ( i >= samples ) {
  
                          break;
  
                      }
  
                      float theta = dTheta * float( i );
                      gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
                      gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
  
                  }
  
                  gl_FragColor = linearToOutputTexel( gl_FragColor );
  
              }
          `,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getEquirectShader() {
      const texelSize = new Vector2(1, 1);
      const shaderMaterial = new RawShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
          "envMap": { value: null },
          "texelSize": { value: texelSize },
          "inputEncoding": { value: ENCODINGS[LinearEncoding] },
          "outputEncoding": { value: ENCODINGS[LinearEncoding] }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
  
              precision mediump float;
              precision mediump int;
  
              varying vec3 vOutputDirection;
  
              uniform sampler2D envMap;
              uniform vec2 texelSize;
  
              ${_getEncodings()}
  
              #include <common>
  
              void main() {
  
                  gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
  
                  vec3 outputDirection = normalize( vOutputDirection );
                  vec2 uv = equirectUv( outputDirection );
  
                  vec2 f = fract( uv / texelSize - 0.5 );
                  uv -= f * texelSize;
                  vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
                  uv.x += texelSize.x;
                  vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
                  uv.y += texelSize.y;
                  vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
                  uv.x -= texelSize.x;
                  vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
  
                  vec3 tm = mix( tl, tr, f.x );
                  vec3 bm = mix( bl, br, f.x );
                  gl_FragColor.rgb = mix( tm, bm, f.y );
  
                  gl_FragColor = linearToOutputTexel( gl_FragColor );
  
              }
          `,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getCubemapShader() {
      const shaderMaterial = new RawShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
          "envMap": { value: null },
          "inputEncoding": { value: ENCODINGS[LinearEncoding] },
          "outputEncoding": { value: ENCODINGS[LinearEncoding] }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
  
              precision mediump float;
              precision mediump int;
  
              varying vec3 vOutputDirection;
  
              uniform samplerCube envMap;
  
              ${_getEncodings()}
  
              void main() {
  
                  gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
                  gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
                  gl_FragColor = linearToOutputTexel( gl_FragColor );
  
              }
          `,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getCommonVertexShader() {
      return `
  
          precision mediump float;
          precision mediump int;
  
          attribute vec3 position;
          attribute vec2 uv;
          attribute float faceIndex;
  
          varying vec3 vOutputDirection;
  
          // RH coordinate system; PMREM face-indexing convention
          vec3 getDirection( vec2 uv, float face ) {
  
              uv = 2.0 * uv - 1.0;
  
              vec3 direction = vec3( uv, 1.0 );
  
              if ( face == 0.0 ) {
  
                  direction = direction.zyx; // ( 1, v, u ) pos x
  
              } else if ( face == 1.0 ) {
  
                  direction = direction.xzy;
                  direction.xz *= -1.0; // ( -u, 1, -v ) pos y
  
              } else if ( face == 2.0 ) {
  
                  direction.x *= -1.0; // ( -u, v, 1 ) pos z
  
              } else if ( face == 3.0 ) {
  
                  direction = direction.zyx;
                  direction.xz *= -1.0; // ( -1, v, -u ) neg x
  
              } else if ( face == 4.0 ) {
  
                  direction = direction.xzy;
                  direction.xy *= -1.0; // ( -u, -1, v ) neg y
  
              } else if ( face == 5.0 ) {
  
                  direction.z *= -1.0; // ( u, v, -1 ) neg z
  
              }
  
              return direction;
  
          }
  
          void main() {
  
              vOutputDirection = getDirection( uv, faceIndex );
              gl_Position = vec4( position, 1.0 );
  
          }
      `;
    }
    function _getEncodings() {
      return `
  
          uniform int inputEncoding;
          uniform int outputEncoding;
  
          #include <encodings_pars_fragment>
  
          vec4 inputTexelToLinear( vec4 value ) {
  
              if ( inputEncoding == 0 ) {
  
                  return value;
  
              } else if ( inputEncoding == 1 ) {
  
                  return sRGBToLinear( value );
  
              } else if ( inputEncoding == 2 ) {
  
                  return RGBEToLinear( value );
  
              } else if ( inputEncoding == 3 ) {
  
                  return RGBMToLinear( value, 7.0 );
  
              } else if ( inputEncoding == 4 ) {
  
                  return RGBMToLinear( value, 16.0 );
  
              } else if ( inputEncoding == 5 ) {
  
                  return RGBDToLinear( value, 256.0 );
  
              } else {
  
                  return GammaToLinear( value, 2.2 );
  
              }
  
          }
  
          vec4 linearToOutputTexel( vec4 value ) {
  
              if ( outputEncoding == 0 ) {
  
                  return value;
  
              } else if ( outputEncoding == 1 ) {
  
                  return LinearTosRGB( value );
  
              } else if ( outputEncoding == 2 ) {
  
                  return LinearToRGBE( value );
  
              } else if ( outputEncoding == 3 ) {
  
                  return LinearToRGBM( value, 7.0 );
  
              } else if ( outputEncoding == 4 ) {
  
                  return LinearToRGBM( value, 16.0 );
  
              } else if ( outputEncoding == 5 ) {
  
                  return LinearToRGBD( value, 256.0 );
  
              } else {
  
                  return LinearToGamma( value, 2.2 );
  
              }
  
          }
  
          vec4 envMapTexelToLinear( vec4 color ) {
  
              return inputTexelToLinear( color );
  
          }
      `;
    }
    function WebGLCubeUVMaps(renderer) {
      let cubeUVmaps = new WeakMap();
      let pmremGenerator = null;
      function get(texture) {
        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
          const mapping = texture.mapping;
          const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
          const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
          if (isEquirectMap || isCubeMap) {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                const currentRenderTarget = renderer.getRenderTarget();
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                renderer.setRenderTarget(currentRenderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
        return texture;
      }
      function isCubeTextureComplete(image) {
        let count = 0;
        const length = 6;
        for (let i2 = 0; i2 < length; i2++) {
          if (image[i2] !== void 0)
            count++;
        }
        return count === length;
      }
      function onTextureDispose(event2) {
        const texture = event2.target;
        texture.removeEventListener("dispose", onTextureDispose);
        const cubemapUV = cubeUVmaps.get(texture);
        if (cubemapUV !== void 0) {
          cubeUVmaps.delete(texture);
          cubemapUV.dispose();
        }
      }
      function dispose() {
        cubeUVmaps = new WeakMap();
        if (pmremGenerator !== null) {
          pmremGenerator.dispose();
          pmremGenerator = null;
        }
      }
      return {
        get,
        dispose
      };
    }
    function WebGLExtensions(gl) {
      const extensions = {};
      function getExtension(name) {
        if (extensions[name] !== void 0) {
          return extensions[name];
        }
        let extension;
        switch (name) {
          case "WEBGL_depth_texture":
            extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension;
      }
      return {
        has: function(name) {
          return getExtension(name) !== null;
        },
        init: function(capabilities) {
          if (capabilities.isWebGL2) {
            getExtension("EXT_color_buffer_float");
          } else {
            getExtension("WEBGL_depth_texture");
            getExtension("OES_texture_float");
            getExtension("OES_texture_half_float");
            getExtension("OES_texture_half_float_linear");
            getExtension("OES_standard_derivatives");
            getExtension("OES_element_index_uint");
            getExtension("OES_vertex_array_object");
            getExtension("ANGLE_instanced_arrays");
          }
          getExtension("OES_texture_float_linear");
          getExtension("EXT_color_buffer_half_float");
        },
        get: function(name) {
          const extension = getExtension(name);
          if (extension === null) {
            console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
          }
          return extension;
        }
      };
    }
    function WebGLGeometries(gl, attributes, info, bindingStates) {
      const geometries = {};
      const wireframeAttributes = new WeakMap();
      function onGeometryDispose(event2) {
        const geometry = event2.target;
        if (geometry.index !== null) {
          attributes.remove(geometry.index);
        }
        for (const name in geometry.attributes) {
          attributes.remove(geometry.attributes[name]);
        }
        geometry.removeEventListener("dispose", onGeometryDispose);
        delete geometries[geometry.id];
        const attribute = wireframeAttributes.get(geometry);
        if (attribute) {
          attributes.remove(attribute);
          wireframeAttributes.delete(geometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) {
          delete geometry._maxInstanceCount;
        }
        info.memory.geometries--;
      }
      function get(object, geometry) {
        if (geometries[geometry.id] === true)
          return geometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        geometries[geometry.id] = true;
        info.memory.geometries++;
        return geometry;
      }
      function update(geometry) {
        const geometryAttributes = geometry.attributes;
        for (const name in geometryAttributes) {
          attributes.update(geometryAttributes[name], 34962);
        }
        const morphAttributes = geometry.morphAttributes;
        for (const name in morphAttributes) {
          const array = morphAttributes[name];
          for (let i2 = 0, l = array.length; i2 < l; i2++) {
            attributes.update(array[i2], 34962);
          }
        }
      }
      function updateWireframeAttribute(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
          const array = geometryIndex.array;
          version = geometryIndex.version;
          for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
            const a = array[i2 + 0];
            const b = array[i2 + 1];
            const c = array[i2 + 2];
            indices.push(a, b, b, c, c, a);
          }
        } else {
          const array = geometryPosition.array;
          version = geometryPosition.version;
          for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
            const a = i2 + 0;
            const b = i2 + 1;
            const c = i2 + 2;
            indices.push(a, b, b, c, c, a);
          }
        }
        const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute)
          attributes.remove(previousAttribute);
        wireframeAttributes.set(geometry, attribute);
      }
      function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
          const geometryIndex = geometry.index;
          if (geometryIndex !== null) {
            if (currentAttribute.version < geometryIndex.version) {
              updateWireframeAttribute(geometry);
            }
          }
        } else {
          updateWireframeAttribute(geometry);
        }
        return wireframeAttributes.get(geometry);
      }
      return {
        get,
        update,
        getWireframeAttribute
      };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
      const isWebGL2 = capabilities.isWebGL2;
      let mode;
      function setMode(value) {
        mode = value;
      }
      let type, bytesPerElement;
      function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
      }
      function render4(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
      }
      function renderInstances(start, count, primcount) {
        if (primcount === 0)
          return;
        let extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawElementsInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawElementsInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render4;
      this.renderInstances = renderInstances;
    }
    function WebGLInfo(gl) {
      const memory = {
        geometries: 0,
        textures: 0
      };
      const render4 = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      function update(count, mode, instanceCount) {
        render4.calls++;
        switch (mode) {
          case 4:
            render4.triangles += instanceCount * (count / 3);
            break;
          case 1:
            render4.lines += instanceCount * (count / 2);
            break;
          case 3:
            render4.lines += instanceCount * (count - 1);
            break;
          case 2:
            render4.lines += instanceCount * count;
            break;
          case 0:
            render4.points += instanceCount * count;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
            break;
        }
      }
      function reset() {
        render4.frame++;
        render4.calls = 0;
        render4.triangles = 0;
        render4.points = 0;
        render4.lines = 0;
      }
      return {
        memory,
        render: render4,
        programs: null,
        autoReset: true,
        reset,
        update
      };
    }
    var DataTexture2DArray = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
      }
    };
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    function numericalSort(a, b) {
      return a[0] - b[0];
    }
    function absNumericalSort(a, b) {
      return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function denormalize(morph, attribute) {
      let denominator = 1;
      const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
      if (array instanceof Int8Array)
        denominator = 127;
      else if (array instanceof Int16Array)
        denominator = 32767;
      else if (array instanceof Int32Array)
        denominator = 2147483647;
      else
        console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
      morph.divideScalar(denominator);
    }
    function WebGLMorphtargets(gl, capabilities, textures) {
      const influencesList = {};
      const morphInfluences = new Float32Array(8);
      const morphTextures = new WeakMap();
      const morph = new Vector3();
      const workInfluences = [];
      for (let i2 = 0; i2 < 8; i2++) {
        workInfluences[i2] = [i2, 0];
      }
      function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        if (capabilities.isWebGL2 === true) {
          const numberOfMorphTargets = geometry.morphAttributes.position.length;
          let entry = morphTextures.get(geometry);
          if (entry === void 0 || entry.count !== numberOfMorphTargets) {
            if (entry !== void 0)
              entry.texture.dispose();
            const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
            const morphTargets = geometry.morphAttributes.position;
            const morphNormals = geometry.morphAttributes.normal || [];
            const numberOfVertices = geometry.attributes.position.count;
            const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
            let width = numberOfVertices * numberOfVertexData;
            let height = 1;
            if (width > capabilities.maxTextureSize) {
              height = Math.ceil(width / capabilities.maxTextureSize);
              width = capabilities.maxTextureSize;
            }
            const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
            const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
            texture.format = RGBAFormat;
            texture.type = FloatType;
            const vertexDataStride = numberOfVertexData * 4;
            for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
              const morphTarget = morphTargets[i2];
              const morphNormal = morphNormals[i2];
              const offset2 = width * height * 4 * i2;
              for (let j = 0; j < morphTarget.count; j++) {
                morph.fromBufferAttribute(morphTarget, j);
                if (morphTarget.normalized === true)
                  denormalize(morph, morphTarget);
                const stride = j * vertexDataStride;
                buffer[offset2 + stride + 0] = morph.x;
                buffer[offset2 + stride + 1] = morph.y;
                buffer[offset2 + stride + 2] = morph.z;
                buffer[offset2 + stride + 3] = 0;
                if (hasMorphNormals === true) {
                  morph.fromBufferAttribute(morphNormal, j);
                  if (morphNormal.normalized === true)
                    denormalize(morph, morphNormal);
                  buffer[offset2 + stride + 4] = morph.x;
                  buffer[offset2 + stride + 5] = morph.y;
                  buffer[offset2 + stride + 6] = morph.z;
                  buffer[offset2 + stride + 7] = 0;
                }
              }
            }
            entry = {
              count: numberOfMorphTargets,
              texture,
              size: new Vector2(width, height)
            };
            morphTextures.set(geometry, entry);
          }
          let morphInfluencesSum = 0;
          for (let i2 = 0; i2 < objectInfluences.length; i2++) {
            morphInfluencesSum += objectInfluences[i2];
          }
          const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
          program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
          program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
          program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
          program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
        } else {
          const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
          let influences = influencesList[geometry.id];
          if (influences === void 0 || influences.length !== length) {
            influences = [];
            for (let i2 = 0; i2 < length; i2++) {
              influences[i2] = [i2, 0];
            }
            influencesList[geometry.id] = influences;
          }
          for (let i2 = 0; i2 < length; i2++) {
            const influence = influences[i2];
            influence[0] = i2;
            influence[1] = objectInfluences[i2];
          }
          influences.sort(absNumericalSort);
          for (let i2 = 0; i2 < 8; i2++) {
            if (i2 < length && influences[i2][1]) {
              workInfluences[i2][0] = influences[i2][0];
              workInfluences[i2][1] = influences[i2][1];
            } else {
              workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
              workInfluences[i2][1] = 0;
            }
          }
          workInfluences.sort(numericalSort);
          const morphTargets = geometry.morphAttributes.position;
          const morphNormals = geometry.morphAttributes.normal;
          let morphInfluencesSum = 0;
          for (let i2 = 0; i2 < 8; i2++) {
            const influence = workInfluences[i2];
            const index2 = influence[0];
            const value = influence[1];
            if (index2 !== Number.MAX_SAFE_INTEGER && value) {
              if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index2]) {
                geometry.setAttribute("morphTarget" + i2, morphTargets[index2]);
              }
              if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index2]) {
                geometry.setAttribute("morphNormal" + i2, morphNormals[index2]);
              }
              morphInfluences[i2] = value;
              morphInfluencesSum += value;
            } else {
              if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
                geometry.deleteAttribute("morphTarget" + i2);
              }
              if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
                geometry.deleteAttribute("morphNormal" + i2);
              }
              morphInfluences[i2] = 0;
            }
          }
          const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
          program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
          program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
        }
      }
      return {
        update
      };
    }
    function WebGLObjects(gl, geometries, attributes, info) {
      let updateMap = new WeakMap();
      function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        if (updateMap.get(buffergeometry) !== frame) {
          geometries.update(buffergeometry);
          updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
          if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
            object.addEventListener("dispose", onInstancedMeshDispose);
          }
          attributes.update(object.instanceMatrix, 34962);
          if (object.instanceColor !== null) {
            attributes.update(object.instanceColor, 34962);
          }
        }
        return buffergeometry;
      }
      function dispose() {
        updateMap = new WeakMap();
      }
      function onInstancedMeshDispose(event2) {
        const instancedMesh = event2.target;
        instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null)
          attributes.remove(instancedMesh.instanceColor);
      }
      return {
        update,
        dispose
      };
    }
    var DataTexture3D = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
      }
    };
    DataTexture3D.prototype.isDataTexture3D = true;
    var emptyTexture = new Texture();
    var emptyTexture2dArray = new DataTexture2DArray();
    var emptyTexture3d = new DataTexture3D();
    var emptyCubeTexture = new CubeTexture();
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);
    var mat2array = new Float32Array(4);
    function flatten(array, nBlocks, blockSize) {
      const firstElem = array[0];
      if (firstElem <= 0 || firstElem > 0)
        return array;
      const n = nBlocks * blockSize;
      let r = arrayCacheF32[n];
      if (r === void 0) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
      }
      if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for (let i2 = 1, offset2 = 0; i2 !== nBlocks; ++i2) {
          offset2 += blockSize;
          array[i2].toArray(r, offset2);
        }
      }
      return r;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i2 = 0, l = a.length; i2 < l; i2++) {
        if (a[i2] !== b[i2])
          return false;
      }
      return true;
    }
    function copyArray(a, b) {
      for (let i2 = 0, l = b.length; i2 < l; i2++) {
        a[i2] = b[i2];
      }
    }
    function allocTexUnits(textures, n) {
      let r = arrayCacheI32[n];
      if (r === void 0) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
      }
      for (let i2 = 0; i2 !== n; ++i2) {
        r[i2] = textures.allocateTextureUnit();
      }
      return r;
    }
    function setValueV1f(gl, v) {
      const cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1f(this.addr, v);
      cache[0] = v;
    }
    function setValueV2f(gl, v) {
      const cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
          gl.uniform2f(this.addr, v.x, v.y);
          cache[0] = v.x;
          cache[1] = v.y;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueV3f(gl, v) {
      const cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
          gl.uniform3f(this.addr, v.x, v.y, v.z);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
        }
      } else if (v.r !== void 0) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
          gl.uniform3f(this.addr, v.r, v.g, v.b);
          cache[0] = v.r;
          cache[1] = v.g;
          cache[2] = v.b;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueV4f(gl, v) {
      const cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
          gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
          cache[3] = v.w;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueM2(gl, v) {
      const cache = this.cache;
      const elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
      }
    }
    function setValueM3(gl, v) {
      const cache = this.cache;
      const elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
      }
    }
    function setValueM4(gl, v) {
      const cache = this.cache;
      const elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
      }
    }
    function setValueV1i(gl, v) {
      const cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1i(this.addr, v);
      cache[0] = v;
    }
    function setValueV2i(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform2iv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV3i(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform3iv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV4i(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform4iv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV1ui(gl, v) {
      const cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1ui(this.addr, v);
      cache[0] = v;
    }
    function setValueV2ui(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform2uiv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV3ui(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform3uiv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV4ui(gl, v) {
      const cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform4uiv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueT1(gl, v, textures) {
      const cache = this.cache;
      const unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTexture2D(v || emptyTexture, unit);
    }
    function setValueT3D1(gl, v, textures) {
      const cache = this.cache;
      const unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture3D(v || emptyTexture3d, unit);
    }
    function setValueT6(gl, v, textures) {
      const cache = this.cache;
      const unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTextureCube(v || emptyCubeTexture, unit);
    }
    function setValueT2DArray1(gl, v, textures) {
      const cache = this.cache;
      const unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture2DArray(v || emptyTexture2dArray, unit);
    }
    function getSingularSetter(type) {
      switch (type) {
        case 5126:
          return setValueV1f;
        case 35664:
          return setValueV2f;
        case 35665:
          return setValueV3f;
        case 35666:
          return setValueV4f;
        case 35674:
          return setValueM2;
        case 35675:
          return setValueM3;
        case 35676:
          return setValueM4;
        case 5124:
        case 35670:
          return setValueV1i;
        case 35667:
        case 35671:
          return setValueV2i;
        case 35668:
        case 35672:
          return setValueV3i;
        case 35669:
        case 35673:
          return setValueV4i;
        case 5125:
          return setValueV1ui;
        case 36294:
          return setValueV2ui;
        case 36295:
          return setValueV3ui;
        case 36296:
          return setValueV4ui;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return setValueT1;
        case 35679:
        case 36299:
        case 36307:
          return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return setValueT2DArray1;
      }
    }
    function setValueV1fArray(gl, v) {
      gl.uniform1fv(this.addr, v);
    }
    function setValueV2fArray(gl, v) {
      const data = flatten(v, this.size, 2);
      gl.uniform2fv(this.addr, data);
    }
    function setValueV3fArray(gl, v) {
      const data = flatten(v, this.size, 3);
      gl.uniform3fv(this.addr, data);
    }
    function setValueV4fArray(gl, v) {
      const data = flatten(v, this.size, 4);
      gl.uniform4fv(this.addr, data);
    }
    function setValueM2Array(gl, v) {
      const data = flatten(v, this.size, 4);
      gl.uniformMatrix2fv(this.addr, false, data);
    }
    function setValueM3Array(gl, v) {
      const data = flatten(v, this.size, 9);
      gl.uniformMatrix3fv(this.addr, false, data);
    }
    function setValueM4Array(gl, v) {
      const data = flatten(v, this.size, 16);
      gl.uniformMatrix4fv(this.addr, false, data);
    }
    function setValueV1iArray(gl, v) {
      gl.uniform1iv(this.addr, v);
    }
    function setValueV2iArray(gl, v) {
      gl.uniform2iv(this.addr, v);
    }
    function setValueV3iArray(gl, v) {
      gl.uniform3iv(this.addr, v);
    }
    function setValueV4iArray(gl, v) {
      gl.uniform4iv(this.addr, v);
    }
    function setValueV1uiArray(gl, v) {
      gl.uniform1uiv(this.addr, v);
    }
    function setValueV2uiArray(gl, v) {
      gl.uniform2uiv(this.addr, v);
    }
    function setValueV3uiArray(gl, v) {
      gl.uniform3uiv(this.addr, v);
    }
    function setValueV4uiArray(gl, v) {
      gl.uniform4uiv(this.addr, v);
    }
    function setValueT1Array(gl, v, textures) {
      const n = v.length;
      const units = allocTexUnits(textures, n);
      gl.uniform1iv(this.addr, units);
      for (let i2 = 0; i2 !== n; ++i2) {
        textures.safeSetTexture2D(v[i2] || emptyTexture, units[i2]);
      }
    }
    function setValueT6Array(gl, v, textures) {
      const n = v.length;
      const units = allocTexUnits(textures, n);
      gl.uniform1iv(this.addr, units);
      for (let i2 = 0; i2 !== n; ++i2) {
        textures.safeSetTextureCube(v[i2] || emptyCubeTexture, units[i2]);
      }
    }
    function getPureArraySetter(type) {
      switch (type) {
        case 5126:
          return setValueV1fArray;
        case 35664:
          return setValueV2fArray;
        case 35665:
          return setValueV3fArray;
        case 35666:
          return setValueV4fArray;
        case 35674:
          return setValueM2Array;
        case 35675:
          return setValueM3Array;
        case 35676:
          return setValueM4Array;
        case 5124:
        case 35670:
          return setValueV1iArray;
        case 35667:
        case 35671:
          return setValueV2iArray;
        case 35668:
        case 35672:
          return setValueV3iArray;
        case 35669:
        case 35673:
          return setValueV4iArray;
        case 5125:
          return setValueV1uiArray;
        case 36294:
          return setValueV2uiArray;
        case 36295:
          return setValueV3uiArray;
        case 36296:
          return setValueV4uiArray;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return setValueT6Array;
      }
    }
    function SingleUniform(id2, activeInfo, addr) {
      this.id = id2;
      this.addr = addr;
      this.cache = [];
      this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id2, activeInfo, addr) {
      this.id = id2;
      this.addr = addr;
      this.cache = [];
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);
    }
    PureArrayUniform.prototype.updateCache = function(data) {
      const cache = this.cache;
      if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
      }
      copyArray(cache, data);
    };
    function StructuredUniform(id2) {
      this.id = id2;
      this.seq = [];
      this.map = {};
    }
    StructuredUniform.prototype.setValue = function(gl, value, textures) {
      const seq = this.seq;
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        u.setValue(gl, value[u.id], textures);
      }
    };
    var RePathPart = /(\w+)(\])?(\[|\.)?/g;
    function addUniform(container, uniformObject) {
      container.seq.push(uniformObject);
      container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
      const path = activeInfo.name, pathLength = path.length;
      RePathPart.lastIndex = 0;
      while (true) {
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id2 = match[1];
        const idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex)
          id2 = id2 | 0;
        if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
          addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
          break;
        } else {
          const map2 = container.map;
          let next2 = map2[id2];
          if (next2 === void 0) {
            next2 = new StructuredUniform(id2);
            addUniform(container, next2);
          }
          container = next2;
        }
      }
    }
    function WebGLUniforms(gl, program) {
      this.seq = [];
      this.map = {};
      const n = gl.getProgramParameter(program, 35718);
      for (let i2 = 0; i2 < n; ++i2) {
        const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
      }
    }
    WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
      const u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
      const v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, textures) {
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
      const r = [];
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        if (u.id in values)
          r.push(u);
      }
      return r;
    };
    function WebGLShader(gl, type, string) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, string);
      gl.compileShader(shader);
      return shader;
    }
    var programIdCount = 0;
    function addLineNumbers(string) {
      const lines = string.split("\n");
      for (let i2 = 0; i2 < lines.length; i2++) {
        lines[i2] = i2 + 1 + ": " + lines[i2];
      }
      return lines.join("\n");
    }
    function getEncodingComponents(encoding) {
      switch (encoding) {
        case LinearEncoding:
          return ["Linear", "( value )"];
        case sRGBEncoding:
          return ["sRGB", "( value )"];
        case RGBEEncoding:
          return ["RGBE", "( value )"];
        case RGBM7Encoding:
          return ["RGBM", "( value, 7.0 )"];
        case RGBM16Encoding:
          return ["RGBM", "( value, 16.0 )"];
        case RGBDEncoding:
          return ["RGBD", "( value, 256.0 )"];
        case GammaEncoding:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case LogLuvEncoding:
          return ["LogLuv", "( value )"];
        default:
          console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
          return ["Linear", "( value )"];
      }
    }
    function getShaderErrors(gl, shader, type) {
      const status = gl.getShaderParameter(shader, 35713);
      const errors = gl.getShaderInfoLog(shader).trim();
      if (status && errors === "")
        return "";
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
    }
    function getTexelDecodingFunction(functionName, encoding) {
      const components = getEncodingComponents(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
      const components = getEncodingComponents(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
      let toneMappingName;
      switch (toneMapping) {
        case LinearToneMapping:
          toneMappingName = "Linear";
          break;
        case ReinhardToneMapping:
          toneMappingName = "Reinhard";
          break;
        case CineonToneMapping:
          toneMappingName = "OptimizedCineon";
          break;
        case ACESFilmicToneMapping:
          toneMappingName = "ACESFilmic";
          break;
        case CustomToneMapping:
          toneMappingName = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
          toneMappingName = "Linear";
      }
      return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(parameters) {
      const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
      ];
      return chunks.filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
      const chunks = [];
      for (const name in defines) {
        const value = defines[name];
        if (value === false)
          continue;
        chunks.push("#define " + name + " " + value);
      }
      return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program) {
      const attributes = {};
      const n = gl.getProgramParameter(program, 35721);
      for (let i2 = 0; i2 < n; i2++) {
        const info = gl.getActiveAttrib(program, i2);
        const name = info.name;
        let locationSize = 1;
        if (info.type === 35674)
          locationSize = 2;
        if (info.type === 35675)
          locationSize = 3;
        if (info.type === 35676)
          locationSize = 4;
        attributes[name] = {
          type: info.type,
          location: gl.getAttribLocation(program, name),
          locationSize
        };
      }
      return attributes;
    }
    function filterEmptyLine(string) {
      return string !== "";
    }
    function replaceLightNums(string, parameters) {
      return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
    }
    function replaceClippingPlaneNums(string, parameters) {
      return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
    }
    var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function resolveIncludes(string) {
      return string.replace(includePattern, includeReplacer);
    }
    function includeReplacer(match, include) {
      const string = ShaderChunk[include];
      if (string === void 0) {
        throw new Error("Can not resolve #include <" + include + ">");
      }
      return resolveIncludes(string);
    }
    var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function unrollLoops(string) {
      return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
    }
    function deprecatedLoopReplacer(match, start, end, snippet) {
      console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
      return loopReplacer(match, start, end, snippet);
    }
    function loopReplacer(match, start, end, snippet) {
      let string = "";
      for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
        string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
      }
      return string;
    }
    function generatePrecision(parameters) {
      let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
      if (parameters.precision === "highp") {
        precisionstring += "\n#define HIGH_PRECISION";
      } else if (parameters.precision === "mediump") {
        precisionstring += "\n#define MEDIUM_PRECISION";
      } else if (parameters.precision === "lowp") {
        precisionstring += "\n#define LOW_PRECISION";
      }
      return precisionstring;
    }
    function generateShadowMapTypeDefine(parameters) {
      let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
      if (parameters.shadowMapType === PCFShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
      } else if (parameters.shadowMapType === PCFSoftShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
      } else if (parameters.shadowMapType === VSMShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
      }
      return shadowMapTypeDefine;
    }
    function generateEnvMapTypeDefine(parameters) {
      let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeReflectionMapping:
          case CubeRefractionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            break;
          case CubeUVReflectionMapping:
          case CubeUVRefractionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
      }
      return envMapTypeDefine;
    }
    function generateEnvMapModeDefine(parameters) {
      let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeRefractionMapping:
          case CubeUVRefractionMapping:
            envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            break;
        }
      }
      return envMapModeDefine;
    }
    function generateEnvMapBlendingDefine(parameters) {
      let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
      if (parameters.envMap) {
        switch (parameters.combine) {
          case MultiplyOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case MixOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
            break;
          case AddOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            break;
        }
      }
      return envMapBlendingDefine;
    }
    function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
      const gl = renderer.getContext();
      const defines = parameters.defines;
      let vertexShader = parameters.vertexShader;
      let fragmentShader = parameters.fragmentShader;
      const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
      const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
      const envMapModeDefine = generateEnvMapModeDefine(parameters);
      const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
      const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
      const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
      const customDefines = generateDefines(defines);
      const program = gl.createProgram();
      let prefixVertex, prefixFragment;
      let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
      if (parameters.isRawShaderMaterial) {
        prefixVertex = [
          customDefines
        ].filter(filterEmptyLine).join("\n");
        if (prefixVertex.length > 0) {
          prefixVertex += "\n";
        }
        prefixFragment = [
          customExtensions,
          customDefines
        ].filter(filterEmptyLine).join("\n");
        if (prefixFragment.length > 0) {
          prefixFragment += "\n";
        }
      } else {
        prefixVertex = [
          generatePrecision(parameters),
          "#define SHADER_NAME " + parameters.shaderName,
          customDefines,
          parameters.instancing ? "#define USE_INSTANCING" : "",
          parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          "#define GAMMA_FACTOR " + gammaFactorDefine,
          "#define MAX_BONES " + parameters.maxBones,
          parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
          parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
          parameters.map ? "#define USE_MAP" : "",
          parameters.envMap ? "#define USE_ENVMAP" : "",
          parameters.envMap ? "#define " + envMapModeDefine : "",
          parameters.lightMap ? "#define USE_LIGHTMAP" : "",
          parameters.aoMap ? "#define USE_AOMAP" : "",
          parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          parameters.bumpMap ? "#define USE_BUMPMAP" : "",
          parameters.normalMap ? "#define USE_NORMALMAP" : "",
          parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
          parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
          parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
          parameters.specularMap ? "#define USE_SPECULARMAP" : "",
          parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
          parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
          parameters.transmission ? "#define USE_TRANSMISSION" : "",
          parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          parameters.vertexTangents ? "#define USE_TANGENT" : "",
          parameters.vertexColors ? "#define USE_COLOR" : "",
          parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          parameters.vertexUvs ? "#define USE_UV" : "",
          parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          parameters.flatShading ? "#define FLAT_SHADED" : "",
          parameters.skinning ? "#define USE_SKINNING" : "",
          parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
          parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
          parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
          parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
          parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
          parameters.flipSided ? "#define FLIP_SIDED" : "",
          parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
          parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "	attribute vec3 morphTarget0;",
          "	attribute vec3 morphTarget1;",
          "	attribute vec3 morphTarget2;",
          "	attribute vec3 morphTarget3;",
          "	#ifdef USE_MORPHNORMALS",
          "		attribute vec3 morphNormal0;",
          "		attribute vec3 morphNormal1;",
          "		attribute vec3 morphNormal2;",
          "		attribute vec3 morphNormal3;",
          "	#else",
          "		attribute vec3 morphTarget4;",
          "		attribute vec3 morphTarget5;",
          "		attribute vec3 morphTarget6;",
          "		attribute vec3 morphTarget7;",
          "	#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          "\n"
        ].filter(filterEmptyLine).join("\n");
        prefixFragment = [
          customExtensions,
          generatePrecision(parameters),
          "#define SHADER_NAME " + parameters.shaderName,
          customDefines,
          "#define GAMMA_FACTOR " + gammaFactorDefine,
          parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
          parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
          parameters.map ? "#define USE_MAP" : "",
          parameters.matcap ? "#define USE_MATCAP" : "",
          parameters.envMap ? "#define USE_ENVMAP" : "",
          parameters.envMap ? "#define " + envMapTypeDefine : "",
          parameters.envMap ? "#define " + envMapModeDefine : "",
          parameters.envMap ? "#define " + envMapBlendingDefine : "",
          parameters.lightMap ? "#define USE_LIGHTMAP" : "",
          parameters.aoMap ? "#define USE_AOMAP" : "",
          parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          parameters.bumpMap ? "#define USE_BUMPMAP" : "",
          parameters.normalMap ? "#define USE_NORMALMAP" : "",
          parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
          parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
          parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
          parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          parameters.specularMap ? "#define USE_SPECULARMAP" : "",
          parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
          parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
          parameters.alphaTest ? "#define USE_ALPHATEST" : "",
          parameters.sheen ? "#define USE_SHEEN" : "",
          parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          parameters.transmission ? "#define USE_TRANSMISSION" : "",
          parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          parameters.vertexTangents ? "#define USE_TANGENT" : "",
          parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
          parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          parameters.vertexUvs ? "#define USE_UV" : "",
          parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
          parameters.flatShading ? "#define FLAT_SHADED" : "",
          parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
          parameters.flipSided ? "#define FLIP_SIDED" : "",
          parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
          parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
          (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
          parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
          parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
          parameters.dithering ? "#define DITHERING" : "",
          parameters.format === RGBFormat ? "#define OPAQUE" : "",
          ShaderChunk["encodings_pars_fragment"],
          parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
          parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
          parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
          parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
          parameters.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", parameters.specularColorMapEncoding) : "",
          parameters.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", parameters.sheenColorMapEncoding) : "",
          parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
          getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
          parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
          "\n"
        ].filter(filterEmptyLine).join("\n");
      }
      vertexShader = resolveIncludes(vertexShader);
      vertexShader = replaceLightNums(vertexShader, parameters);
      vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
      fragmentShader = resolveIncludes(fragmentShader);
      fragmentShader = replaceLightNums(fragmentShader, parameters);
      fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
      vertexShader = unrollLoops(vertexShader);
      fragmentShader = unrollLoops(fragmentShader);
      if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        versionString = "#version 300 es\n";
        prefixVertex = [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join("\n") + "\n" + prefixVertex;
        prefixFragment = [
          "#define varying in",
          parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
          parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join("\n") + "\n" + prefixFragment;
      }
      const vertexGlsl = versionString + prefixVertex + vertexShader;
      const fragmentGlsl = versionString + prefixFragment + fragmentShader;
      const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
      const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      if (parameters.index0AttributeName !== void 0) {
        gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
      } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, "position");
      }
      gl.linkProgram(program);
      if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
          runnable = false;
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          this.diagnostics = {
            runnable,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      let cachedUniforms;
      this.getUniforms = function() {
        if (cachedUniforms === void 0) {
          cachedUniforms = new WebGLUniforms(gl, program);
        }
        return cachedUniforms;
      };
      let cachedAttributes;
      this.getAttributes = function() {
        if (cachedAttributes === void 0) {
          cachedAttributes = fetchAttributeLocations(gl, program);
        }
        return cachedAttributes;
      };
      this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = void 0;
      };
      this.name = parameters.shaderName;
      this.id = programIdCount++;
      this.cacheKey = cacheKey;
      this.usedTimes = 1;
      this.program = program;
      this.vertexShader = glVertexShader;
      this.fragmentShader = glFragmentShader;
      return this;
    }
    function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
      const programs = [];
      const isWebGL2 = capabilities.isWebGL2;
      const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
      const floatVertexTextures = capabilities.floatVertexTextures;
      const maxVertexUniforms = capabilities.maxVertexUniforms;
      const vertexTextures = capabilities.vertexTextures;
      let precision = capabilities.precision;
      const shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      };
      const parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoat",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        ,
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "alphaTest",
        "combine",
        "vertexColors",
        "vertexAlphas",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "morphTargetsCount",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        "physicallyCorrectLights",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "format",
        "specularIntensityMap",
        "specularColorMap",
        "specularColorMapEncoding",
        "transmission",
        "transmissionMap",
        "thicknessMap",
        "sheen",
        "sheenColorMap",
        "sheenColorMapEncoding",
        "sheenRoughnessMap"
      ];
      function getMaxBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) {
          return 1024;
        } else {
          const nVertexUniforms = maxVertexUniforms;
          const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          const maxBones = Math.min(nVertexMatrices, bones.length);
          if (maxBones < bones.length) {
            console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
            return 0;
          }
          return maxBones;
        }
      }
      function getTextureEncodingFromMap(map2) {
        let encoding;
        if (map2 && map2.isTexture) {
          encoding = map2.encoding;
        } else if (map2 && map2.isWebGLRenderTarget) {
          console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
          encoding = map2.texture.encoding;
        } else {
          encoding = LinearEncoding;
        }
        if (isWebGL2 && map2 && map2.isTexture && map2.format === RGBAFormat && map2.type === UnsignedByteType && map2.encoding === sRGBEncoding) {
          encoding = LinearEncoding;
        }
        return encoding;
      }
      function getParameters(material, lights, shadows, scene, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material.precision !== null) {
          precision = capabilities.getMaxPrecision(material.precision);
          if (precision !== material.precision) {
            console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
          }
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
          const shader = ShaderLib[shaderID];
          vertexShader = shader.vertexShader;
          fragmentShader = shader.fragmentShader;
        } else {
          vertexShader = material.vertexShader;
          fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const useAlphaTest = material.alphaTest > 0;
        const useClearcoat = material.clearcoat > 0;
        const parameters = {
          isWebGL2,
          shaderID,
          shaderName: material.type,
          vertexShader,
          fragmentShader,
          defines: material.defines,
          isRawShaderMaterial: material.isRawShaderMaterial === true,
          glslVersion: material.glslVersion,
          precision,
          instancing: object.isInstancedMesh === true,
          instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
          supportsVertexTextures: vertexTextures,
          outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
          map: !!material.map,
          mapEncoding: getTextureEncodingFromMap(material.map),
          matcap: !!material.matcap,
          matcapEncoding: getTextureEncodingFromMap(material.matcap),
          envMap: !!envMap,
          envMapMode: envMap && envMap.mapping,
          envMapEncoding: getTextureEncodingFromMap(envMap),
          envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
          lightMap: !!material.lightMap,
          lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
          aoMap: !!material.aoMap,
          emissiveMap: !!material.emissiveMap,
          emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
          tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
          clearcoat: useClearcoat,
          clearcoatMap: useClearcoat && !!material.clearcoatMap,
          clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
          clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
          displacementMap: !!material.displacementMap,
          roughnessMap: !!material.roughnessMap,
          metalnessMap: !!material.metalnessMap,
          specularMap: !!material.specularMap,
          specularIntensityMap: !!material.specularIntensityMap,
          specularColorMap: !!material.specularColorMap,
          specularColorMapEncoding: getTextureEncodingFromMap(material.specularColorMap),
          alphaMap: !!material.alphaMap,
          alphaTest: useAlphaTest,
          gradientMap: !!material.gradientMap,
          sheen: material.sheen > 0,
          sheenColorMap: !!material.sheenColorMap,
          sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
          sheenRoughnessMap: !!material.sheenRoughnessMap,
          transmission: material.transmission > 0,
          transmissionMap: !!material.transmissionMap,
          thicknessMap: !!material.thicknessMap,
          combine: material.combine,
          vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
          vertexColors: material.vertexColors,
          vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
          vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || material.sheenRoughnessMap,
          uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
          fog: !!fog,
          useFog: material.fog,
          fogExp2: fog && fog.isFogExp2,
          flatShading: !!material.flatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer,
          skinning: object.isSkinnedMesh === true && maxBones > 0,
          maxBones,
          useVertexTexture: floatVertexTextures,
          morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
          morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
          morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
          numDirLights: lights.directional.length,
          numPointLights: lights.point.length,
          numSpotLights: lights.spot.length,
          numRectAreaLights: lights.rectArea.length,
          numHemiLights: lights.hemi.length,
          numDirLightShadows: lights.directionalShadowMap.length,
          numPointLightShadows: lights.pointShadowMap.length,
          numSpotLightShadows: lights.spotShadowMap.length,
          numClippingPlanes: clipping.numPlanes,
          numClipIntersection: clipping.numIntersection,
          format: material.format,
          dithering: material.dithering,
          shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
          shadowMapType: renderer.shadowMap.type,
          toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
          physicallyCorrectLights: renderer.physicallyCorrectLights,
          premultipliedAlpha: material.premultipliedAlpha,
          doubleSided: material.side === DoubleSide,
          flipSided: material.side === BackSide,
          depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
          index0AttributeName: material.index0AttributeName,
          extensionDerivatives: material.extensions && material.extensions.derivatives,
          extensionFragDepth: material.extensions && material.extensions.fragDepth,
          extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
          extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
          customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
      }
      function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) {
          array.push(parameters.shaderID);
        } else {
          array.push(hashString(parameters.fragmentShader));
          array.push(hashString(parameters.vertexShader));
        }
        if (parameters.defines !== void 0) {
          for (const name in parameters.defines) {
            array.push(name);
            array.push(parameters.defines[name]);
          }
        }
        if (parameters.isRawShaderMaterial === false) {
          for (let i2 = 0; i2 < parameterNames.length; i2++) {
            array.push(parameters[parameterNames[i2]]);
          }
          array.push(renderer.outputEncoding);
          array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
      }
      function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
          const shader = ShaderLib[shaderID];
          uniforms = UniformsUtils.clone(shader.uniforms);
        } else {
          uniforms = material.uniforms;
        }
        return uniforms;
      }
      function acquireProgram(parameters, cacheKey) {
        let program;
        for (let p = 0, pl = programs.length; p < pl; p++) {
          const preexistingProgram = programs[p];
          if (preexistingProgram.cacheKey === cacheKey) {
            program = preexistingProgram;
            ++program.usedTimes;
            break;
          }
        }
        if (program === void 0) {
          program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
          programs.push(program);
        }
        return program;
      }
      function releaseProgram(program) {
        if (--program.usedTimes === 0) {
          const i2 = programs.indexOf(program);
          programs[i2] = programs[programs.length - 1];
          programs.pop();
          program.destroy();
        }
      }
      return {
        getParameters,
        getProgramCacheKey,
        getUniforms,
        acquireProgram,
        releaseProgram,
        programs
      };
    }
    function WebGLProperties() {
      let properties = new WeakMap();
      function get(object) {
        let map2 = properties.get(object);
        if (map2 === void 0) {
          map2 = {};
          properties.set(object, map2);
        }
        return map2;
      }
      function remove2(object) {
        properties.delete(object);
      }
      function update(object, key, value) {
        properties.get(object)[key] = value;
      }
      function dispose() {
        properties = new WeakMap();
      }
      return {
        get,
        remove: remove2,
        update,
        dispose
      };
    }
    function painterSortStable(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.program !== b.program) {
        return a.program.id - b.program.id;
      } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
      } else if (a.z !== b.z) {
        return a.z - b.z;
      } else {
        return a.id - b.id;
      }
    }
    function reversePainterSortStable(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.z !== b.z) {
        return b.z - a.z;
      } else {
        return a.id - b.id;
      }
    }
    function WebGLRenderList(properties) {
      const renderItems = [];
      let renderItemsIndex = 0;
      const opaque = [];
      const transmissive = [];
      const transparent = [];
      const defaultProgram = { id: -1 };
      function init6() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transmissive.length = 0;
        transparent.length = 0;
      }
      function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === void 0) {
          renderItem = {
            id: object.id,
            object,
            geometry,
            material,
            program: materialProperties.program || defaultProgram,
            groupOrder,
            renderOrder: object.renderOrder,
            z,
            group
          };
          renderItems[renderItemsIndex] = renderItem;
        } else {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material;
          renderItem.program = materialProperties.program || defaultProgram;
          renderItem.groupOrder = groupOrder;
          renderItem.renderOrder = object.renderOrder;
          renderItem.z = z;
          renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
      }
      function push(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0) {
          transmissive.push(renderItem);
        } else if (material.transparent === true) {
          transparent.push(renderItem);
        } else {
          opaque.push(renderItem);
        }
      }
      function unshift(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0) {
          transmissive.unshift(renderItem);
        } else if (material.transparent === true) {
          transparent.unshift(renderItem);
        } else {
          opaque.unshift(renderItem);
        }
      }
      function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1)
          opaque.sort(customOpaqueSort || painterSortStable);
        if (transmissive.length > 1)
          transmissive.sort(customTransparentSort || reversePainterSortStable);
        if (transparent.length > 1)
          transparent.sort(customTransparentSort || reversePainterSortStable);
      }
      function finish() {
        for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
          const renderItem = renderItems[i2];
          if (renderItem.id === null)
            break;
          renderItem.id = null;
          renderItem.object = null;
          renderItem.geometry = null;
          renderItem.material = null;
          renderItem.program = null;
          renderItem.group = null;
        }
      }
      return {
        opaque,
        transmissive,
        transparent,
        init: init6,
        push,
        unshift,
        finish,
        sort
      };
    }
    function WebGLRenderLists(properties) {
      let lists = new WeakMap();
      function get(scene, renderCallDepth) {
        let list;
        if (lists.has(scene) === false) {
          list = new WebGLRenderList(properties);
          lists.set(scene, [list]);
        } else {
          if (renderCallDepth >= lists.get(scene).length) {
            list = new WebGLRenderList(properties);
            lists.get(scene).push(list);
          } else {
            list = lists.get(scene)[renderCallDepth];
          }
        }
        return list;
      }
      function dispose() {
        lists = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    function UniformsCache() {
      const lights = {};
      return {
        get: function(light) {
          if (lights[light.id] !== void 0) {
            return lights[light.id];
          }
          let uniforms;
          switch (light.type) {
            case "DirectionalLight":
              uniforms = {
                direction: new Vector3(),
                color: new Color()
              };
              break;
            case "SpotLight":
              uniforms = {
                position: new Vector3(),
                direction: new Vector3(),
                color: new Color(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0
              };
              break;
            case "PointLight":
              uniforms = {
                position: new Vector3(),
                color: new Color(),
                distance: 0,
                decay: 0
              };
              break;
            case "HemisphereLight":
              uniforms = {
                direction: new Vector3(),
                skyColor: new Color(),
                groundColor: new Color()
              };
              break;
            case "RectAreaLight":
              uniforms = {
                color: new Color(),
                position: new Vector3(),
                halfWidth: new Vector3(),
                halfHeight: new Vector3()
              };
              break;
          }
          lights[light.id] = uniforms;
          return uniforms;
        }
      };
    }
    function ShadowUniformsCache() {
      const lights = {};
      return {
        get: function(light) {
          if (lights[light.id] !== void 0) {
            return lights[light.id];
          }
          let uniforms;
          switch (light.type) {
            case "DirectionalLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
              };
              break;
            case "SpotLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
              };
              break;
            case "PointLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              };
              break;
          }
          lights[light.id] = uniforms;
          return uniforms;
        }
      };
    }
    var nextVersion = 0;
    function shadowCastingLightsFirst(lightA, lightB) {
      return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
    }
    function WebGLLights(extensions, capabilities) {
      const cache = new UniformsCache();
      const shadowCache = ShadowUniformsCache();
      const state = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
      };
      for (let i2 = 0; i2 < 9; i2++)
        state.probe.push(new Vector3());
      const vector3 = new Vector3();
      const matrix4 = new Matrix4();
      const matrix42 = new Matrix4();
      function setup(lights, physicallyCorrectLights) {
        let r = 0, g = 0, b = 0;
        for (let i2 = 0; i2 < 9; i2++)
          state.probe[i2].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        lights.sort(shadowCastingLightsFirst);
        const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
        for (let i2 = 0, l = lights.length; i2 < l; i2++) {
          const light = lights[i2];
          const color = light.color;
          const intensity = light.intensity;
          const distance = light.distance;
          const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
          if (light.isAmbientLight) {
            r += color.r * intensity * scaleFactor;
            g += color.g * intensity * scaleFactor;
            b += color.b * intensity * scaleFactor;
          } else if (light.isLightProbe) {
            for (let j = 0; j < 9; j++) {
              state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            }
          } else if (light.isDirectionalLight) {
            const uniforms = cache.get(light);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
            if (light.castShadow) {
              const shadow = light.shadow;
              const shadowUniforms = shadowCache.get(light);
              shadowUniforms.shadowBias = shadow.bias;
              shadowUniforms.shadowNormalBias = shadow.normalBias;
              shadowUniforms.shadowRadius = shadow.radius;
              shadowUniforms.shadowMapSize = shadow.mapSize;
              state.directionalShadow[directionalLength] = shadowUniforms;
              state.directionalShadowMap[directionalLength] = shadowMap;
              state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
              numDirectionalShadows++;
            }
            state.directional[directionalLength] = uniforms;
            directionalLength++;
          } else if (light.isSpotLight) {
            const uniforms = cache.get(light);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
            uniforms.distance = distance;
            uniforms.coneCos = Math.cos(light.angle);
            uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
            uniforms.decay = light.decay;
            if (light.castShadow) {
              const shadow = light.shadow;
              const shadowUniforms = shadowCache.get(light);
              shadowUniforms.shadowBias = shadow.bias;
              shadowUniforms.shadowNormalBias = shadow.normalBias;
              shadowUniforms.shadowRadius = shadow.radius;
              shadowUniforms.shadowMapSize = shadow.mapSize;
              state.spotShadow[spotLength] = shadowUniforms;
              state.spotShadowMap[spotLength] = shadowMap;
              state.spotShadowMatrix[spotLength] = light.shadow.matrix;
              numSpotShadows++;
            }
            state.spot[spotLength] = uniforms;
            spotLength++;
          } else if (light.isRectAreaLight) {
            const uniforms = cache.get(light);
            uniforms.color.copy(color).multiplyScalar(intensity);
            uniforms.halfWidth.set(light.width * 0.5, 0, 0);
            uniforms.halfHeight.set(0, light.height * 0.5, 0);
            state.rectArea[rectAreaLength] = uniforms;
            rectAreaLength++;
          } else if (light.isPointLight) {
            const uniforms = cache.get(light);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
            uniforms.distance = light.distance;
            uniforms.decay = light.decay;
            if (light.castShadow) {
              const shadow = light.shadow;
              const shadowUniforms = shadowCache.get(light);
              shadowUniforms.shadowBias = shadow.bias;
              shadowUniforms.shadowNormalBias = shadow.normalBias;
              shadowUniforms.shadowRadius = shadow.radius;
              shadowUniforms.shadowMapSize = shadow.mapSize;
              shadowUniforms.shadowCameraNear = shadow.camera.near;
              shadowUniforms.shadowCameraFar = shadow.camera.far;
              state.pointShadow[pointLength] = shadowUniforms;
              state.pointShadowMap[pointLength] = shadowMap;
              state.pointShadowMatrix[pointLength] = light.shadow.matrix;
              numPointShadows++;
            }
            state.point[pointLength] = uniforms;
            pointLength++;
          } else if (light.isHemisphereLight) {
            const uniforms = cache.get(light);
            uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
            uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
            state.hemi[hemiLength] = uniforms;
            hemiLength++;
          }
        }
        if (rectAreaLength > 0) {
          if (capabilities.isWebGL2) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else {
            if (extensions.has("OES_texture_float_linear") === true) {
              state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
              state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else if (extensions.has("OES_texture_half_float_linear") === true) {
              state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
              state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
            } else {
              console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
            }
          }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
          state.directional.length = directionalLength;
          state.spot.length = spotLength;
          state.rectArea.length = rectAreaLength;
          state.point.length = pointLength;
          state.hemi.length = hemiLength;
          state.directionalShadow.length = numDirectionalShadows;
          state.directionalShadowMap.length = numDirectionalShadows;
          state.pointShadow.length = numPointShadows;
          state.pointShadowMap.length = numPointShadows;
          state.spotShadow.length = numSpotShadows;
          state.spotShadowMap.length = numSpotShadows;
          state.directionalShadowMatrix.length = numDirectionalShadows;
          state.pointShadowMatrix.length = numPointShadows;
          state.spotShadowMatrix.length = numSpotShadows;
          hash.directionalLength = directionalLength;
          hash.pointLength = pointLength;
          hash.spotLength = spotLength;
          hash.rectAreaLength = rectAreaLength;
          hash.hemiLength = hemiLength;
          hash.numDirectionalShadows = numDirectionalShadows;
          hash.numPointShadows = numPointShadows;
          hash.numSpotShadows = numSpotShadows;
          state.version = nextVersion++;
        }
      }
      function setupView(lights, camera) {
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        const viewMatrix = camera.matrixWorldInverse;
        for (let i2 = 0, l = lights.length; i2 < l; i2++) {
          const light = lights[i2];
          if (light.isDirectionalLight) {
            const uniforms = state.directional[directionalLength];
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(vector3);
            uniforms.direction.transformDirection(viewMatrix);
            directionalLength++;
          } else if (light.isSpotLight) {
            const uniforms = state.spot[spotLength];
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(vector3);
            uniforms.direction.transformDirection(viewMatrix);
            spotLength++;
          } else if (light.isRectAreaLight) {
            const uniforms = state.rectArea[rectAreaLength];
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            matrix42.identity();
            matrix4.copy(light.matrixWorld);
            matrix4.premultiply(viewMatrix);
            matrix42.extractRotation(matrix4);
            uniforms.halfWidth.set(light.width * 0.5, 0, 0);
            uniforms.halfHeight.set(0, light.height * 0.5, 0);
            uniforms.halfWidth.applyMatrix4(matrix42);
            uniforms.halfHeight.applyMatrix4(matrix42);
            rectAreaLength++;
          } else if (light.isPointLight) {
            const uniforms = state.point[pointLength];
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            pointLength++;
          } else if (light.isHemisphereLight) {
            const uniforms = state.hemi[hemiLength];
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.direction.normalize();
            hemiLength++;
          }
        }
      }
      return {
        setup,
        setupView,
        state
      };
    }
    function WebGLRenderState(extensions, capabilities) {
      const lights = new WebGLLights(extensions, capabilities);
      const lightsArray = [];
      const shadowsArray = [];
      function init6() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
      }
      function pushLight(light) {
        lightsArray.push(light);
      }
      function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
      }
      function setupLights(physicallyCorrectLights) {
        lights.setup(lightsArray, physicallyCorrectLights);
      }
      function setupLightsView(camera) {
        lights.setupView(lightsArray, camera);
      }
      const state = {
        lightsArray,
        shadowsArray,
        lights
      };
      return {
        init: init6,
        state,
        setupLights,
        setupLightsView,
        pushLight,
        pushShadow
      };
    }
    function WebGLRenderStates(extensions, capabilities) {
      let renderStates = new WeakMap();
      function get(scene, renderCallDepth = 0) {
        let renderState;
        if (renderStates.has(scene) === false) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.set(scene, [renderState]);
        } else {
          if (renderCallDepth >= renderStates.get(scene).length) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.get(scene).push(renderState);
          } else {
            renderState = renderStates.get(scene)[renderCallDepth];
          }
        }
        return renderState;
      }
      function dispose() {
        renderStates = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    var MeshDepthMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshDepthMaterial";
        this.depthPacking = BasicDepthPacking;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
      }
    };
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    var MeshDistanceMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshDistanceMaterial";
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1e3;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
      }
    };
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
    var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    function WebGLShadowMap(_renderer, _objects, _capabilities) {
      let _frustum = new Frustum();
      const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
      const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
      const shadowMaterialVertical = new ShaderMaterial({
        defines: {
          VSM_SAMPLES: 8
        },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new Vector2() },
          radius: { value: 4 }
        },
        vertexShader: vertex,
        fragmentShader: fragment
      });
      const shadowMaterialHorizontal = shadowMaterialVertical.clone();
      shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
      const fullScreenTri = new BufferGeometry();
      fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
      const scope = this;
      this.enabled = false;
      this.autoUpdate = true;
      this.needsUpdate = false;
      this.type = PCFShadowMap;
      this.render = function(lights, scene, camera) {
        if (scope.enabled === false)
          return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
          return;
        if (lights.length === 0)
          return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        for (let i2 = 0, il = lights.length; i2 < il; i2++) {
          const light = lights[i2];
          const shadow = light.shadow;
          if (shadow === void 0) {
            console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
            continue;
          }
          if (shadow.autoUpdate === false && shadow.needsUpdate === false)
            continue;
          _shadowMapSize.copy(shadow.mapSize);
          const shadowFrameExtents = shadow.getFrameExtents();
          _shadowMapSize.multiply(shadowFrameExtents);
          _viewportSize.copy(shadow.mapSize);
          if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
            if (_shadowMapSize.x > _maxTextureSize) {
              _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
              _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
              shadow.mapSize.x = _viewportSize.x;
            }
            if (_shadowMapSize.y > _maxTextureSize) {
              _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
              _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
              shadow.mapSize.y = _viewportSize.y;
            }
          }
          if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
            const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.camera.updateProjectionMatrix();
          }
          if (shadow.map === null) {
            const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.camera.updateProjectionMatrix();
          }
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          const viewportCount = shadow.getViewportCount();
          for (let vp = 0; vp < viewportCount; vp++) {
            const viewport = shadow.getViewport(vp);
            _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
            _state.viewport(_viewport);
            shadow.updateMatrices(light, vp);
            _frustum = shadow.getFrustum();
            renderObject(scene, camera, shadow.camera, light, this.type);
          }
          if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
            VSMPass(shadow, camera);
          }
          shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
      };
      function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
          shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
          shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
          shadowMaterialVertical.needsUpdate = true;
          shadowMaterialHorizontal.needsUpdate = true;
        }
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
      }
      function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
        if (customMaterial !== void 0) {
          result = customMaterial;
        } else {
          result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        }
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
          const keyA = result.uuid, keyB = material.uuid;
          let materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          let cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
          }
          result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) {
          result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        } else {
          result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        }
        result.alphaMap = material.alphaMap;
        result.alphaTest = material.alphaTest;
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.displacementMap = material.displacementMap;
        result.displacementScale = material.displacementScale;
        result.displacementBias = material.displacementBias;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
          result.referencePosition.setFromMatrixPosition(light.matrixWorld);
          result.nearDistance = shadowCameraNear;
          result.farDistance = shadowCameraFar;
        }
        return result;
      }
      function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false)
          return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
          if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
            object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
            const geometry = _objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let k = 0, kl = groups.length; k < kl; k++) {
                const group = groups[k];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                  _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                }
              }
            } else if (material.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
            }
          }
        }
        const children2 = object.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          renderObject(children2[i2], camera, shadowCamera, light, type);
        }
      }
    }
    function WebGLState(gl, extensions, capabilities) {
      const isWebGL2 = capabilities.isWebGL2;
      function ColorBuffer() {
        let locked = false;
        const color = new Vector4();
        let currentColorMask = null;
        const currentColorClear = new Vector4(0, 0, 0, 0);
        return {
          setMask: function(colorMask) {
            if (currentColorMask !== colorMask && !locked) {
              gl.colorMask(colorMask, colorMask, colorMask, colorMask);
              currentColorMask = colorMask;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(r, g, b, a, premultipliedAlpha) {
            if (premultipliedAlpha === true) {
              r *= a;
              g *= a;
              b *= a;
            }
            color.set(r, g, b, a);
            if (currentColorClear.equals(color) === false) {
              gl.clearColor(r, g, b, a);
              currentColorClear.copy(color);
            }
          },
          reset: function() {
            locked = false;
            currentColorMask = null;
            currentColorClear.set(-1, 0, 0, 0);
          }
        };
      }
      function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
          setTest: function(depthTest) {
            if (depthTest) {
              enable(2929);
            } else {
              disable(2929);
            }
          },
          setMask: function(depthMask) {
            if (currentDepthMask !== depthMask && !locked) {
              gl.depthMask(depthMask);
              currentDepthMask = depthMask;
            }
          },
          setFunc: function(depthFunc) {
            if (currentDepthFunc !== depthFunc) {
              if (depthFunc) {
                switch (depthFunc) {
                  case NeverDepth:
                    gl.depthFunc(512);
                    break;
                  case AlwaysDepth:
                    gl.depthFunc(519);
                    break;
                  case LessDepth:
                    gl.depthFunc(513);
                    break;
                  case LessEqualDepth:
                    gl.depthFunc(515);
                    break;
                  case EqualDepth:
                    gl.depthFunc(514);
                    break;
                  case GreaterEqualDepth:
                    gl.depthFunc(518);
                    break;
                  case GreaterDepth:
                    gl.depthFunc(516);
                    break;
                  case NotEqualDepth:
                    gl.depthFunc(517);
                    break;
                  default:
                    gl.depthFunc(515);
                }
              } else {
                gl.depthFunc(515);
              }
              currentDepthFunc = depthFunc;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(depth) {
            if (currentDepthClear !== depth) {
              gl.clearDepth(depth);
              currentDepthClear = depth;
            }
          },
          reset: function() {
            locked = false;
            currentDepthMask = null;
            currentDepthFunc = null;
            currentDepthClear = null;
          }
        };
      }
      function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
          setTest: function(stencilTest) {
            if (!locked) {
              if (stencilTest) {
                enable(2960);
              } else {
                disable(2960);
              }
            }
          },
          setMask: function(stencilMask) {
            if (currentStencilMask !== stencilMask && !locked) {
              gl.stencilMask(stencilMask);
              currentStencilMask = stencilMask;
            }
          },
          setFunc: function(stencilFunc, stencilRef, stencilMask) {
            if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
              gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
              currentStencilFunc = stencilFunc;
              currentStencilRef = stencilRef;
              currentStencilFuncMask = stencilMask;
            }
          },
          setOp: function(stencilFail, stencilZFail, stencilZPass) {
            if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
              gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
              currentStencilFail = stencilFail;
              currentStencilZFail = stencilZFail;
              currentStencilZPass = stencilZPass;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(stencil) {
            if (currentStencilClear !== stencil) {
              gl.clearStencil(stencil);
              currentStencilClear = stencil;
            }
          },
          reset: function() {
            locked = false;
            currentStencilMask = null;
            currentStencilFunc = null;
            currentStencilRef = null;
            currentStencilFuncMask = null;
            currentStencilFail = null;
            currentStencilZFail = null;
            currentStencilZPass = null;
            currentStencilClear = null;
          }
        };
      }
      const colorBuffer = new ColorBuffer();
      const depthBuffer = new DepthBuffer();
      const stencilBuffer = new StencilBuffer();
      let enabledCapabilities = {};
      let xrFramebuffer = null;
      let currentBoundFramebuffers = {};
      let currentProgram = null;
      let currentBlendingEnabled = false;
      let currentBlending = null;
      let currentBlendEquation = null;
      let currentBlendSrc = null;
      let currentBlendDst = null;
      let currentBlendEquationAlpha = null;
      let currentBlendSrcAlpha = null;
      let currentBlendDstAlpha = null;
      let currentPremultipledAlpha = false;
      let currentFlipSided = null;
      let currentCullFace = null;
      let currentLineWidth = null;
      let currentPolygonOffsetFactor = null;
      let currentPolygonOffsetUnits = null;
      const maxTextures = gl.getParameter(35661);
      let lineWidthAvailable = false;
      let version = 0;
      const glVersion = gl.getParameter(7938);
      if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
      } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
      }
      let currentTextureSlot = null;
      let currentBoundTextures = {};
      const scissorParam = gl.getParameter(3088);
      const viewportParam = gl.getParameter(2978);
      const currentScissor = new Vector4().fromArray(scissorParam);
      const currentViewport = new Vector4().fromArray(viewportParam);
      function createTexture(type, target, count) {
        const data = new Uint8Array(4);
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for (let i2 = 0; i2 < count; i2++) {
          gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
        }
        return texture;
      }
      const emptyTextures = {};
      emptyTextures[3553] = createTexture(3553, 3553, 1);
      emptyTextures[34067] = createTexture(34067, 34069, 6);
      colorBuffer.setClear(0, 0, 0, 1);
      depthBuffer.setClear(1);
      stencilBuffer.setClear(0);
      enable(2929);
      depthBuffer.setFunc(LessEqualDepth);
      setFlipSided(false);
      setCullFace(CullFaceBack);
      enable(2884);
      setBlending(NoBlending);
      function enable(id2) {
        if (enabledCapabilities[id2] !== true) {
          gl.enable(id2);
          enabledCapabilities[id2] = true;
        }
      }
      function disable(id2) {
        if (enabledCapabilities[id2] !== false) {
          gl.disable(id2);
          enabledCapabilities[id2] = false;
        }
      }
      function bindXRFramebuffer(framebuffer) {
        if (framebuffer !== xrFramebuffer) {
          gl.bindFramebuffer(36160, framebuffer);
          xrFramebuffer = framebuffer;
        }
      }
      function bindFramebuffer(target, framebuffer) {
        if (framebuffer === null && xrFramebuffer !== null)
          framebuffer = xrFramebuffer;
        if (currentBoundFramebuffers[target] !== framebuffer) {
          gl.bindFramebuffer(target, framebuffer);
          currentBoundFramebuffers[target] = framebuffer;
          if (isWebGL2) {
            if (target === 36009) {
              currentBoundFramebuffers[36160] = framebuffer;
            }
            if (target === 36160) {
              currentBoundFramebuffers[36009] = framebuffer;
            }
          }
          return true;
        }
        return false;
      }
      function useProgram(program) {
        if (currentProgram !== program) {
          gl.useProgram(program);
          currentProgram = program;
          return true;
        }
        return false;
      }
      const equationToGL = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
      };
      if (isWebGL2) {
        equationToGL[MinEquation] = 32775;
        equationToGL[MaxEquation] = 32776;
      } else {
        const extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
          equationToGL[MinEquation] = extension.MIN_EXT;
          equationToGL[MaxEquation] = extension.MAX_EXT;
        }
      }
      const factorToGL = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
      };
      function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
          if (currentBlendingEnabled === true) {
            disable(3042);
            currentBlendingEnabled = false;
          }
          return;
        }
        if (currentBlendingEnabled === false) {
          enable(3042);
          currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
          if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
            if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
              gl.blendEquation(32774);
              currentBlendEquation = AddEquation;
              currentBlendEquationAlpha = AddEquation;
            }
            if (premultipliedAlpha) {
              switch (blending) {
                case NormalBlending:
                  gl.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case AdditiveBlending:
                  gl.blendFunc(1, 1);
                  break;
                case SubtractiveBlending:
                  gl.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case MultiplyBlending:
                  gl.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            } else {
              switch (blending) {
                case NormalBlending:
                  gl.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case AdditiveBlending:
                  gl.blendFunc(770, 1);
                  break;
                case SubtractiveBlending:
                  gl.blendFunc(0, 769);
                  break;
                case MultiplyBlending:
                  gl.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            }
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
          }
          return;
        }
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
          gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
          currentBlendEquation = blendEquation;
          currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
          gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
          currentBlendSrc = blendSrc;
          currentBlendDst = blendDst;
          currentBlendSrcAlpha = blendSrcAlpha;
          currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
      }
      function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(2884) : enable(2884);
        let flipSided = material.side === BackSide;
        if (frontFaceCW)
          flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
          stencilBuffer.setMask(material.stencilWriteMask);
          stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
          stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        material.alphaToCoverage === true ? enable(32926) : disable(32926);
      }
      function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(2304);
          } else {
            gl.frontFace(2305);
          }
          currentFlipSided = flipSided;
        }
      }
      function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
          enable(2884);
          if (cullFace !== currentCullFace) {
            if (cullFace === CullFaceBack) {
              gl.cullFace(1029);
            } else if (cullFace === CullFaceFront) {
              gl.cullFace(1028);
            } else {
              gl.cullFace(1032);
            }
          }
        } else {
          disable(2884);
        }
        currentCullFace = cullFace;
      }
      function setLineWidth(width) {
        if (width !== currentLineWidth) {
          if (lineWidthAvailable)
            gl.lineWidth(width);
          currentLineWidth = width;
        }
      }
      function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
          enable(32823);
          if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
            gl.polygonOffset(factor, units);
            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;
          }
        } else {
          disable(32823);
        }
      }
      function setScissorTest(scissorTest) {
        if (scissorTest) {
          enable(3089);
        } else {
          disable(3089);
        }
      }
      function activeTexture(webglSlot) {
        if (webglSlot === void 0)
          webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
      }
      function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) {
          activeTexture();
        }
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === void 0) {
          boundTexture = { type: void 0, texture: void 0 };
          currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      }
      function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== void 0 && boundTexture.type !== void 0) {
          gl.bindTexture(boundTexture.type, null);
          boundTexture.type = void 0;
          boundTexture.texture = void 0;
        }
      }
      function compressedTexImage2D() {
        try {
          gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage2D() {
        try {
          gl.texImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage3D() {
        try {
          gl.texImage3D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function scissor(scissor2) {
        if (currentScissor.equals(scissor2) === false) {
          gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
          currentScissor.copy(scissor2);
        }
      }
      function viewport(viewport2) {
        if (currentViewport.equals(viewport2) === false) {
          gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
          currentViewport.copy(viewport2);
        }
      }
      function reset() {
        gl.disable(3042);
        gl.disable(2884);
        gl.disable(2929);
        gl.disable(32823);
        gl.disable(3089);
        gl.disable(2960);
        gl.disable(32926);
        gl.blendEquation(32774);
        gl.blendFunc(1, 0);
        gl.blendFuncSeparate(1, 0, 1, 0);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(513);
        gl.clearDepth(1);
        gl.stencilMask(4294967295);
        gl.stencilFunc(519, 0, 4294967295);
        gl.stencilOp(7680, 7680, 7680);
        gl.clearStencil(0);
        gl.cullFace(1029);
        gl.frontFace(2305);
        gl.polygonOffset(0, 0);
        gl.activeTexture(33984);
        gl.bindFramebuffer(36160, null);
        if (isWebGL2 === true) {
          gl.bindFramebuffer(36009, null);
          gl.bindFramebuffer(36008, null);
        }
        gl.useProgram(null);
        gl.lineWidth(1);
        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        xrFramebuffer = null;
        currentBoundFramebuffers = {};
        currentProgram = null;
        currentBlendingEnabled = false;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
      }
      return {
        buffers: {
          color: colorBuffer,
          depth: depthBuffer,
          stencil: stencilBuffer
        },
        enable,
        disable,
        bindFramebuffer,
        bindXRFramebuffer,
        useProgram,
        setBlending,
        setMaterial,
        setFlipSided,
        setCullFace,
        setLineWidth,
        setPolygonOffset,
        setScissorTest,
        activeTexture,
        bindTexture,
        unbindTexture,
        compressedTexImage2D,
        texImage2D,
        texImage3D,
        scissor,
        viewport,
        reset
      };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
      const isWebGL2 = capabilities.isWebGL2;
      const maxTextures = capabilities.maxTextures;
      const maxCubemapSize = capabilities.maxCubemapSize;
      const maxTextureSize = capabilities.maxTextureSize;
      const maxSamples = capabilities.maxSamples;
      const _videoTextures = new WeakMap();
      let _canvas3;
      let useOffscreenCanvas = false;
      try {
        useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
      } catch (err) {
      }
      function createCanvas(width, height) {
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
      }
      function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        if (image.width > maxSize || image.height > maxSize) {
          scale = maxSize / Math.max(image.width, image.height);
        }
        if (scale < 1 || needsPowerOfTwo === true) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
            const width = floor(scale * image.width);
            const height = floor(scale * image.height);
            if (_canvas3 === void 0)
              _canvas3 = createCanvas(width, height);
            const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas3;
            canvas.width = width;
            canvas.height = height;
            const context3 = canvas.getContext("2d");
            context3.drawImage(image, 0, 0, width, height);
            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
            return canvas;
          } else {
            if ("data" in image) {
              console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
            }
            return image;
          }
        }
        return image;
      }
      function isPowerOfTwo$1(image) {
        return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
      }
      function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2)
          return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      }
      function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      }
      function generateMipmap(target, texture, width, height, depth = 1) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
      }
      function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
        if (isWebGL2 === false)
          return glFormat;
        if (internalFormatName !== null) {
          if (_gl[internalFormatName] !== void 0)
            return _gl[internalFormatName];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
          if (glType === 5126)
            internalFormat = 33326;
          if (glType === 5131)
            internalFormat = 33325;
          if (glType === 5121)
            internalFormat = 33321;
        }
        if (glFormat === 6407) {
          if (glType === 5126)
            internalFormat = 34837;
          if (glType === 5131)
            internalFormat = 34843;
          if (glType === 5121)
            internalFormat = 32849;
        }
        if (glFormat === 6408) {
          if (glType === 5126)
            internalFormat = 34836;
          if (glType === 5131)
            internalFormat = 34842;
          if (glType === 5121)
            internalFormat = encoding === sRGBEncoding ? 35907 : 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
          extensions.get("EXT_color_buffer_float");
        }
        return internalFormat;
      }
      function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
          return 9728;
        }
        return 9729;
      }
      function onTextureDispose(event2) {
        const texture = event2.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) {
          _videoTextures.delete(texture);
        }
        info.memory.textures--;
      }
      function onRenderTargetDispose(event2) {
        const renderTarget = event2.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
      }
      function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === void 0)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
      }
      function deallocateRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        if (!renderTarget)
          return;
        if (textureProperties.__webglTexture !== void 0) {
          _gl.deleteTexture(textureProperties.__webglTexture);
          info.memory.textures--;
        }
        if (renderTarget.depthTexture) {
          renderTarget.depthTexture.dispose();
        }
        if (renderTarget.isWebGLCubeRenderTarget) {
          for (let i2 = 0; i2 < 6; i2++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
          }
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
          if (renderTargetProperties.__webglMultisampledFramebuffer)
            _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
          if (renderTargetProperties.__webglColorRenderbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
          if (renderTargetProperties.__webglDepthRenderbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          for (let i2 = 0, il = texture.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(texture[i2]);
            if (attachmentProperties.__webglTexture) {
              _gl.deleteTexture(attachmentProperties.__webglTexture);
              info.memory.textures--;
            }
            properties.remove(texture[i2]);
          }
        }
        properties.remove(texture);
        properties.remove(renderTarget);
      }
      let textureUnits = 0;
      function resetTextureUnits() {
        textureUnits = 0;
      }
      function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) {
          console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
        }
        textureUnits += 1;
        return textureUnit;
      }
      function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture)
          updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          const image = texture.image;
          if (image === void 0) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
          } else if (image.complete === false) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          } else {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
      }
      function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
      }
      function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
      }
      function setTextureCube(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadCubeTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
      }
      const wrappingToGL = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
      };
      const filterToGL = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
      };
      function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
          _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
          _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
          }
          _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
          _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
          _gl.texParameteri(textureType, 10242, 33071);
          _gl.texParameteri(textureType, 10243, 33071);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, 33071);
          }
          if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
          }
          _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
          if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
          }
        }
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
          const extension = extensions.get("EXT_texture_filter_anisotropic");
          if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
            return;
          if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
            return;
          if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === void 0) {
          textureProperties.__webglInit = true;
          texture.addEventListener("dispose", onTextureDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          info.memory.textures++;
        }
      }
      function uploadTexture(textureProperties, texture, slot) {
        let textureType = 3553;
        if (texture.isDataTexture2DArray)
          textureType = 35866;
        if (texture.isDataTexture3D)
          textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (isWebGL2) {
            if (texture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (texture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            } else if (texture.type === UnsignedInt248Type) {
              glInternalFormat = 35056;
            } else {
              glInternalFormat = 33189;
            }
          } else {
            if (texture.type === FloatType) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedShortType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
              mipmap = mipmaps[i2];
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
          }
        } else if (texture.isCompressedTexture) {
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
              mipmap = mipmaps[i2];
              state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6)
          return;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i2 = 0; i2 < 6; i2++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
          } else {
            cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
          }
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
          for (let i2 = 0; i2 < 6; i2++) {
            mipmaps = cubeImage[i2].mipmaps;
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (glFormat !== null) {
                  state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          mipmaps = texture.mipmaps;
          for (let i2 = 0; i2 < 6; i2++) {
            if (isDataTexture) {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                const mipmapImage = mipmap.image[i2].image;
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
        const glFormat = utils.convert(texture.format);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        if (textureTarget === 32879 || textureTarget === 35866) {
          state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
        state.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
        state.bindFramebuffer(36160, null);
      }
      function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          let glInternalFormat = 33189;
          if (isMultisample) {
            const depthTexture = renderTarget.depthTexture;
            if (depthTexture && depthTexture.isDepthTexture) {
              if (depthTexture.type === FloatType) {
                glInternalFormat = 36012;
              } else if (depthTexture.type === UnsignedIntType) {
                glInternalFormat = 33190;
              }
            }
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          if (isMultisample) {
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
          const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          if (isMultisample) {
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
        _gl.bindRenderbuffer(36161, null);
      }
      function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube)
          throw new Error("Depth Texture with cube render targets is not supported");
        state.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        }
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
          renderTarget.depthTexture.image.width = renderTarget.width;
          renderTarget.depthTexture.image.height = renderTarget.height;
          renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        } else {
          throw new Error("Unknown depthTexture format");
        }
      }
      function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
          if (isCube)
            throw new Error("target.depthTexture not supported in Cube render targets");
          setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else {
          if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for (let i2 = 0; i2 < 6; i2++) {
              state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
              renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
            }
          } else {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
          }
        }
        state.bindFramebuffer(36160, null);
      }
      function setupRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        if (renderTarget.isWebGLMultipleRenderTargets !== true) {
          textureProperties.__webglTexture = _gl.createTexture();
          textureProperties.__version = texture.version;
          info.memory.textures++;
        }
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
          texture.format = RGBAFormat;
          console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
        }
        if (isCube) {
          renderTargetProperties.__webglFramebuffer = [];
          for (let i2 = 0; i2 < 6; i2++) {
            renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
          if (isMultipleRenderTargets) {
            if (capabilities.drawBuffers) {
              const textures = renderTarget.texture;
              for (let i2 = 0, il = textures.length; i2 < il; i2++) {
                const attachmentProperties = properties.get(textures[i2]);
                if (attachmentProperties.__webglTexture === void 0) {
                  attachmentProperties.__webglTexture = _gl.createTexture();
                  info.memory.textures++;
                }
              }
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            }
          } else if (isMultisample) {
            if (isWebGL2) {
              renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
              renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
              _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
              const glFormat = utils.convert(texture.format);
              const glType = utils.convert(texture.type);
              const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
              const samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
              _gl.bindRenderbuffer(36161, null);
              if (renderTarget.depthBuffer) {
                renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
              }
              state.bindFramebuffer(36160, null);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          }
        }
        if (isCube) {
          state.bindTexture(34067, textureProperties.__webglTexture);
          setTextureParameters(34067, texture, supportsMips);
          for (let i2 = 0; i2 < 6; i2++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
          }
          state.unbindTexture();
        } else if (isMultipleRenderTargets) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachment = textures[i2];
            const attachmentProperties = properties.get(attachment);
            state.bindTexture(3553, attachmentProperties.__webglTexture);
            setTextureParameters(3553, attachment, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
            if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
              generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
            }
          }
          state.unbindTexture();
        } else {
          let glTextureType = 3553;
          if (isRenderTarget3D) {
            if (isWebGL2) {
              const isTexture3D = texture.isDataTexture3D;
              glTextureType = isTexture3D ? 32879 : 35866;
            } else {
              console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
            }
          }
          state.bindTexture(glTextureType, textureProperties.__webglTexture);
          setTextureParameters(glTextureType, texture, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
          }
          state.unbindTexture();
        }
        if (renderTarget.depthBuffer) {
          setupDepthRenderbuffer(renderTarget);
        }
      }
      function updateRenderTargetMipmap(renderTarget) {
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          const texture = textures[i2];
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.unbindTexture();
          }
        }
      }
      function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
          if (isWebGL2) {
            const width = renderTarget.width;
            const height = renderTarget.height;
            let mask = 16384;
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
            const renderTargetProperties = properties.get(renderTarget);
            state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
            state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
            state.bindFramebuffer(36008, null);
            state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
      }
      function updateVideoTexture(texture) {
        const frame = info.render.frame;
        if (_videoTextures.get(texture) !== frame) {
          _videoTextures.set(texture, frame);
          texture.update();
        }
      }
      let warnedTexture2D = false;
      let warnedTextureCube = false;
      function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
          if (warnedTexture2D === false) {
            console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
            warnedTexture2D = true;
          }
          texture = texture.texture;
        }
        setTexture2D(texture, slot);
      }
      function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
          if (warnedTextureCube === false) {
            console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
            warnedTextureCube = true;
          }
          texture = texture.texture;
        }
        setTextureCube(texture, slot);
      }
      this.allocateTextureUnit = allocateTextureUnit;
      this.resetTextureUnits = resetTextureUnits;
      this.setTexture2D = setTexture2D;
      this.setTexture2DArray = setTexture2DArray;
      this.setTexture3D = setTexture3D;
      this.setTextureCube = setTextureCube;
      this.setupRenderTarget = setupRenderTarget;
      this.updateRenderTargetMipmap = updateRenderTargetMipmap;
      this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
      this.safeSetTexture2D = safeSetTexture2D;
      this.safeSetTextureCube = safeSetTextureCube;
    }
    function WebGLUtils(gl, extensions, capabilities) {
      const isWebGL2 = capabilities.isWebGL2;
      function convert(p) {
        let extension;
        if (p === UnsignedByteType)
          return 5121;
        if (p === UnsignedShort4444Type)
          return 32819;
        if (p === UnsignedShort5551Type)
          return 32820;
        if (p === UnsignedShort565Type)
          return 33635;
        if (p === ByteType)
          return 5120;
        if (p === ShortType)
          return 5122;
        if (p === UnsignedShortType)
          return 5123;
        if (p === IntType)
          return 5124;
        if (p === UnsignedIntType)
          return 5125;
        if (p === FloatType)
          return 5126;
        if (p === HalfFloatType) {
          if (isWebGL2)
            return 5131;
          extension = extensions.get("OES_texture_half_float");
          if (extension !== null) {
            return extension.HALF_FLOAT_OES;
          } else {
            return null;
          }
        }
        if (p === AlphaFormat)
          return 6406;
        if (p === RGBFormat)
          return 6407;
        if (p === RGBAFormat)
          return 6408;
        if (p === LuminanceFormat)
          return 6409;
        if (p === LuminanceAlphaFormat)
          return 6410;
        if (p === DepthFormat)
          return 6402;
        if (p === DepthStencilFormat)
          return 34041;
        if (p === RedFormat)
          return 6403;
        if (p === RedIntegerFormat)
          return 36244;
        if (p === RGFormat)
          return 33319;
        if (p === RGIntegerFormat)
          return 33320;
        if (p === RGBIntegerFormat)
          return 36248;
        if (p === RGBAIntegerFormat)
          return 36249;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
          extension = extensions.get("WEBGL_compressed_texture_pvrtc");
          if (extension !== null) {
            if (p === RGB_PVRTC_4BPPV1_Format)
              return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === RGB_PVRTC_2BPPV1_Format)
              return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === RGBA_PVRTC_4BPPV1_Format)
              return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === RGBA_PVRTC_2BPPV1_Format)
              return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else {
            return null;
          }
        }
        if (p === RGB_ETC1_Format) {
          extension = extensions.get("WEBGL_compressed_texture_etc1");
          if (extension !== null) {
            return extension.COMPRESSED_RGB_ETC1_WEBGL;
          } else {
            return null;
          }
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
          extension = extensions.get("WEBGL_compressed_texture_etc");
          if (extension !== null) {
            if (p === RGB_ETC2_Format)
              return extension.COMPRESSED_RGB8_ETC2;
            if (p === RGBA_ETC2_EAC_Format)
              return extension.COMPRESSED_RGBA8_ETC2_EAC;
          }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
          extension = extensions.get("WEBGL_compressed_texture_astc");
          if (extension !== null) {
            return p;
          } else {
            return null;
          }
        }
        if (p === RGBA_BPTC_Format) {
          extension = extensions.get("EXT_texture_compression_bptc");
          if (extension !== null) {
            return p;
          } else {
            return null;
          }
        }
        if (p === UnsignedInt248Type) {
          if (isWebGL2)
            return 34042;
          extension = extensions.get("WEBGL_depth_texture");
          if (extension !== null) {
            return extension.UNSIGNED_INT_24_8_WEBGL;
          } else {
            return null;
          }
        }
      }
      return { convert };
    }
    var ArrayCamera = class extends PerspectiveCamera {
      constructor(array = []) {
        super();
        this.cameras = array;
      }
    };
    ArrayCamera.prototype.isArrayCamera = true;
    var Group = class extends Object3D {
      constructor() {
        super();
        this.type = "Group";
      }
    };
    Group.prototype.isGroup = true;
    var _moveEvent = { type: "move" };
    var WebXRController = class {
      constructor() {
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
      }
      getHandSpace() {
        if (this._hand === null) {
          this._hand = new Group();
          this._hand.matrixAutoUpdate = false;
          this._hand.visible = false;
          this._hand.joints = {};
          this._hand.inputState = { pinching: false };
        }
        return this._hand;
      }
      getTargetRaySpace() {
        if (this._targetRay === null) {
          this._targetRay = new Group();
          this._targetRay.matrixAutoUpdate = false;
          this._targetRay.visible = false;
          this._targetRay.hasLinearVelocity = false;
          this._targetRay.linearVelocity = new Vector3();
          this._targetRay.hasAngularVelocity = false;
          this._targetRay.angularVelocity = new Vector3();
        }
        return this._targetRay;
      }
      getGripSpace() {
        if (this._grip === null) {
          this._grip = new Group();
          this._grip.matrixAutoUpdate = false;
          this._grip.visible = false;
          this._grip.hasLinearVelocity = false;
          this._grip.linearVelocity = new Vector3();
          this._grip.hasAngularVelocity = false;
          this._grip.angularVelocity = new Vector3();
        }
        return this._grip;
      }
      dispatchEvent(event2) {
        if (this._targetRay !== null) {
          this._targetRay.dispatchEvent(event2);
        }
        if (this._grip !== null) {
          this._grip.dispatchEvent(event2);
        }
        if (this._hand !== null) {
          this._hand.dispatchEvent(event2);
        }
        return this;
      }
      disconnect(inputSource) {
        this.dispatchEvent({ type: "disconnected", data: inputSource });
        if (this._targetRay !== null) {
          this._targetRay.visible = false;
        }
        if (this._grip !== null) {
          this._grip.visible = false;
        }
        if (this._hand !== null) {
          this._hand.visible = false;
        }
        return this;
      }
      update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== "visible-blurred") {
          if (targetRay !== null) {
            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (inputPose !== null) {
              targetRay.matrix.fromArray(inputPose.transform.matrix);
              targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
              if (inputPose.linearVelocity) {
                targetRay.hasLinearVelocity = true;
                targetRay.linearVelocity.copy(inputPose.linearVelocity);
              } else {
                targetRay.hasLinearVelocity = false;
              }
              if (inputPose.angularVelocity) {
                targetRay.hasAngularVelocity = true;
                targetRay.angularVelocity.copy(inputPose.angularVelocity);
              } else {
                targetRay.hasAngularVelocity = false;
              }
              this.dispatchEvent(_moveEvent);
            }
          }
          if (hand && inputSource.hand) {
            handPose = true;
            for (const inputjoint of inputSource.hand.values()) {
              const jointPose = frame.getJointPose(inputjoint, referenceSpace);
              if (hand.joints[inputjoint.jointName] === void 0) {
                const joint2 = new Group();
                joint2.matrixAutoUpdate = false;
                joint2.visible = false;
                hand.joints[inputjoint.jointName] = joint2;
                hand.add(joint2);
              }
              const joint = hand.joints[inputjoint.jointName];
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
            }
            const indexTip = hand.joints["index-finger-tip"];
            const thumbTip = hand.joints["thumb-tip"];
            const distance = indexTip.position.distanceTo(thumbTip.position);
            const distanceToPinch = 0.02;
            const threshold = 5e-3;
            if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
              hand.inputState.pinching = false;
              this.dispatchEvent({
                type: "pinchend",
                handedness: inputSource.handedness,
                target: this
              });
            } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
              hand.inputState.pinching = true;
              this.dispatchEvent({
                type: "pinchstart",
                handedness: inputSource.handedness,
                target: this
              });
            }
          } else {
            if (grip !== null && inputSource.gripSpace) {
              gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
              if (gripPose !== null) {
                grip.matrix.fromArray(gripPose.transform.matrix);
                grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                if (gripPose.linearVelocity) {
                  grip.hasLinearVelocity = true;
                  grip.linearVelocity.copy(gripPose.linearVelocity);
                } else {
                  grip.hasLinearVelocity = false;
                }
                if (gripPose.angularVelocity) {
                  grip.hasAngularVelocity = true;
                  grip.angularVelocity.copy(gripPose.angularVelocity);
                } else {
                  grip.hasAngularVelocity = false;
                }
              }
            }
          }
        }
        if (targetRay !== null) {
          targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
          grip.visible = gripPose !== null;
        }
        if (hand !== null) {
          hand.visible = handPose !== null;
        }
        return this;
      }
    };
    var WebXRManager = class extends EventDispatcher {
      constructor(renderer, gl) {
        super();
        const scope = this;
        const state = renderer.state;
        let session = null;
        let framebufferScaleFactor = 1;
        let referenceSpace = null;
        let referenceSpaceType = "local-floor";
        let pose = null;
        let glBinding = null;
        let glFramebuffer = null;
        let glProjLayer = null;
        let glBaseLayer = null;
        let isMultisample = false;
        let glMultisampledFramebuffer = null;
        let glColorRenderbuffer = null;
        let glDepthRenderbuffer = null;
        let xrFrame = null;
        let depthStyle = null;
        let clearStyle = null;
        const controllers = [];
        const inputSourcesMap = new Map();
        const cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        const cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        const cameras = [cameraL, cameraR];
        const cameraVR = new ArrayCamera();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index2) {
          let controller = controllers[index2];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index2] = controller;
          }
          return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index2) {
          let controller = controllers[index2];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index2] = controller;
          }
          return controller.getGripSpace();
        };
        this.getHand = function(index2) {
          let controller = controllers[index2];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index2] = controller;
          }
          return controller.getHandSpace();
        };
        function onSessionEvent(event2) {
          const controller = inputSourcesMap.get(event2.inputSource);
          if (controller) {
            controller.dispatchEvent({ type: event2.type, data: event2.inputSource });
          }
        }
        function onSessionEnd() {
          inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
          });
          inputSourcesMap.clear();
          _currentDepthNear = null;
          _currentDepthFar = null;
          state.bindXRFramebuffer(null);
          renderer.setRenderTarget(renderer.getRenderTarget());
          if (glFramebuffer)
            gl.deleteFramebuffer(glFramebuffer);
          if (glMultisampledFramebuffer)
            gl.deleteFramebuffer(glMultisampledFramebuffer);
          if (glColorRenderbuffer)
            gl.deleteRenderbuffer(glColorRenderbuffer);
          if (glDepthRenderbuffer)
            gl.deleteRenderbuffer(glDepthRenderbuffer);
          glFramebuffer = null;
          glMultisampledFramebuffer = null;
          glColorRenderbuffer = null;
          glDepthRenderbuffer = null;
          glBaseLayer = null;
          glProjLayer = null;
          glBinding = null;
          session = null;
          animation.stop();
          scope.isPresenting = false;
          scope.dispatchEvent({ type: "sessionend" });
        }
        this.setFramebufferScaleFactor = function(value) {
          framebufferScaleFactor = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }
        };
        this.setReferenceSpaceType = function(value) {
          referenceSpaceType = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }
        };
        this.getReferenceSpace = function() {
          return referenceSpace;
        };
        this.getBaseLayer = function() {
          return glProjLayer !== null ? glProjLayer : glBaseLayer;
        };
        this.getBinding = function() {
          return glBinding;
        };
        this.getFrame = function() {
          return xrFrame;
        };
        this.getSession = function() {
          return session;
        };
        this.setSession = function(value) {
          return __async(this, null, function* () {
            session = value;
            if (session !== null) {
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              const attributes = gl.getContextAttributes();
              if (attributes.xrCompatible !== true) {
                yield gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0) {
                const layerInit = {
                  antialias: attributes.antialias,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ baseLayer: glBaseLayer });
              } else if (gl instanceof WebGLRenderingContext) {
                const layerInit = {
                  antialias: true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ layers: [glBaseLayer] });
              } else {
                isMultisample = attributes.antialias;
                let depthFormat = null;
                if (attributes.depth) {
                  clearStyle = 256;
                  if (attributes.stencil)
                    clearStyle |= 1024;
                  depthStyle = attributes.stencil ? 33306 : 36096;
                  depthFormat = attributes.stencil ? 35056 : 33190;
                }
                const projectionlayerInit = {
                  colorFormat: attributes.alpha ? 32856 : 32849,
                  depthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                glFramebuffer = gl.createFramebuffer();
                session.updateRenderState({ layers: [glProjLayer] });
                if (isMultisample) {
                  glMultisampledFramebuffer = gl.createFramebuffer();
                  glColorRenderbuffer = gl.createRenderbuffer();
                  gl.bindRenderbuffer(36161, glColorRenderbuffer);
                  gl.renderbufferStorageMultisample(36161, 4, 32856, glProjLayer.textureWidth, glProjLayer.textureHeight);
                  state.bindFramebuffer(36160, glMultisampledFramebuffer);
                  gl.framebufferRenderbuffer(36160, 36064, 36161, glColorRenderbuffer);
                  gl.bindRenderbuffer(36161, null);
                  if (depthFormat !== null) {
                    glDepthRenderbuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(36161, glDepthRenderbuffer);
                    gl.renderbufferStorageMultisample(36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
                    gl.framebufferRenderbuffer(36160, depthStyle, 36161, glDepthRenderbuffer);
                    gl.bindRenderbuffer(36161, null);
                  }
                  state.bindFramebuffer(36160, null);
                }
              }
              referenceSpace = yield session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({ type: "sessionstart" });
            }
          });
        };
        function onInputSourcesChange(event2) {
          const inputSources = session.inputSources;
          for (let i2 = 0; i2 < controllers.length; i2++) {
            inputSourcesMap.set(inputSources[i2], controllers[i2]);
          }
          for (let i2 = 0; i2 < event2.removed.length; i2++) {
            const inputSource = event2.removed[i2];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
              controller.dispatchEvent({ type: "disconnected", data: inputSource });
              inputSourcesMap.delete(inputSource);
            }
          }
          for (let i2 = 0; i2 < event2.added.length; i2++) {
            const inputSource = event2.added[i2];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
              controller.dispatchEvent({ type: "connected", data: inputSource });
            }
          }
        }
        const cameraLPos = new Vector3();
        const cameraRPos = new Vector3();
        function setProjectionFromUnion(camera, cameraL2, cameraR2) {
          cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
          cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
          const ipd = cameraLPos.distanceTo(cameraRPos);
          const projL = cameraL2.projectionMatrix.elements;
          const projR = cameraR2.projectionMatrix.elements;
          const near = projL[14] / (projL[10] - 1);
          const far = projL[14] / (projL[10] + 1);
          const topFov = (projL[9] + 1) / projL[5];
          const bottomFov = (projL[9] - 1) / projL[5];
          const leftFov = (projL[8] - 1) / projL[0];
          const rightFov = (projR[8] + 1) / projR[0];
          const left = near * leftFov;
          const right = near * rightFov;
          const zOffset = ipd / (-leftFov + rightFov);
          const xOffset = zOffset * -leftFov;
          cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
          camera.translateX(xOffset);
          camera.translateZ(zOffset);
          camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          const near2 = near + zOffset;
          const far2 = far + zOffset;
          const left2 = left - xOffset;
          const right2 = right + (ipd - xOffset);
          const top2 = topFov * far / far2 * near2;
          const bottom2 = bottomFov * far / far2 * near2;
          camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent2) {
          if (parent2 === null) {
            camera.matrixWorld.copy(camera.matrix);
          } else {
            camera.matrixWorld.multiplyMatrices(parent2.matrixWorld, camera.matrix);
          }
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
          if (session === null)
            return;
          cameraVR.near = cameraR.near = cameraL.near = camera.near;
          cameraVR.far = cameraR.far = cameraL.far = camera.far;
          if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            session.updateRenderState({
              depthNear: cameraVR.near,
              depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
          }
          const parent2 = camera.parent;
          const cameras2 = cameraVR.cameras;
          updateCamera(cameraVR, parent2);
          for (let i2 = 0; i2 < cameras2.length; i2++) {
            updateCamera(cameras2[i2], parent2);
          }
          cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
          camera.position.copy(cameraVR.position);
          camera.quaternion.copy(cameraVR.quaternion);
          camera.scale.copy(cameraVR.scale);
          camera.matrix.copy(cameraVR.matrix);
          camera.matrixWorld.copy(cameraVR.matrixWorld);
          const children2 = camera.children;
          for (let i2 = 0, l = children2.length; i2 < l; i2++) {
            children2[i2].updateMatrixWorld(true);
          }
          if (cameras2.length === 2) {
            setProjectionFromUnion(cameraVR, cameraL, cameraR);
          } else {
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
          }
        };
        this.getCamera = function() {
          return cameraVR;
        };
        this.getFoveation = function() {
          if (glProjLayer !== null) {
            return glProjLayer.fixedFoveation;
          }
          if (glBaseLayer !== null) {
            return glBaseLayer.fixedFoveation;
          }
          return void 0;
        };
        this.setFoveation = function(foveation) {
          if (glProjLayer !== null) {
            glProjLayer.fixedFoveation = foveation;
          }
          if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
            glBaseLayer.fixedFoveation = foveation;
          }
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
          pose = frame.getViewerPose(referenceSpace);
          xrFrame = frame;
          if (pose !== null) {
            const views = pose.views;
            if (glBaseLayer !== null) {
              state.bindXRFramebuffer(glBaseLayer.framebuffer);
            }
            let cameraVRNeedsUpdate = false;
            if (views.length !== cameraVR.cameras.length) {
              cameraVR.cameras.length = 0;
              cameraVRNeedsUpdate = true;
            }
            for (let i2 = 0; i2 < views.length; i2++) {
              const view = views[i2];
              let viewport = null;
              if (glBaseLayer !== null) {
                viewport = glBaseLayer.getViewport(view);
              } else {
                const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                state.bindXRFramebuffer(glFramebuffer);
                if (glSubImage.depthStencilTexture !== void 0) {
                  gl.framebufferTexture2D(36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0);
                }
                gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
                viewport = glSubImage.viewport;
              }
              const camera = cameras[i2];
              camera.matrix.fromArray(view.transform.matrix);
              camera.projectionMatrix.fromArray(view.projectionMatrix);
              camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
              if (i2 === 0) {
                cameraVR.matrix.copy(camera.matrix);
              }
              if (cameraVRNeedsUpdate === true) {
                cameraVR.cameras.push(camera);
              }
            }
            if (isMultisample) {
              state.bindXRFramebuffer(glMultisampledFramebuffer);
              if (clearStyle !== null)
                gl.clear(clearStyle);
            }
          }
          const inputSources = session.inputSources;
          for (let i2 = 0; i2 < controllers.length; i2++) {
            const controller = controllers[i2];
            const inputSource = inputSources[i2];
            controller.update(inputSource, frame, referenceSpace);
          }
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time, frame);
          if (isMultisample) {
            const width = glProjLayer.textureWidth;
            const height = glProjLayer.textureHeight;
            state.bindFramebuffer(36008, glMultisampledFramebuffer);
            state.bindFramebuffer(36009, glFramebuffer);
            gl.invalidateFramebuffer(36008, [depthStyle]);
            gl.invalidateFramebuffer(36009, [depthStyle]);
            gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, 16384, 9728);
            gl.invalidateFramebuffer(36008, [36064]);
            state.bindFramebuffer(36008, null);
            state.bindFramebuffer(36009, null);
            state.bindFramebuffer(36160, glMultisampledFramebuffer);
          }
          xrFrame = null;
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
        };
        this.dispose = function() {
        };
      }
    };
    function WebGLMaterials(properties) {
      function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
        if (material.isMeshBasicMaterial) {
          refreshUniformsCommon(uniforms, material);
        } else if (material.isMeshLambertMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
          refreshUniformsCommon(uniforms, material);
          if (material.isMeshPhysicalMaterial) {
            refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
          } else {
            refreshUniformsStandard(uniforms, material);
          }
        } else if (material.isMeshMatcapMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
          refreshUniformsLine(uniforms, material);
          if (material.isLineDashedMaterial) {
            refreshUniformsDash(uniforms, material);
          }
        } else if (material.isPointsMaterial) {
          refreshUniformsPoints(uniforms, material, pixelRatio, height);
        } else if (material.isSpriteMaterial) {
          refreshUniformsSprites(uniforms, material);
        } else if (material.isShadowMaterial) {
          uniforms.color.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) {
          material.uniformsNeedUpdate = false;
        }
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) {
          uniforms.diffuse.value.copy(material.color);
        }
        if (material.emissive) {
          uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        }
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        if (material.specularMap) {
          uniforms.specularMap.value = material.specularMap;
        }
        if (material.alphaTest > 0) {
          uniforms.alphaTest.value = material.alphaTest;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) {
          uniforms.envMap.value = envMap;
          uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
          uniforms.reflectivity.value = material.reflectivity;
          uniforms.ior.value = material.ior;
          uniforms.refractionRatio.value = material.refractionRatio;
          const maxMipLevel = properties.get(envMap).__maxMipLevel;
          if (maxMipLevel !== void 0) {
            uniforms.maxMipLevel.value = maxMipLevel;
          }
        }
        if (material.lightMap) {
          uniforms.lightMap.value = material.lightMap;
          uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
          uniforms.aoMap.value = material.aoMap;
          uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        let uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.roughnessMap) {
          uvScaleMap = material.roughnessMap;
        } else if (material.metalnessMap) {
          uvScaleMap = material.metalnessMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        } else if (material.clearcoatMap) {
          uvScaleMap = material.clearcoatMap;
        } else if (material.clearcoatNormalMap) {
          uvScaleMap = material.clearcoatNormalMap;
        } else if (material.clearcoatRoughnessMap) {
          uvScaleMap = material.clearcoatRoughnessMap;
        } else if (material.specularIntensityMap) {
          uvScaleMap = material.specularIntensityMap;
        } else if (material.specularColorMap) {
          uvScaleMap = material.specularColorMap;
        } else if (material.transmissionMap) {
          uvScaleMap = material.transmissionMap;
        } else if (material.thicknessMap) {
          uvScaleMap = material.thicknessMap;
        } else if (material.sheenColorMap) {
          uvScaleMap = material.sheenColorMap;
        } else if (material.sheenRoughnessMap) {
          uvScaleMap = material.sheenRoughnessMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
          }
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        let uv2ScaleMap;
        if (material.aoMap) {
          uv2ScaleMap = material.aoMap;
        } else if (material.lightMap) {
          uv2ScaleMap = material.lightMap;
        }
        if (uv2ScaleMap !== void 0) {
          if (uv2ScaleMap.isWebGLRenderTarget) {
            uv2ScaleMap = uv2ScaleMap.texture;
          }
          if (uv2ScaleMap.matrixAutoUpdate === true) {
            uv2ScaleMap.updateMatrix();
          }
          uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        if (material.alphaTest > 0) {
          uniforms.alphaTest.value = material.alphaTest;
        }
        let uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        if (material.alphaTest > 0) {
          uniforms.alphaTest.value = material.alphaTest;
        }
        let uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 1e-4);
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) {
          uniforms.gradientMap.value = material.gradientMap;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) {
          uniforms.roughnessMap.value = material.roughnessMap;
        }
        if (material.metalnessMap) {
          uniforms.metalnessMap.value = material.metalnessMap;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) {
          uniforms.envMapIntensity.value = material.envMapIntensity;
        }
      }
      function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
        refreshUniformsStandard(uniforms, material);
        uniforms.ior.value = material.ior;
        if (material.sheen > 0) {
          uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
          uniforms.sheenRoughness.value = material.sheenRoughness;
          if (material.sheenColorMap) {
            uniforms.sheenColorMap.value = material.sheenColorMap;
          }
          if (material.sheenRoughnessMap) {
            uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
          }
        }
        if (material.clearcoat > 0) {
          uniforms.clearcoat.value = material.clearcoat;
          uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
          if (material.clearcoatMap) {
            uniforms.clearcoatMap.value = material.clearcoatMap;
          }
          if (material.clearcoatRoughnessMap) {
            uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
          }
          if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) {
              uniforms.clearcoatNormalScale.value.negate();
            }
          }
        }
        if (material.transmission > 0) {
          uniforms.transmission.value = material.transmission;
          uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
          uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
          if (material.transmissionMap) {
            uniforms.transmissionMap.value = material.transmissionMap;
          }
          uniforms.thickness.value = material.thickness;
          if (material.thicknessMap) {
            uniforms.thicknessMap.value = material.thicknessMap;
          }
          uniforms.attenuationDistance.value = material.attenuationDistance;
          uniforms.attenuationColor.value.copy(material.attenuationColor);
        }
        uniforms.specularIntensity.value = material.specularIntensity;
        uniforms.specularColor.value.copy(material.specularColor);
        if (material.specularIntensityMap) {
          uniforms.specularIntensityMap.value = material.specularIntensityMap;
        }
        if (material.specularColorMap) {
          uniforms.specularColorMap.value = material.specularColorMap;
        }
      }
      function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) {
          uniforms.matcap.value = material.matcap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
      }
      function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      return {
        refreshFogUniforms,
        refreshMaterialUniforms
      };
    }
    function createCanvasElement() {
      const canvas = createElementNS("canvas");
      canvas.style.display = "block";
      return canvas;
    }
    function WebGLRenderer(parameters = {}) {
      const _canvas3 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context3 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
      let currentRenderList = null;
      let currentRenderState = null;
      const renderListStack = [];
      const renderStateStack = [];
      this.domElement = _canvas3;
      this.debug = {
        checkShaderErrors: true
      };
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.clippingPlanes = [];
      this.localClippingEnabled = false;
      this.gammaFactor = 2;
      this.outputEncoding = LinearEncoding;
      this.physicallyCorrectLights = false;
      this.toneMapping = NoToneMapping;
      this.toneMappingExposure = 1;
      const _this = this;
      let _isContextLost = false;
      let _currentActiveCubeFace = 0;
      let _currentActiveMipmapLevel = 0;
      let _currentRenderTarget = null;
      let _currentMaterialId = -1;
      let _currentCamera = null;
      const _currentViewport = new Vector4();
      const _currentScissor = new Vector4();
      let _currentScissorTest = null;
      let _width = _canvas3.width;
      let _height = _canvas3.height;
      let _pixelRatio = 1;
      let _opaqueSort = null;
      let _transparentSort = null;
      const _viewport = new Vector4(0, 0, _width, _height);
      const _scissor = new Vector4(0, 0, _width, _height);
      let _scissorTest = false;
      const _currentDrawBuffers = [];
      const _frustum = new Frustum();
      let _clippingEnabled = false;
      let _localClippingEnabled = false;
      let _transmissionRenderTarget = null;
      const _projScreenMatrix2 = new Matrix4();
      const _vector3 = new Vector3();
      const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
      function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
      }
      let _gl = _context3;
      function getContext(contextNames, contextAttributes) {
        for (let i2 = 0; i2 < contextNames.length; i2++) {
          const contextName = contextNames[i2];
          const context3 = _canvas3.getContext(contextName, contextAttributes);
          if (context3 !== null)
            return context3;
        }
        return null;
      }
      try {
        const contextAttributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer,
          powerPreference: _powerPreference,
          failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        _canvas3.addEventListener("webglcontextlost", onContextLost, false);
        _canvas3.addEventListener("webglcontextrestored", onContextRestore, false);
        if (_gl === null) {
          const contextNames = ["webgl2", "webgl", "experimental-webgl"];
          if (_this.isWebGL1Renderer === true) {
            contextNames.shift();
          }
          _gl = getContext(contextNames, contextAttributes);
          if (_gl === null) {
            if (getContext(contextNames)) {
              throw new Error("Error creating WebGL context with your selected attributes.");
            } else {
              throw new Error("Error creating WebGL context.");
            }
          }
        }
        if (_gl.getShaderPrecisionFormat === void 0) {
          _gl.getShaderPrecisionFormat = function() {
            return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
          };
        }
      } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
      }
      let extensions, capabilities, state, info;
      let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
      let programCache, materials, renderLists, renderStates, clipping, shadowMap;
      let background, morphtargets, bufferRenderer, indexedBufferRenderer;
      let utils, bindingStates;
      function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        extensions.init(capabilities);
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        _currentDrawBuffers[0] = 1029;
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        cubeuvmaps = new WebGLCubeUVMaps(_this);
        attributes = new WebGLAttributes(_gl, capabilities);
        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(properties);
        renderLists = new WebGLRenderLists(properties);
        renderStates = new WebGLRenderStates(extensions, capabilities);
        background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
        shadowMap = new WebGLShadowMap(_this, objects, capabilities);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state;
        _this.info = info;
      }
      initGLContext();
      const xr = new WebXRManager(_this, _gl);
      this.xr = xr;
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.loseContext();
      };
      this.forceContextRestore = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.restoreContext();
      };
      this.getPixelRatio = function() {
        return _pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value === void 0)
          return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
      };
      this.getSize = function(target) {
        return target.set(_width, _height);
      };
      this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        _width = width;
        _height = height;
        _canvas3.width = Math.floor(width * _pixelRatio);
        _canvas3.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
          _canvas3.style.width = width + "px";
          _canvas3.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
      };
      this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
      };
      this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas3.width = Math.floor(width * pixelRatio);
        _canvas3.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
      };
      this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
      };
      this.getViewport = function(target) {
        return target.copy(_viewport);
      };
      this.setViewport = function(x, y, width, height) {
        if (x.isVector4) {
          _viewport.set(x.x, x.y, x.z, x.w);
        } else {
          _viewport.set(x, y, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissor = function(target) {
        return target.copy(_scissor);
      };
      this.setScissor = function(x, y, width, height) {
        if (x.isVector4) {
          _scissor.set(x.x, x.y, x.z, x.w);
        } else {
          _scissor.set(x, y, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissorTest = function() {
        return _scissorTest;
      };
      this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
      };
      this.setOpaqueSort = function(method) {
        _opaqueSort = method;
      };
      this.setTransparentSort = function(method) {
        _transparentSort = method;
      };
      this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
      };
      this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
      };
      this.getClearAlpha = function() {
        return background.getClearAlpha();
      };
      this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
      };
      this.clear = function(color, depth, stencil) {
        let bits = 0;
        if (color === void 0 || color)
          bits |= 16384;
        if (depth === void 0 || depth)
          bits |= 256;
        if (stencil === void 0 || stencil)
          bits |= 1024;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        this.clear(true, false, false);
      };
      this.clearDepth = function() {
        this.clear(false, true, false);
      };
      this.clearStencil = function() {
        this.clear(false, false, true);
      };
      this.dispose = function() {
        _canvas3.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas3.removeEventListener("webglcontextrestored", onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        cubeuvmaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        xr.removeEventListener("sessionstart", onXRSessionStart);
        xr.removeEventListener("sessionend", onXRSessionEnd);
        if (_transmissionRenderTarget) {
          _transmissionRenderTarget.dispose();
          _transmissionRenderTarget = null;
        }
        animation.stop();
      };
      function onContextLost(event2) {
        event2.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
      }
      function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
      }
      function onMaterialDispose(event2) {
        const material = event2.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReferences(material);
        properties.remove(material);
      }
      function releaseMaterialProgramReferences(material) {
        const programs = properties.get(material).programs;
        if (programs !== void 0) {
          programs.forEach(function(program) {
            programCache.releaseProgram(program);
          });
        }
      }
      this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null)
          scene = _emptyScene;
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, geometry, material, object);
        state.setMaterial(material, frontFaceCW);
        let index2 = geometry.index;
        const position = geometry.attributes.position;
        if (index2 === null) {
          if (position === void 0 || position.count === 0)
            return;
        } else if (index2.count === 0) {
          return;
        }
        let rangeFactor = 1;
        if (material.wireframe === true) {
          index2 = geometries.getWireframeAttribute(geometry);
          rangeFactor = 2;
        }
        bindingStates.setup(object, material, program, geometry, index2);
        let attribute;
        let renderer = bufferRenderer;
        if (index2 !== null) {
          attribute = attributes.get(index2);
          renderer = indexedBufferRenderer;
          renderer.setIndex(attribute);
        }
        const dataCount = index2 !== null ? index2.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0)
          return;
        if (object.isMesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
            renderer.setMode(1);
          } else {
            renderer.setMode(4);
          }
        } else if (object.isLine) {
          let lineWidth = material.linewidth;
          if (lineWidth === void 0)
            lineWidth = 1;
          state.setLineWidth(lineWidth * getTargetPixelRatio());
          if (object.isLineSegments) {
            renderer.setMode(1);
          } else if (object.isLineLoop) {
            renderer.setMode(2);
          } else {
            renderer.setMode(3);
          }
        } else if (object.isPoints) {
          renderer.setMode(0);
        } else if (object.isSprite) {
          renderer.setMode(4);
        }
        if (object.isInstancedMesh) {
          renderer.renderInstances(drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
          const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
          renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else {
          renderer.render(drawStart, drawCount);
        }
      };
      this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        scene.traverse(function(object) {
          const material = object.material;
          if (material) {
            if (Array.isArray(material)) {
              for (let i2 = 0; i2 < material.length; i2++) {
                const material2 = material[i2];
                getProgram(material2, scene, object);
              }
            } else {
              getProgram(material, scene, object);
            }
          }
        });
        renderStateStack.pop();
        currentRenderState = null;
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time) {
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time);
      }
      function onXRSessionStart() {
        animation.stop();
      }
      function onXRSessionEnd() {
        animation.start();
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      if (typeof window !== "undefined")
        animation.setContext(window);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
      };
      xr.addEventListener("sessionstart", onXRSessionStart);
      xr.addEventListener("sessionend", onXRSessionEnd);
      this.render = function(scene, camera) {
        if (camera !== void 0 && camera.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (_isContextLost === true)
          return;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === null)
          camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
          if (xr.cameraAutoUpdate === true)
            xr.updateCamera(camera);
          camera = xr.getCamera();
        }
        if (scene.isScene === true)
          scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix2);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, renderListStack.length);
        currentRenderList.init();
        renderListStack.push(currentRenderList);
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) {
          currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        if (_clippingEnabled === true)
          clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        if (_clippingEnabled === true)
          clipping.endShadows();
        if (this.info.autoReset === true)
          this.info.reset();
        background.render(currentRenderList, scene);
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        if (camera.isArrayCamera) {
          const cameras = camera.cameras;
          for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
            const camera2 = cameras[i2];
            renderScene(currentRenderList, scene, camera2, camera2.viewport);
          }
        } else {
          renderScene(currentRenderList, scene, camera);
        }
        if (_currentRenderTarget !== null) {
          textures.updateMultisampleRenderTarget(_currentRenderTarget);
          textures.updateRenderTargetMipmap(_currentRenderTarget);
        }
        if (scene.isScene === true)
          scene.onAfterRender(_this, scene, camera);
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) {
          currentRenderState = renderStateStack[renderStateStack.length - 1];
        } else {
          currentRenderState = null;
        }
        renderListStack.pop();
        if (renderListStack.length > 0) {
          currentRenderList = renderListStack[renderListStack.length - 1];
        } else {
          currentRenderList = null;
        }
      };
      function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false)
          return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
          } else if (object.isLOD) {
            if (object.autoUpdate === true)
              object.update(camera);
          } else if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (sortObjects) {
                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
              }
              const geometry = objects.update(object);
              const material = object.material;
              if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
              }
            }
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (object.isSkinnedMesh) {
              if (object.skeleton.frame !== info.render.frame) {
                object.skeleton.update();
                object.skeleton.frame = info.render.frame;
              }
            }
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              if (sortObjects) {
                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
              }
              const geometry = objects.update(object);
              const material = object.material;
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let i2 = 0, l = groups.length; i2 < l; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                  }
                }
              } else if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
              }
            }
          }
        }
        const children2 = object.children;
        for (let i2 = 0, l = children2.length; i2 < l; i2++) {
          projectObject(children2[i2], camera, groupOrder, sortObjects);
        }
      }
      function renderScene(currentRenderList2, scene, camera, viewport) {
        const opaqueObjects = currentRenderList2.opaque;
        const transmissiveObjects = currentRenderList2.transmissive;
        const transparentObjects = currentRenderList2.transparent;
        currentRenderState.setupLightsView(camera);
        if (transmissiveObjects.length > 0)
          renderTransmissionPass(opaqueObjects, scene, camera);
        if (viewport)
          state.viewport(_currentViewport.copy(viewport));
        if (opaqueObjects.length > 0)
          renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0)
          renderObjects(transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0)
          renderObjects(transparentObjects, scene, camera);
      }
      function renderTransmissionPass(opaqueObjects, scene, camera) {
        if (_transmissionRenderTarget === null) {
          const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
          const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
          _transmissionRenderTarget = new renderTargetType(1024, 1024, {
            generateMipmaps: true,
            type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            magFilter: NearestFilter,
            wrapS: ClampToEdgeWrapping,
            wrapT: ClampToEdgeWrapping
          });
        }
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(_transmissionRenderTarget);
        _this.clear();
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = NoToneMapping;
        renderObjects(opaqueObjects, scene, camera);
        _this.toneMapping = currentToneMapping;
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
        _this.setRenderTarget(currentRenderTarget);
      }
      function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
          const renderItem = renderList[i2];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
          const group = renderItem.group;
          if (object.layers.test(camera.layers)) {
            renderObject(object, scene, camera, geometry, material, group);
          }
        }
      }
      function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        material.onBeforeRender(_this, scene, camera, geometry, object, group);
        if (material.transparent === true && material.side === DoubleSide) {
          material.side = BackSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = FrontSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = DoubleSide;
        } else {
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        }
        object.onAfterRender(_this, scene, camera, geometry, material, group);
      }
      function getProgram(material, scene, object) {
        if (scene.isScene !== true)
          scene = _emptyScene;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters2);
        let programs = materialProperties.programs;
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
        if (programs === void 0) {
          material.addEventListener("dispose", onMaterialDispose);
          programs = new Map();
          materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== void 0) {
          if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
            updateCommonMaterialProperties(material, parameters2);
            return program;
          }
        } else {
          parameters2.uniforms = programCache.getUniforms(material);
          material.onBuild(object, parameters2, _this);
          material.onBeforeCompile(parameters2, _this);
          program = programCache.acquireProgram(parameters2, programCacheKey);
          programs.set(programCacheKey, program);
          materialProperties.uniforms = parameters2.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
          uniforms.clippingPlanes = clipping.uniform;
        }
        updateCommonMaterialProperties(material, parameters2);
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
          uniforms.ambientLightColor.value = lights.state.ambient;
          uniforms.lightProbe.value = lights.state.probe;
          uniforms.directionalLights.value = lights.state.directional;
          uniforms.directionalLightShadows.value = lights.state.directionalShadow;
          uniforms.spotLights.value = lights.state.spot;
          uniforms.spotLightShadows.value = lights.state.spotShadow;
          uniforms.rectAreaLights.value = lights.state.rectArea;
          uniforms.ltc_1.value = lights.state.rectAreaLTC1;
          uniforms.ltc_2.value = lights.state.rectAreaLTC2;
          uniforms.pointLights.value = lights.state.point;
          uniforms.pointLightShadows.value = lights.state.pointShadow;
          uniforms.hemisphereLights.value = lights.state.hemi;
          uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
          uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
          uniforms.spotShadowMap.value = lights.state.spotShadowMap;
          uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
          uniforms.pointShadowMap.value = lights.state.pointShadowMap;
          uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        const progUniforms = program.getUniforms();
        const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = uniformsList;
        return program;
      }
      function updateCommonMaterialProperties(material, parameters2) {
        const materialProperties = properties.get(material);
        materialProperties.outputEncoding = parameters2.outputEncoding;
        materialProperties.instancing = parameters2.instancing;
        materialProperties.skinning = parameters2.skinning;
        materialProperties.morphTargets = parameters2.morphTargets;
        materialProperties.morphNormals = parameters2.morphNormals;
        materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
        materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
        materialProperties.numIntersection = parameters2.numClipIntersection;
        materialProperties.vertexAlphas = parameters2.vertexAlphas;
        materialProperties.vertexTangents = parameters2.vertexTangents;
      }
      function setProgram(camera, scene, geometry, material, object) {
        if (scene.isScene !== true)
          scene = _emptyScene;
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
        const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
        const morphTargets = !!geometry.morphAttributes.position;
        const morphNormals = !!geometry.morphAttributes.normal;
        const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
          if (_localClippingEnabled === true || camera !== _currentCamera) {
            const useCache = camera === _currentCamera && material.id === _currentMaterialId;
            clipping.setState(material, camera, useCache);
          }
        }
        let needsProgramChange = false;
        if (material.version === materialProperties.__version) {
          if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            needsProgramChange = true;
          } else if (materialProperties.outputEncoding !== encoding) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancing === false) {
            needsProgramChange = true;
          } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
            needsProgramChange = true;
          } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
            needsProgramChange = true;
          } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
            needsProgramChange = true;
          } else if (materialProperties.envMap !== envMap) {
            needsProgramChange = true;
          } else if (material.fog && materialProperties.fog !== fog) {
            needsProgramChange = true;
          } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
            needsProgramChange = true;
          } else if (materialProperties.vertexAlphas !== vertexAlphas) {
            needsProgramChange = true;
          } else if (materialProperties.vertexTangents !== vertexTangents) {
            needsProgramChange = true;
          } else if (materialProperties.morphTargets !== morphTargets) {
            needsProgramChange = true;
          } else if (materialProperties.morphNormals !== morphNormals) {
            needsProgramChange = true;
          } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
            needsProgramChange = true;
          }
        } else {
          needsProgramChange = true;
          materialProperties.__version = material.version;
        }
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) {
          program = getProgram(material, scene, object);
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
          if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
          }
          if (_currentCamera !== camera) {
            _currentCamera = camera;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
            const uCamPos = p_uniforms.map.cameraPosition;
            if (uCamPos !== void 0) {
              uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
            p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
            p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
          }
        }
        if (object.isSkinnedMesh) {
          p_uniforms.setOptional(_gl, object, "bindMatrix");
          p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
          const skeleton = object.skeleton;
          if (skeleton) {
            if (capabilities.floatVertexTextures) {
              if (skeleton.boneTexture === null)
                skeleton.computeBoneTexture();
              p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
              p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
            } else {
              p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
            }
          }
        }
        if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
          morphtargets.update(object, geometry, material, program);
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
          materialProperties.receiveShadow = object.receiveShadow;
          p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (refreshMaterial) {
          p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
          if (materialProperties.needsLights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
          }
          if (fog && material.fog) {
            materials.refreshFogUniforms(m_uniforms, fog);
          }
          materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
          WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
          WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) {
          p_uniforms.setValue(_gl, "center", object.center);
        }
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
      }
      function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
      }
      this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
      };
      this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
      };
      this.getRenderTarget = function() {
        return _currentRenderTarget;
      };
      this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        }
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget) {
          const texture = renderTarget.texture;
          if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
            isRenderTarget3D = true;
          }
          const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget) {
            framebuffer = __webglFramebuffer[activeCubeFace];
            isCube = true;
          } else if (renderTarget.isWebGLMultisampleRenderTarget) {
            framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
          } else {
            framebuffer = __webglFramebuffer;
          }
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
        } else {
          _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
          _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
          _currentScissorTest = _scissorTest;
        }
        const framebufferBound = state.bindFramebuffer(36160, framebuffer);
        if (framebufferBound && capabilities.drawBuffers) {
          let needsUpdate = false;
          if (renderTarget) {
            if (renderTarget.isWebGLMultipleRenderTargets) {
              const textures2 = renderTarget.texture;
              if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
                for (let i2 = 0, il = textures2.length; i2 < il; i2++) {
                  _currentDrawBuffers[i2] = 36064 + i2;
                }
                _currentDrawBuffers.length = textures2.length;
                needsUpdate = true;
              }
            } else {
              if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
                _currentDrawBuffers[0] = 36064;
                _currentDrawBuffers.length = 1;
                needsUpdate = true;
              }
            }
          } else {
            if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
              _currentDrawBuffers[0] = 1029;
              _currentDrawBuffers.length = 1;
              needsUpdate = true;
            }
          }
          if (needsUpdate) {
            if (capabilities.isWebGL2) {
              _gl.drawBuffers(_currentDrawBuffers);
            } else {
              extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
            }
          }
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
          const textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
          const textureProperties = properties.get(renderTarget.texture);
          const layer = activeCubeFace || 0;
          _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
        _currentMaterialId = -1;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          state.bindFramebuffer(36160, framebuffer);
          try {
            const texture = renderTarget.texture;
            const textureFormat = texture.format;
            const textureType = texture.type;
            if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
            if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            if (_gl.checkFramebufferStatus(36160) === 36053) {
              if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
              }
            } else {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            }
          } finally {
            const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
            state.bindFramebuffer(36160, framebuffer2);
          }
        }
      };
      this.copyFramebufferToTexture = function(position, texture, level = 0) {
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        let glFormat = utils.convert(texture.format);
        if (capabilities.isWebGL2) {
          if (glFormat === 6407)
            glFormat = 32849;
          if (glFormat === 6408)
            glFormat = 32856;
        }
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
      };
      this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
        const width = srcTexture.image.width;
        const height = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) {
          _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        } else {
          if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
          } else {
            _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
          }
        }
        if (level === 0 && dstTexture.generateMipmaps)
          _gl.generateMipmap(3553);
        state.unbindTexture();
      };
      this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
        if (_this.isWebGL1Renderer) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          return;
        }
        const width = sourceBox.max.x - sourceBox.min.x + 1;
        const height = sourceBox.max.y - sourceBox.min.y + 1;
        const depth = sourceBox.max.z - sourceBox.min.z + 1;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isDataTexture3D) {
          textures.setTexture3D(dstTexture, 0);
          glTarget = 32879;
        } else if (dstTexture.isDataTexture2DArray) {
          textures.setTexture2DArray(dstTexture, 0);
          glTarget = 35866;
        } else {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          return;
        }
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        const unpackRowLen = _gl.getParameter(3314);
        const unpackImageHeight = _gl.getParameter(32878);
        const unpackSkipPixels = _gl.getParameter(3316);
        const unpackSkipRows = _gl.getParameter(3315);
        const unpackSkipImages = _gl.getParameter(32877);
        const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
        _gl.pixelStorei(3314, image.width);
        _gl.pixelStorei(32878, image.height);
        _gl.pixelStorei(3316, sourceBox.min.x);
        _gl.pixelStorei(3315, sourceBox.min.y);
        _gl.pixelStorei(32877, sourceBox.min.z);
        if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
        } else {
          if (srcTexture.isCompressedTexture) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
            _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
          } else {
            _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
          }
        }
        _gl.pixelStorei(3314, unpackRowLen);
        _gl.pixelStorei(32878, unpackImageHeight);
        _gl.pixelStorei(3316, unpackSkipPixels);
        _gl.pixelStorei(3315, unpackSkipRows);
        _gl.pixelStorei(32877, unpackSkipImages);
        if (level === 0 && dstTexture.generateMipmaps)
          _gl.generateMipmap(glTarget);
        state.unbindTexture();
      };
      this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
      };
      this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state.reset();
        bindingStates.reset();
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    WebGLRenderer.prototype.isWebGLRenderer = true;
    var WebGL1Renderer = class extends WebGLRenderer {
    };
    WebGL1Renderer.prototype.isWebGL1Renderer = true;
    var FogExp2 = class {
      constructor(color, density = 25e-5) {
        this.name = "";
        this.color = new Color(color);
        this.density = density;
      }
      clone() {
        return new FogExp2(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      }
    };
    FogExp2.prototype.isFogExp2 = true;
    var Fog = class {
      constructor(color, near = 1, far = 1e3) {
        this.name = "";
        this.color = new Color(color);
        this.near = near;
        this.far = far;
      }
      clone() {
        return new Fog(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    };
    Fog.prototype.isFog = true;
    var Scene = class extends Object3D {
      constructor() {
        super();
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      }
    };
    Scene.prototype.isScene = true;
    var InterleavedBuffer = class {
      constructor(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = array !== void 0 ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
        this.uuid = generateUUID();
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (let i2 = 0, l = this.stride; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      set(value, offset2 = 0) {
        this.array.set(value, offset2);
        return this;
      }
      clone(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      toJSON(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    };
    InterleavedBuffer.prototype.isInterleavedBuffer = true;
    var _vector$6 = /* @__PURE__ */ new Vector3();
    var InterleavedBufferAttribute = class {
      constructor(interleavedBuffer, itemSize, offset2, normalized = false) {
        this.name = "";
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset2;
        this.normalized = normalized === true;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(value) {
        this.data.needsUpdate = value;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
          _vector$6.x = this.getX(i2);
          _vector$6.y = this.getY(i2);
          _vector$6.z = this.getZ(i2);
          _vector$6.applyMatrix4(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$6.x = this.getX(i2);
          _vector$6.y = this.getY(i2);
          _vector$6.z = this.getZ(i2);
          _vector$6.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$6.x = this.getX(i2);
          _vector$6.y = this.getY(i2);
          _vector$6.z = this.getZ(i2);
          _vector$6.transformDirection(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      setX(index2, x) {
        this.data.array[index2 * this.data.stride + this.offset] = x;
        return this;
      }
      setY(index2, y) {
        this.data.array[index2 * this.data.stride + this.offset + 1] = y;
        return this;
      }
      setZ(index2, z) {
        this.data.array[index2 * this.data.stride + this.offset + 2] = z;
        return this;
      }
      setW(index2, w) {
        this.data.array[index2 * this.data.stride + this.offset + 3] = w;
        return this;
      }
      getX(index2) {
        return this.data.array[index2 * this.data.stride + this.offset];
      }
      getY(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 1];
      }
      getZ(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 2];
      }
      getW(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 3];
      }
      setXY(index2, x, y) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y;
        return this;
      }
      setXYZ(index2, x, y, z) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y;
        this.data.array[index2 + 2] = z;
        return this;
      }
      setXYZW(index2, x, y, z, w) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y;
        this.data.array[index2 + 2] = z;
        this.data.array[index2 + 3] = w;
        return this;
      }
      clone(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index2 = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index2 + j]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      }
      toJSON(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index2 = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index2 + j]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    };
    InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
    var SpriteMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "SpriteMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
      }
    };
    SpriteMaterial.prototype.isSpriteMaterial = true;
    var _geometry;
    var _intersectPoint = /* @__PURE__ */ new Vector3();
    var _worldScale = /* @__PURE__ */ new Vector3();
    var _mvPosition = /* @__PURE__ */ new Vector3();
    var _alignedPosition = /* @__PURE__ */ new Vector2();
    var _rotatedPosition = /* @__PURE__ */ new Vector2();
    var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
    var _vA = /* @__PURE__ */ new Vector3();
    var _vB = /* @__PURE__ */ new Vector3();
    var _vC = /* @__PURE__ */ new Vector3();
    var _uvA = /* @__PURE__ */ new Vector2();
    var _uvB = /* @__PURE__ */ new Vector2();
    var _uvC = /* @__PURE__ */ new Vector2();
    var Sprite = class extends Object3D {
      constructor(material) {
        super();
        this.type = "Sprite";
        if (_geometry === void 0) {
          _geometry = new BufferGeometry();
          const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
          ]);
          const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
          _geometry.setIndex([0, 1, 2, 0, 2, 3]);
          _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
          _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = material !== void 0 ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
      }
      raycast(raycaster, intersects2) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);
        let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect === null) {
          transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
          face: null,
          object: this
        });
      }
      copy(source) {
        super.copy(source);
        if (source.center !== void 0)
          this.center.copy(source.center);
        this.material = source.material;
        return this;
      }
    };
    Sprite.prototype.isSprite = true;
    function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
      _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
      if (sin !== void 0) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
      } else {
        _rotatedPosition.copy(_alignedPosition);
      }
      vertexPosition.copy(mvPosition);
      vertexPosition.x += _rotatedPosition.x;
      vertexPosition.y += _rotatedPosition.y;
      vertexPosition.applyMatrix4(_viewWorldMatrix);
    }
    var _basePosition = /* @__PURE__ */ new Vector3();
    var _skinIndex = /* @__PURE__ */ new Vector4();
    var _skinWeight = /* @__PURE__ */ new Vector4();
    var _vector$5 = /* @__PURE__ */ new Vector3();
    var _matrix = /* @__PURE__ */ new Matrix4();
    var SkinnedMesh = class extends Mesh {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
      }
      copy(source) {
        super.copy(source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
      }
      bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
          vector.x = skinWeight.getX(i2);
          vector.y = skinWeight.getY(i2);
          vector.z = skinWeight.getZ(i2);
          vector.w = skinWeight.getW(i2);
          const scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === "attached") {
          this.bindMatrixInverse.copy(this.matrixWorld).invert();
        } else if (this.bindMode === "detached") {
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      }
      boneTransform(index2, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
        _basePosition.copy(target).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for (let i2 = 0; i2 < 4; i2++) {
          const weight = _skinWeight.getComponent(i2);
          if (weight !== 0) {
            const boneIndex = _skinIndex.getComponent(i2);
            _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
          }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
      }
    };
    SkinnedMesh.prototype.isSkinnedMesh = true;
    var Bone = class extends Object3D {
      constructor() {
        super();
        this.type = "Bone";
      }
    };
    Bone.prototype.isBone = true;
    var DataTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { data, width, height };
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
      }
    };
    DataTexture.prototype.isDataTexture = true;
    var InstancedBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized, meshPerAttribute = 1) {
        if (typeof normalized === "number") {
          meshPerAttribute = normalized;
          normalized = false;
          console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
        }
        super(array, itemSize, normalized);
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    };
    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
    var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
    var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
    var _instanceIntersects = [];
    var _mesh = /* @__PURE__ */ new Mesh();
    var InstancedMesh = class extends Mesh {
      constructor(geometry, material, count) {
        super(geometry, material);
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.count = count;
        this.frustumCulled = false;
      }
      copy(source) {
        super.copy(source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null)
          this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
      }
      getColorAt(index2, color) {
        color.fromArray(this.instanceColor.array, index2 * 3);
      }
      getMatrixAt(index2, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index2 * 16);
      }
      raycast(raycaster, intersects2) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === void 0)
          return;
        for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
          _mesh.matrixWorld = _instanceWorldMatrix;
          _mesh.raycast(raycaster, _instanceIntersects);
          for (let i2 = 0, l = _instanceIntersects.length; i2 < l; i2++) {
            const intersect = _instanceIntersects[i2];
            intersect.instanceId = instanceId;
            intersect.object = this;
            intersects2.push(intersect);
          }
          _instanceIntersects.length = 0;
        }
      }
      setColorAt(index2, color) {
        if (this.instanceColor === null) {
          this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
        }
        color.toArray(this.instanceColor.array, index2 * 3);
      }
      setMatrixAt(index2, matrix) {
        matrix.toArray(this.instanceMatrix.array, index2 * 16);
      }
      updateMorphTargets() {
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    InstancedMesh.prototype.isInstancedMesh = true;
    var LineBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "LineBasicMaterial";
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.linecap = "round";
        this.linejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
      }
    };
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    var _start$1 = /* @__PURE__ */ new Vector3();
    var _end$1 = /* @__PURE__ */ new Vector3();
    var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
    var _ray$1 = /* @__PURE__ */ new Ray();
    var _sphere$1 = /* @__PURE__ */ new Sphere();
    var Line = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
        super();
        this.type = "Line";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [0];
            for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
              _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
              _end$1.fromBufferAttribute(positionAttribute, i2);
              lineDistances[i2] = lineDistances[i2 - 1];
              lineDistances[i2] += _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false)
          return;
        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
          const index2 = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index2 !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index2.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
              const a = index2.getX(i2);
              const b = index2.getX(i2 + 1);
              vStart.fromBufferAttribute(positionAttribute, a);
              vEnd.fromBufferAttribute(positionAttribute, b);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
              vStart.fromBufferAttribute(positionAttribute, i2);
              vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    };
    Line.prototype.isLine = true;
    var _start = /* @__PURE__ */ new Vector3();
    var _end = /* @__PURE__ */ new Vector3();
    var LineSegments = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "LineSegments";
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
              _start.fromBufferAttribute(positionAttribute, i2);
              _end.fromBufferAttribute(positionAttribute, i2 + 1);
              lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
              lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      }
    };
    LineSegments.prototype.isLineSegments = true;
    var LineLoop = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "LineLoop";
      }
    };
    LineLoop.prototype.isLineLoop = true;
    var PointsMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "PointsMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
      }
    };
    PointsMaterial.prototype.isPointsMaterial = true;
    var _inverseMatrix = /* @__PURE__ */ new Matrix4();
    var _ray = /* @__PURE__ */ new Ray();
    var _sphere = /* @__PURE__ */ new Sphere();
    var _position$2 = /* @__PURE__ */ new Vector3();
    var Points = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
        super();
        this.type = "Points";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false)
          return;
        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
          const index2 = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index2 !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index2.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2++) {
              const a = index2.getX(i2);
              _position$2.fromBufferAttribute(positionAttribute, a);
              testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end; i2 < l; i2++) {
              _position$2.fromBufferAttribute(positionAttribute, i2);
              testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          }
        } else {
          console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    };
    Points.prototype.isPoints = true;
    function testPoint(point, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
      const rayPointDistanceSq = _ray.distanceSqToPoint(point);
      if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector3();
        _ray.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          distanceToRay: Math.sqrt(rayPointDistanceSq),
          point: intersectPoint,
          index: index2,
          face: null,
          object
        });
      }
    }
    var VideoTexture = class extends Texture {
      constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.format = format !== void 0 ? format : RGBFormat;
        this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
        this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
          scope.needsUpdate = true;
          video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) {
          video.requestVideoFrameCallback(updateVideo);
        }
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    };
    VideoTexture.prototype.isVideoTexture = true;
    var CompressedTexture = class extends Texture {
      constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { width, height };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    CompressedTexture.prototype.isCompressedTexture = true;
    var CanvasTexture = class extends Texture {
      constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
      }
    };
    CanvasTexture.prototype.isCanvasTexture = true;
    var DepthTexture = class extends Texture {
      constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== void 0 ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
          throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        }
        if (type === void 0 && format === DepthFormat)
          type = UnsignedShortType;
        if (type === void 0 && format === DepthStencilFormat)
          type = UnsignedInt248Type;
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = { width, height };
        this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
        this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    DepthTexture.prototype.isDepthTexture = true;
    var _v0 = new Vector3();
    var _v1$1 = new Vector3();
    var _normal = new Vector3();
    var _triangle = new Triangle();
    var Curve = class {
      constructor() {
        this.type = "Curve";
        this.arcLengthDivisions = 200;
      }
      getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      }
      getPointAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
      }
      getPoints(divisions = 5) {
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPoint(d / divisions));
        }
        return points;
      }
      getSpacedPoints(divisions = 5) {
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPointAt(d / divisions));
        }
        return points;
      }
      getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
      }
      getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for (let p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      }
      updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
      }
      getUtoTmapping(u, distance) {
        const arcLengths = this.getLengths();
        let i2 = 0;
        const il = arcLengths.length;
        let targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        let low = 0, high = il - 1, comparison;
        while (low <= high) {
          i2 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i2] - targetArcLength;
          if (comparison < 0) {
            low = i2 + 1;
          } else if (comparison > 0) {
            high = i2 - 1;
          } else {
            high = i2;
            break;
          }
        }
        i2 = high;
        if (arcLengths[i2] === targetArcLength) {
          return i2 / (il - 1);
        }
        const lengthBefore = arcLengths[i2];
        const lengthAfter = arcLengths[i2 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t = (i2 + segmentFraction) / (il - 1);
        return t;
      }
      getTangent(t, optionalTarget) {
        const delta = 1e-4;
        let t1 = t - delta;
        let t2 = t + delta;
        if (t1 < 0)
          t1 = 0;
        if (t2 > 1)
          t2 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      }
      getTangentAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
      }
      computeFrenetFrames(segments, closed) {
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        for (let i2 = 0; i2 <= segments; i2++) {
          const u = i2 / segments;
          tangents[i2] = this.getTangentAt(u, new Vector3());
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (let i2 = 1; i2 <= segments; i2++) {
          normals[i2] = normals[i2 - 1].clone();
          binormals[i2] = binormals[i2 - 1].clone();
          vec.crossVectors(tangents[i2 - 1], tangents[i2]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            const theta = Math.acos(clamp4(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
            normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[i2].crossVectors(tangents[i2], normals[i2]);
        }
        if (closed === true) {
          let theta = Math.acos(clamp4(normals[0].dot(normals[segments]), -1, 1));
          theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            theta = -theta;
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      }
      fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    };
    var EllipseCurve = class extends Curve {
      constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
        super();
        this.type = "EllipseCurve";
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
      }
      getPoint(t, optionalTarget) {
        const point = optionalTarget || new Vector2();
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0)
          deltaAngle += twoPi;
        while (deltaAngle > twoPi)
          deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
          if (samePoints) {
            deltaAngle = 0;
          } else {
            deltaAngle = twoPi;
          }
        }
        if (this.aClockwise === true && !samePoints) {
          if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
          } else {
            deltaAngle = deltaAngle - twoPi;
          }
        }
        const angle = this.aStartAngle + t * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos(angle);
        let y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
          const cos = Math.cos(this.aRotation);
          const sin = Math.sin(this.aRotation);
          const tx = x - this.aX;
          const ty = y - this.aY;
          x = tx * cos - ty * sin + this.aX;
          y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
      }
      copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
      }
    };
    EllipseCurve.prototype.isEllipseCurve = true;
    var ArcCurve = class extends EllipseCurve {
      constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = "ArcCurve";
      }
    };
    ArcCurve.prototype.isArcCurve = true;
    function CubicPoly() {
      let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
      function init6(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
      }
      return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
          init6(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
          let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
          let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
          t1 *= dt1;
          t2 *= dt1;
          init6(x1, x2, t1, t2);
        },
        calc: function(t) {
          const t2 = t * t;
          const t3 = t2 * t;
          return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
      };
    }
    var tmp = new Vector3();
    var px = new CubicPoly();
    var py = new CubicPoly();
    var pz = new CubicPoly();
    var CatmullRomCurve3 = class extends Curve {
      constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
        super();
        this.type = "CatmullRomCurve3";
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const points = this.points;
        const l = points.length;
        const p = (l - (this.closed ? 0 : 1)) * t;
        let intPoint = Math.floor(p);
        let weight = p - intPoint;
        if (this.closed) {
          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        } else if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        let p0, p3;
        if (this.closed || intPoint > 0) {
          p0 = points[(intPoint - 1) % l];
        } else {
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        }
        const p1 = points[intPoint % l];
        const p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
          p3 = points[(intPoint + 2) % l];
        } else {
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
          p3 = tmp;
        }
        if (this.curveType === "centripetal" || this.curveType === "chordal") {
          const pow = this.curveType === "chordal" ? 0.5 : 0.25;
          let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
          if (dt1 < 1e-4)
            dt1 = 1;
          if (dt0 < 1e-4)
            dt0 = dt1;
          if (dt2 < 1e-4)
            dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === "catmullrom") {
          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
      }
    };
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    function CatmullRom(t, p0, p1, p2, p3) {
      const v0 = (p2 - p0) * 0.5;
      const v1 = (p3 - p1) * 0.5;
      const t2 = t * t;
      const t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
      const k = 1 - t;
      return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
      return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
      return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
      return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
      const k = 1 - t;
      return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
      const k = 1 - t;
      return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
      return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
      return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
      return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    var CubicBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
        super();
        this.type = "CubicBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    var CubicBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
        super();
        this.type = "CubicBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    var LineCurve = class extends Curve {
      constructor(v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.type = "LineCurve";
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      }
      getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
      getTangent(t, optionalTarget) {
        const tangent = optionalTarget || new Vector2();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    LineCurve.prototype.isLineCurve = true;
    var LineCurve3 = class extends Curve {
      constructor(v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.type = "LineCurve3";
        this.isLineCurve3 = true;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      }
      getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    var QuadraticBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.type = "QuadraticBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    var QuadraticBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.type = "QuadraticBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    var SplineCurve = class extends Curve {
      constructor(points = []) {
        super();
        this.type = "SplineCurve";
        this.points = points;
      }
      getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const points = this.points;
        const p = (points.length - 1) * t;
        const intPoint = Math.floor(p);
        const weight = p - intPoint;
        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        const p1 = points[intPoint];
        const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector2().fromArray(point));
        }
        return this;
      }
    };
    SplineCurve.prototype.isSplineCurve = true;
    var Curves = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArcCurve,
      CatmullRomCurve3,
      CubicBezierCurve,
      CubicBezierCurve3,
      EllipseCurve,
      LineCurve,
      LineCurve3,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      SplineCurve
    });
    var CurvePath = class extends Curve {
      constructor() {
        super();
        this.type = "CurvePath";
        this.curves = [];
        this.autoClose = false;
      }
      add(curve) {
        this.curves.push(curve);
      }
      closePath() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          this.curves.push(new LineCurve(endPoint, startPoint));
        }
      }
      getPoint(t, optionalTarget) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i2 = 0;
        while (i2 < curveLengths.length) {
          if (curveLengths[i2] >= d) {
            const diff = curveLengths[i2] - d;
            const curve = this.curves[i2];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u, optionalTarget);
          }
          i2++;
        }
        return null;
      }
      getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
      }
      updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        const lengths = [];
        let sums = 0;
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          sums += this.curves[i2].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      }
      getSpacedPoints(divisions = 40) {
        const points = [];
        for (let i2 = 0; i2 <= divisions; i2++) {
          points.push(this.getPoint(i2 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      }
      getPoints(divisions = 12) {
        const points = [];
        let last;
        for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
          const curve = curves[i2];
          const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
          const pts = curve.getPoints(resolution);
          for (let j = 0; j < pts.length; j++) {
            const point = pts[j];
            if (last && last.equals(point))
              continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      }
      copy(source) {
        super.copy(source);
        this.curves = [];
        for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
          const curve = source.curves[i2];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.autoClose = this.autoClose;
        data.curves = [];
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          const curve = this.curves[i2];
          data.curves.push(curve.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
          const curve = json.curves[i2];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    };
    var Path = class extends CurvePath {
      constructor(points) {
        super();
        this.type = "Path";
        this.currentPoint = new Vector2();
        if (points) {
          this.setFromPoints(points);
        }
      }
      setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for (let i2 = 1, l = points.length; i2 < l; i2++) {
          this.lineTo(points[i2].x, points[i2].y);
        }
        return this;
      }
      moveTo(x, y) {
        this.currentPoint.set(x, y);
        return this;
      }
      lineTo(x, y) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      splineThru(pts) {
        const npts = [this.currentPoint.clone()].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      }
      arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
      absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
      ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      }
      absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          const firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      }
      copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.currentPoint = this.currentPoint.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    };
    var Shape = class extends Path {
      constructor(points) {
        super(points);
        this.uuid = generateUUID();
        this.type = "Shape";
        this.holes = [];
      }
      getPointsHoles(divisions) {
        const holesPts = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          holesPts[i2] = this.holes[i2].getPoints(divisions);
        }
        return holesPts;
      }
      extractPoints(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      }
      copy(source) {
        super.copy(source);
        this.holes = [];
        for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
          const hole = source.holes[i2];
          this.holes.push(hole.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.uuid = this.uuid;
        data.holes = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          const hole = this.holes[i2];
          data.holes.push(hole.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
          const hole = json.holes[i2];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    };
    var Earcut = {
      triangulate: function(data, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (let i2 = dim; i2 < outerLen; i2 += dim) {
            x = data[i2];
            y = data[i2 + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
    };
    function linkedList(data, start, end, dim, clockwise) {
      let i2, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      let p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      let stop = ear, prev2, next2;
      while (ear.prev !== ear.next) {
        prev2 = ear.prev;
        next2 = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev2.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next2.i / dim);
          removeNode(ear);
          ear = next2.next;
          stop = next2.next;
          continue;
        }
        ear = next2;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      const a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      let p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      const a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      let p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      let p = start;
      do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      let a = start;
      do {
        let b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            let c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize);
            earcutLinked(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      const queue = [];
      let i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        eliminateHole(queue[i2], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      let p = outerNode;
      const hx = hole.x;
      const hy = hole.y;
      let qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y)
                return p;
              if (hy === p.next.y)
                return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      if (hx === qx)
        return m;
      const stop = m, mx = m.x, my = m.y;
      let tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      let p = start;
      do {
        if (p.z === null)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      let i2, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      let p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
      return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      const o1 = sign(area(p1, q1, p2));
      const o2 = sign(area(p1, q1, q2));
      const o3 = sign(area(p2, q2, p1));
      const o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      let p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      let p = a, inside = false;
      const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
      do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i2, x, y, last) {
      const p = new Node(i2, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i2, x, y) {
      this.i = i2;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
      let sum = 0;
      for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
        sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
        j = i2;
      }
      return sum;
    }
    var ShapeUtils = class {
      static area(contour) {
        const n = contour.length;
        let a = 0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      }
      static isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
      }
      static triangulateShape(contour, holes) {
        const vertices = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i2 = 0; i2 < holes.length; i2++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i2].length;
          addContour(vertices, holes[i2]);
        }
        const triangles = Earcut.triangulate(vertices, holeIndices);
        for (let i2 = 0; i2 < triangles.length; i2 += 3) {
          faces.push(triangles.slice(i2, i2 + 3));
        }
        return faces;
      }
    };
    function removeDupEndPts(points) {
      const l = points.length;
      if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
      }
    }
    function addContour(vertices, contour) {
      for (let i2 = 0; i2 < contour.length; i2++) {
        vertices.push(contour[i2].x);
        vertices.push(contour[i2].y);
      }
    }
    var ExtrudeGeometry = class extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
        super();
        this.type = "ExtrudeGeometry";
        this.parameters = {
          shapes,
          options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
          const shape = shapes[i2];
          addShape(shape);
        }
        this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        function addShape(shape) {
          const placeholder = [];
          const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
          const steps = options.steps !== void 0 ? options.steps : 1;
          let depth = options.depth !== void 0 ? options.depth : 1;
          let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
          let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
          let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
          let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
          let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
          const extrudePath = options.extrudePath;
          const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
          if (options.amount !== void 0) {
            console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
            depth = options.amount;
          }
          let extrudePts, extrudeByPath = false;
          let splineTube, binormal, normal, position2;
          if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
          }
          if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
            bevelOffset = 0;
          }
          const shapePoints = shape.extractPoints(curveSegments);
          let vertices = shapePoints.shape;
          const holes = shapePoints.holes;
          const reverse = !ShapeUtils.isClockWise(vertices);
          if (reverse) {
            vertices = vertices.reverse();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              if (ShapeUtils.isClockWise(ahole)) {
                holes[h] = ahole.reverse();
              }
            }
          }
          const faces = ShapeUtils.triangulateShape(vertices, holes);
          const contour = vertices;
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            vertices = vertices.concat(ahole);
          }
          function scalePt2(pt, vec, size) {
            if (!vec)
              console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
          }
          const vlen = vertices.length, flen = faces.length;
          function getBevelVec(inPt, inPrev, inNext) {
            let v_trans_x, v_trans_y, shrink_by;
            const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
              const v_prev_len = Math.sqrt(v_prev_lensq);
              const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
              const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
              const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
              const ptNextShift_x = inNext.x - v_next_y / v_next_len;
              const ptNextShift_y = inNext.y + v_next_x / v_next_len;
              const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
              v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
              v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
              const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
              if (v_trans_lensq <= 2) {
                return new Vector2(v_trans_x, v_trans_y);
              } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
              }
            } else {
              let direction_eq = false;
              if (v_prev_x > Number.EPSILON) {
                if (v_next_x > Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (v_prev_x < -Number.EPSILON) {
                  if (v_next_x < -Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                    direction_eq = true;
                  }
                }
              }
              if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
              } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
              }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
          }
          const contourMovements = [];
          for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
          }
          const holesMovements = [];
          let oneHoleMovements, verticesMovements = contourMovements.concat();
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = [];
            for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
          }
          for (let b = 0; b < bevelSegments; b++) {
            const t = b / bevelSegments;
            const z = bevelThickness * Math.cos(t * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v(vert.x, vert.y, -z);
            }
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = holesMovements[h];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                v(vert.x, vert.y, -z);
              }
            }
          }
          const bs = bevelSize + bevelOffset;
          for (let i2 = 0; i2 < vlen; i2++) {
            const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
            if (!extrudeByPath) {
              v(vert.x, vert.y, 0);
            } else {
              normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
              position2.copy(extrudePts[0]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
          for (let s = 1; s <= steps; s++) {
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth / steps * s);
              } else {
                normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
          }
          for (let b = bevelSegments - 1; b >= 0; b--) {
            const t = b / bevelSegments;
            const z = bevelThickness * Math.cos(t * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v(vert.x, vert.y, depth + z);
            }
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = holesMovements[h];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth + z);
                } else {
                  v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
              }
            }
          }
          buildLidFaces();
          buildSideFaces();
          function buildLidFaces() {
            const start = verticesArray.length / 3;
            if (bevelEnabled) {
              let layer = 0;
              let offset2 = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[2] + offset2, face[1] + offset2, face[0] + offset2);
              }
              layer = steps + bevelSegments * 2;
              offset2 = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[0] + offset2, face[1] + offset2, face[2] + offset2);
              }
            } else {
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[2], face[1], face[0]);
              }
              for (let i2 = 0; i2 < flen; i2++) {
                const face = faces[i2];
                f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
              }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
          }
          function buildSideFaces() {
            const start = verticesArray.length / 3;
            let layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              sidewalls(ahole, layeroffset);
              layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
          }
          function sidewalls(contour2, layeroffset) {
            let i2 = contour2.length;
            while (--i2 >= 0) {
              const j = i2;
              let k = i2 - 1;
              if (k < 0)
                k = contour2.length - 1;
              for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                const slen1 = vlen * s;
                const slen2 = vlen * (s + 1);
                const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                f4(a, b, c, d);
              }
            }
          }
          function v(x, y, z) {
            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z);
          }
          function f3(a, b, c) {
            addVertex(a);
            addVertex(b);
            addVertex(c);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
          }
          function f4(a, b, c, d) {
            addVertex(a);
            addVertex(b);
            addVertex(d);
            addVertex(b);
            addVertex(c);
            addVertex(d);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
          }
          function addVertex(index2) {
            verticesArray.push(placeholder[index2 * 3 + 0]);
            verticesArray.push(placeholder[index2 * 3 + 1]);
            verticesArray.push(placeholder[index2 * 3 + 2]);
          }
          function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
          }
        }
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON$1(shapes, options, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
          const shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== void 0) {
          data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
        }
        return new ExtrudeGeometry(geometryShapes, data.options);
      }
    };
    var WorldUVGenerator = {
      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
          new Vector2(a_x, a_y),
          new Vector2(b_x, b_y),
          new Vector2(c_x, c_y)
        ];
      },
      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
          return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
          ];
        } else {
          return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
          ];
        }
      }
    };
    function toJSON$1(shapes, options, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
          const shape = shapes[i2];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      if (options.extrudePath !== void 0)
        data.options.extrudePath = options.extrudePath.toJSON();
      return data;
    }
    var ShapeGeometry = class extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
        super();
        this.type = "ShapeGeometry";
        this.parameters = {
          shapes,
          curveSegments
        };
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let groupStart = 0;
        let groupCount = 0;
        if (Array.isArray(shapes) === false) {
          addShape(shapes);
        } else {
          for (let i2 = 0; i2 < shapes.length; i2++) {
            addShape(shapes[i2]);
            this.addGroup(groupStart, groupCount, i2);
            groupStart += groupCount;
            groupCount = 0;
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
          const indexOffset = vertices.length / 3;
          const points = shape.extractPoints(curveSegments);
          let shapeVertices = points.shape;
          const shapeHoles = points.holes;
          if (ShapeUtils.isClockWise(shapeVertices) === false) {
            shapeVertices = shapeVertices.reverse();
          }
          for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
            const shapeHole = shapeHoles[i2];
            if (ShapeUtils.isClockWise(shapeHole) === true) {
              shapeHoles[i2] = shapeHole.reverse();
            }
          }
          const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
          for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
            const shapeHole = shapeHoles[i2];
            shapeVertices = shapeVertices.concat(shapeHole);
          }
          for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
            const vertex2 = shapeVertices[i2];
            vertices.push(vertex2.x, vertex2.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex2.x, vertex2.y);
          }
          for (let i2 = 0, l = faces.length; i2 < l; i2++) {
            const face = faces[i2];
            const a = face[0] + indexOffset;
            const b = face[1] + indexOffset;
            const c = face[2] + indexOffset;
            indices.push(a, b, c);
            groupCount += 3;
          }
        }
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        return toJSON(shapes, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
          const shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        return new ShapeGeometry(geometryShapes, data.curveSegments);
      }
    };
    function toJSON(shapes, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
          const shape = shapes[i2];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      return data;
    }
    var ShadowMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "ShadowMaterial";
        this.color = new Color(0);
        this.transparent = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        return this;
      }
    };
    ShadowMaterial.prototype.isShadowMaterial = true;
    var MeshStandardMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "STANDARD": "" };
        this.type = "MeshStandardMaterial";
        this.color = new Color(16777215);
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "STANDARD": "" };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    var MeshPhysicalMaterial = class extends MeshStandardMaterial {
      constructor(parameters) {
        super();
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.type = "MeshPhysicalMaterial";
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.ior = 1.5;
        Object.defineProperty(this, "reflectivity", {
          get: function() {
            return clamp4(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function(reflectivity) {
            this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
          }
        });
        this.sheenColor = new Color(0);
        this.sheenColorMap = null;
        this.sheenRoughness = 1;
        this.sheenRoughnessMap = null;
        this.transmissionMap = null;
        this.thickness = 0.01;
        this.thicknessMap = null;
        this.attenuationDistance = 0;
        this.attenuationColor = new Color(1, 1, 1);
        this.specularIntensity = 1;
        this.specularIntensityMap = null;
        this.specularColor = new Color(1, 1, 1);
        this.specularColorMap = null;
        this._sheen = 0;
        this._clearcoat = 0;
        this._transmission = 0;
        this.setValues(parameters);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(value) {
        if (this._sheen > 0 !== value > 0) {
          this.version++;
        }
        this._sheen = value;
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(value) {
        if (this._clearcoat > 0 !== value > 0) {
          this.version++;
        }
        this._clearcoat = value;
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(value) {
        if (this._transmission > 0 !== value > 0) {
          this.version++;
        }
        this._transmission = value;
      }
      copy(source) {
        super.copy(source);
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.ior = source.ior;
        this.sheen = source.sheen;
        this.sheenColor.copy(source.sheenColor);
        this.sheenColorMap = source.sheenColorMap;
        this.sheenRoughness = source.sheenRoughness;
        this.sheenRoughnessMap = source.sheenRoughnessMap;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularColor.copy(source.specularColor);
        this.specularColorMap = source.specularColorMap;
        return this;
      }
    };
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    var MeshPhongMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshPhongMaterial";
        this.color = new Color(16777215);
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    var MeshToonMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "TOON": "" };
        this.type = "MeshToonMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    var MeshNormalMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    var MeshLambertMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshLambertMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    var MeshMatcapMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "MATCAP": "" };
        this.type = "MeshMatcapMaterial";
        this.color = new Color(16777215);
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "MATCAP": "" };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    var LineDashedMaterial = class extends LineBasicMaterial {
      constructor(parameters) {
        super();
        this.type = "LineDashedMaterial";
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
      }
    };
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    var AnimationUtils = {
      arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) {
          return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
        }
        return array.slice(from, to);
      },
      convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
          return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array);
        }
        return Array.prototype.slice.call(array);
      },
      isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function(times) {
        function compareTime(i2, j) {
          return times[i2] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for (let i2 = 0; i2 !== n; ++i2)
          result[i2] = i2;
        result.sort(compareTime);
        return result;
      },
      sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
          const srcOffset = order[i2] * stride;
          for (let j = 0; j !== stride; ++j) {
            result[dstOffset++] = values[srcOffset + j];
          }
        }
        return result;
      },
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i2 = 1, key = jsonKeys[0];
        while (key !== void 0 && key[valuePropertyName] === void 0) {
          key = jsonKeys[i2++];
        }
        if (key === void 0)
          return;
        let value = key[valuePropertyName];
        if (value === void 0)
          return;
        if (Array.isArray(value)) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push.apply(values, value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else if (value.toArray !== void 0) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              value.toArray(values, values.length);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push(value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        }
      },
      subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          const track = clip.tracks[i2];
          const valueSize = track.getValueSize();
          const times = [];
          const values = [];
          for (let j = 0; j < track.times.length; ++j) {
            const frame = track.times[j] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j]);
            for (let k = 0; k < valueSize; ++k) {
              values.push(track.values[j * valueSize + k]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils.convertArray(times, track.times.constructor);
          track.values = AnimationUtils.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          if (minStartTime > clip.tracks[i2].times[0]) {
            minStartTime = clip.tracks[i2].times[0];
          }
        }
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          clip.tracks[i2].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      },
      makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0)
          fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for (let i2 = 0; i2 < numTracks; ++i2) {
          const referenceTrack = referenceClip.tracks[i2];
          const referenceTrackType = referenceTrack.ValueTypeName;
          if (referenceTrackType === "bool" || referenceTrackType === "string")
            continue;
          const targetTrack = targetClip.tracks.find(function(track) {
            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
          });
          if (targetTrack === void 0)
            continue;
          let referenceOffset = 0;
          const referenceValueSize = referenceTrack.getValueSize();
          if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            referenceOffset = referenceValueSize / 3;
          }
          let targetOffset = 0;
          const targetValueSize = targetTrack.getValueSize();
          if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            targetOffset = targetValueSize / 3;
          }
          const lastIndex = referenceTrack.times.length - 1;
          let referenceValue;
          if (referenceTime <= referenceTrack.times[0]) {
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else if (referenceTime >= referenceTrack.times[lastIndex]) {
            const startIndex = lastIndex * referenceValueSize + referenceOffset;
            const endIndex = startIndex + referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else {
            const interpolant = referenceTrack.createInterpolant();
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            interpolant.evaluate(referenceTime);
            referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
          }
          if (referenceTrackType === "quaternion") {
            const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
            referenceQuat.toArray(referenceValue);
          }
          const numTimes = targetTrack.times.length;
          for (let j = 0; j < numTimes; ++j) {
            const valueStart = j * targetValueSize + targetOffset;
            if (referenceTrackType === "quaternion") {
              Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
            } else {
              const valueEnd = targetValueSize - targetOffset * 2;
              for (let k = 0; k < valueEnd; ++k) {
                targetTrack.values[valueStart + k] -= referenceValue[k];
              }
            }
          }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
      }
    };
    var Interpolant = class {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
      }
      evaluate(t) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            let right;
            linear_scan: {
              forward_scan:
                if (!(t < t1)) {
                  for (let giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.afterEnd_(i1 - 1, t, t0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t >= t0)) {
                const t1global = pp[1];
                if (t < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (let giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              const mid = i1 + right >>> 1;
              if (t < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.beforeStart_(0, t, t1);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.afterEnd_(i1 - 1, t0, t);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t, t1);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(index2) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset2 = index2 * stride;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset2 + i2];
        }
        return result;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {
      }
    };
    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
    Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
    var CubicInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
      }
      intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      }
      interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
        }
        return result;
      }
    };
    var LinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
        }
        return result;
      }
    };
    var DiscreteInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    };
    var KeyframeTrack = class {
      constructor(name, times, values, interpolation) {
        if (name === void 0)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === void 0 || times.length === 0)
          throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
      }
      static toJSON(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          json = {
            "name": track.name,
            "times": AnimationUtils.convertArray(track.times, Array),
            "values": AnimationUtils.convertArray(track.values, Array)
          };
          const interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
      InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      setInterpolation(interpolation) {
        let factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(timeOffset) {
        if (timeOffset !== 0) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] += timeOffset;
          }
        }
        return this;
      }
      scale(timeScale) {
        if (timeScale !== 1) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] *= timeScale;
          }
        }
        return this;
      }
      trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          const stride = this.getValueSize();
          this.times = AnimationUtils.arraySlice(times, from, to);
          this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
      }
      validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        let prevTime = null;
        for (let i2 = 0; i2 !== nKeys; i2++) {
          const currTime = times[i2];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils.isTypedArray(values)) {
            for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
              const value = values[i2];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      }
      optimize() {
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for (let i2 = 1; i2 < lastIndex; ++i2) {
          let keep = false;
          const time = times[i2];
          const timeNext = times[i2 + 1];
          if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              const offset2 = i2 * stride, offsetP = offset2 - stride, offsetN = offset2 + stride;
              for (let j = 0; j !== stride; ++j) {
                const value = values[offset2 + j];
                if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i2 !== writeIndex) {
              times[writeIndex] = times[i2];
              const readOffset = i2 * stride, writeOffset = writeIndex * stride;
              for (let j = 0; j !== stride; ++j) {
                values[writeOffset + j] = values[readOffset + j];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      }
      clone() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    };
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    var BooleanKeyframeTrack = class extends KeyframeTrack {
    };
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    var ColorKeyframeTrack = class extends KeyframeTrack {
    };
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    var NumberKeyframeTrack = class extends KeyframeTrack {
    };
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    var QuaternionLinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset2 = i1 * stride;
        for (let end = offset2 + stride; offset2 !== end; offset2 += 4) {
          Quaternion.slerpFlat(result, 0, values, offset2 - stride, values, offset2, alpha);
        }
        return result;
      }
    };
    var QuaternionKeyframeTrack = class extends KeyframeTrack {
      InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    };
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
    QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    var StringKeyframeTrack = class extends KeyframeTrack {
    };
    StringKeyframeTrack.prototype.ValueTypeName = "string";
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    var VectorKeyframeTrack = class extends KeyframeTrack {
    };
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    var AnimationClip = class {
      constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = generateUUID();
        if (this.duration < 0) {
          this.resetDuration();
        }
      }
      static parse(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
          tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
        }
        const clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
      }
      static toJSON(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
          "name": clip.name,
          "duration": clip.duration,
          "tracks": tracks,
          "uuid": clip.uuid,
          "blendMode": clip.blendMode
        };
        for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
        }
        return json;
      }
      static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for (let i2 = 0; i2 < numMorphTargets; i2++) {
          let times = [];
          let values = [];
          times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
          values.push(0, 1, 0);
          const order = AnimationUtils.getKeyframeOrder(times);
          times = AnimationUtils.sortedArray(times, 1, order);
          values = AnimationUtils.sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
        }
        return new this(name, -1, tracks);
      }
      static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          const o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (let i2 = 0; i2 < clipArray.length; i2++) {
          if (clipArray[i2].name === name) {
            return clipArray[i2];
          }
        }
        return null;
      }
      static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        const pattern = /^([\w-]*?)([\d]+)$/;
        for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          const morphTarget = morphTargets[i2];
          const parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            const name = parts[1];
            let animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        const clips = [];
        for (const name in animationToMorphTargets) {
          clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
      }
      static parseAnimation(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
          if (animationKeys.length !== 0) {
            const times = [];
            const values = [];
            AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
            if (times.length !== 0) {
              destTracks.push(new trackType(trackName, times, values));
            }
          }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for (let h = 0; h < hierarchyTracks.length; h++) {
          const animationKeys = hierarchyTracks[h].keys;
          if (!animationKeys || animationKeys.length === 0)
            continue;
          if (animationKeys[0].morphTargets) {
            const morphTargetNames = {};
            let k;
            for (k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                  morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
              }
            }
            for (const morphTargetName in morphTargetNames) {
              const times = [];
              const values = [];
              for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                const animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * (fps || 1);
          } else {
            const boneName = ".bones[" + bones[h].name + "]";
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
            addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        const clip = new this(clipName, duration, tracks, blendMode);
        return clip;
      }
      resetDuration() {
        const tracks = this.tracks;
        let duration = 0;
        for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
          const track = this.tracks[i2];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      }
      trim() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].trim(0, this.duration);
        }
        return this;
      }
      validate() {
        let valid = true;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          valid = valid && this.tracks[i2].validate();
        }
        return valid;
      }
      optimize() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].optimize();
        }
        return this;
      }
      clone() {
        const tracks = [];
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          tracks.push(this.tracks[i2].clone());
        }
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    };
    function getTrackTypeForValueTypeName(typeName) {
      switch (typeName.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return VectorKeyframeTrack;
        case "color":
          return ColorKeyframeTrack;
        case "quaternion":
          return QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
          return BooleanKeyframeTrack;
        case "string":
          return StringKeyframeTrack;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
    }
    function parseKeyframeTrack(json) {
      if (json.type === void 0) {
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      }
      const trackType = getTrackTypeForValueTypeName(json.type);
      if (json.times === void 0) {
        const times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
      }
      if (trackType.parse !== void 0) {
        return trackType.parse(json);
      } else {
        return new trackType(json.name, json.times, json.values, json.interpolation);
      }
    }
    var Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    var LoadingManager = class {
      constructor(onLoad, onProgress, onError) {
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = void 0;
        const handlers = [];
        this.onStart = void 0;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
          itemsTotal++;
          if (isLoading === false) {
            if (scope.onStart !== void 0) {
              scope.onStart(url, itemsLoaded, itemsTotal);
            }
          }
          isLoading = true;
        };
        this.itemEnd = function(url) {
          itemsLoaded++;
          if (scope.onProgress !== void 0) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
          }
          if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== void 0) {
              scope.onLoad();
            }
          }
        };
        this.itemError = function(url) {
          if (scope.onError !== void 0) {
            scope.onError(url);
          }
        };
        this.resolveURL = function(url) {
          if (urlModifier) {
            return urlModifier(url);
          }
          return url;
        };
        this.setURLModifier = function(transform3) {
          urlModifier = transform3;
          return this;
        };
        this.addHandler = function(regex, loader) {
          handlers.push(regex, loader);
          return this;
        };
        this.removeHandler = function(regex) {
          const index2 = handlers.indexOf(regex);
          if (index2 !== -1) {
            handlers.splice(index2, 2);
          }
          return this;
        };
        this.getHandler = function(file) {
          for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
            const regex = handlers[i2];
            const loader = handlers[i2 + 1];
            if (regex.global)
              regex.lastIndex = 0;
            if (regex.test(file)) {
              return loader;
            }
          }
          return null;
        };
      }
    };
    var DefaultLoadingManager = new LoadingManager();
    var Loader = class {
      constructor(manager) {
        this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
        this.crossOrigin = "anonymous";
        this.withCredentials = false;
        this.path = "";
        this.resourcePath = "";
        this.requestHeader = {};
      }
      load() {
      }
      loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
          scope.load(url, resolve, onProgress, reject);
        });
      }
      parse() {
      }
      setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      }
      setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      }
      setPath(path) {
        this.path = path;
        return this;
      }
      setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
      setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    };
    var loading = {};
    var FileLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const cached = Cache.get(url);
        if (cached !== void 0) {
          this.manager.itemStart(url);
          setTimeout(() => {
            if (onLoad)
              onLoad(cached);
            this.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading[url] !== void 0) {
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        const req = new Request(url, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
        });
        fetch(req).then((response) => {
          if (response.status === 200 || response.status === 0) {
            if (response.status === 0) {
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            }
            const callbacks = loading[url];
            const reader = response.body.getReader();
            const contentLength = response.headers.get("Content-Length");
            const total = contentLength ? parseInt(contentLength) : 0;
            const lengthComputable = total !== 0;
            let loaded = 0;
            return new ReadableStream({
              start(controller) {
                readData();
                function readData() {
                  reader.read().then(({ done, value }) => {
                    if (done) {
                      controller.close();
                    } else {
                      loaded += value.byteLength;
                      const event2 = new ProgressEvent("progress", { lengthComputable, loaded, total });
                      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                        const callback = callbacks[i2];
                        if (callback.onProgress)
                          callback.onProgress(event2);
                      }
                      controller.enqueue(value);
                      readData();
                    }
                  });
                }
              }
            });
          } else {
            throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
          }
        }).then((stream) => {
          const response = new Response(stream);
          switch (this.responseType) {
            case "arraybuffer":
              return response.arrayBuffer();
            case "blob":
              return response.blob();
            case "document":
              return response.text().then((text2) => {
                const parser = new DOMParser();
                return parser.parseFromString(text2, this.mimeType);
              });
            case "json":
              return response.json();
            default:
              return response.text();
          }
        }).then((data) => {
          Cache.add(url, data);
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad)
              callback.onLoad(data);
          }
          this.manager.itemEnd(url);
        }).catch((err) => {
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(err);
          }
          this.manager.itemError(url);
          this.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
      }
      setResponseType(value) {
        this.responseType = value;
        return this;
      }
      setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    };
    var ImageLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const image = createElementNS("img");
        function onImageLoad() {
          removeEventListeners();
          Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event2) {
          removeEventListeners();
          if (onError)
            onError(event2);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.substr(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    };
    var CubeTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i2) {
          loader.load(urls[i2], function(image) {
            texture.images[i2] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, void 0, onError);
        }
        for (let i2 = 0; i2 < urls.length; ++i2) {
          loadTexture(i2);
        }
        return texture;
      }
    };
    var TextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    };
    var Light = class extends Object3D {
      constructor(color, intensity = 1) {
        super();
        this.type = "Light";
        this.color = new Color(color);
        this.intensity = intensity;
      }
      dispose() {
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      }
    };
    Light.prototype.isLight = true;
    var HemisphereLight = class extends Light {
      constructor(skyColor, groundColor, intensity) {
        super(skyColor, intensity);
        this.type = "HemisphereLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
      }
      copy(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    };
    HemisphereLight.prototype.isHemisphereLight = true;
    var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
    var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
    var _lookTarget$1 = /* @__PURE__ */ new Vector3();
    var LightShadow = class {
      constructor(camera) {
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
          new Vector4(0, 0, 1, 1)
        ];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        if (this.map) {
          this.map.dispose();
        }
        if (this.mapPass) {
          this.mapPass.dispose();
        }
      }
      copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.normalBias !== 0)
          object.normalBias = this.normalBias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    };
    var SpotLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(50, 1, 0.5, 500));
        this.focus = 1;
      }
      updateMatrices(light) {
        const camera = this.camera;
        const fov2 = RAD2DEG * 2 * light.angle * this.focus;
        const aspect2 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
          camera.fov = fov2;
          camera.aspect = aspect2;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
      }
      copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
      }
    };
    SpotLightShadow.prototype.isSpotLightShadow = true;
    var SpotLight = class extends Light {
      constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
        super(color, intensity);
        this.type = "SpotLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay;
        this.shadow = new SpotLightShadow();
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(power) {
        this.intensity = power / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    SpotLight.prototype.isSpotLight = true;
    var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
    var _lightPositionWorld = /* @__PURE__ */ new Vector3();
    var _lookTarget = /* @__PURE__ */ new Vector3();
    var PointLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(90, 1, 0.5, 500));
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
          new Vector4(2, 1, 1, 1),
          new Vector4(0, 1, 1, 1),
          new Vector4(3, 1, 1, 1),
          new Vector4(1, 1, 1, 1),
          new Vector4(3, 0, 1, 1),
          new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
          new Vector3(1, 0, 0),
          new Vector3(-1, 0, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1),
          new Vector3(0, 1, 0),
          new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1)
        ];
      }
      updateMatrices(light, viewportIndex = 0) {
        const camera = this.camera;
        const shadowMatrix = this.matrix;
        const far = light.distance || camera.far;
        if (far !== camera.far) {
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(_lightPositionWorld);
        _lookTarget.copy(camera.position);
        _lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
      }
    };
    PointLightShadow.prototype.isPointLightShadow = true;
    var PointLight = class extends Light {
      constructor(color, intensity, distance = 0, decay = 1) {
        super(color, intensity);
        this.type = "PointLight";
        this.distance = distance;
        this.decay = decay;
        this.shadow = new PointLightShadow();
      }
      get power() {
        return this.intensity * 4 * Math.PI;
      }
      set power(power) {
        this.intensity = power / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    PointLight.prototype.isPointLight = true;
    var DirectionalLightShadow = class extends LightShadow {
      constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
      }
    };
    DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
    var DirectionalLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.type = "DirectionalLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    DirectionalLight.prototype.isDirectionalLight = true;
    var AmbientLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.type = "AmbientLight";
      }
    };
    AmbientLight.prototype.isAmbientLight = true;
    var RectAreaLight = class extends Light {
      constructor(color, intensity, width = 10, height = 10) {
        super(color, intensity);
        this.type = "RectAreaLight";
        this.width = width;
        this.height = height;
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(power) {
        this.intensity = power / (this.width * this.height * Math.PI);
      }
      copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    };
    RectAreaLight.prototype.isRectAreaLight = true;
    var SphericalHarmonics3 = class {
      constructor() {
        this.coefficients = [];
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients.push(new Vector3());
        }
      }
      set(coefficients) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].copy(coefficients[i2]);
        }
        return this;
      }
      zero() {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].set(0, 0, 0);
        }
        return this;
      }
      getAt(normal, target) {
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
      }
      getIrradianceAt(normal, target) {
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 2 * 0.511664 * y);
        target.addScaledVector(coeff[2], 2 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2 * 0.511664 * x);
        target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
        target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
        return target;
      }
      add(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].add(sh.coefficients[i2]);
        }
        return this;
      }
      addScaledSH(sh, s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
        }
        return this;
      }
      scale(s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].multiplyScalar(s);
        }
        return this;
      }
      lerp(sh, alpha) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
        }
        return this;
      }
      equals(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
            return false;
          }
        }
        return true;
      }
      copy(sh) {
        return this.set(sh.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(array, offset2 = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].fromArray(array, offset2 + i2 * 3);
        }
        return this;
      }
      toArray(array = [], offset2 = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].toArray(array, offset2 + i2 * 3);
        }
        return array;
      }
      static getBasisAt(normal, shBasis) {
        const x = normal.x, y = normal.y, z = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
      }
    };
    SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
    var LightProbe = class extends Light {
      constructor(sh = new SphericalHarmonics3(), intensity = 1) {
        super(void 0, intensity);
        this.sh = sh;
      }
      copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
      }
      fromJSON(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.sh = this.sh.toArray();
        return data;
      }
    };
    LightProbe.prototype.isLightProbe = true;
    var LoaderUtils = class {
      static decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        let s = "";
        for (let i2 = 0, il = array.length; i2 < il; i2++) {
          s += String.fromCharCode(array[i2]);
        }
        try {
          return decodeURIComponent(escape(s));
        } catch (e) {
          return s;
        }
      }
      static extractUrlBase(url) {
        const index2 = url.lastIndexOf("/");
        if (index2 === -1)
          return "./";
        return url.substr(0, index2 + 1);
      }
      static resolveURL(url, path) {
        if (typeof url !== "string" || url === "")
          return "";
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        }
        if (/^(https?:)?\/\//i.test(url))
          return url;
        if (/^data:.*,.*$/i.test(url))
          return url;
        if (/^blob:.*$/i.test(url))
          return url;
        return path + url;
      }
    };
    var InstancedBufferGeometry = class extends BufferGeometry {
      constructor() {
        super();
        this.type = "InstancedBufferGeometry";
        this.instanceCount = Infinity;
      }
      copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const data = super.toJSON(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    };
    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
    var ImageBitmapLoader = class extends Loader {
      constructor(manager) {
        super(manager);
        if (typeof createImageBitmap === "undefined") {
          console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
        }
        if (typeof fetch === "undefined") {
          console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
        }
        this.options = { premultiplyAlpha: "none" };
      }
      setOptions(options) {
        this.options = options;
        return this;
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
          return res.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
        }).then(function(imageBitmap) {
          Cache.add(url, imageBitmap);
          if (onLoad)
            onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch(function(e) {
          if (onError)
            onError(e);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
      }
    };
    ImageBitmapLoader.prototype.isImageBitmapLoader = true;
    var _context2;
    var AudioContext = {
      getContext: function() {
        if (_context2 === void 0) {
          _context2 = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context2;
      },
      setContext: function(value) {
        _context2 = value;
      }
    };
    var AudioLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
          try {
            const bufferCopy = buffer.slice(0);
            const context3 = AudioContext.getContext();
            context3.decodeAudioData(bufferCopy, function(audioBuffer) {
              onLoad(audioBuffer);
            });
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    };
    var HemisphereLightProbe = class extends LightProbe {
      constructor(skyColor, groundColor, intensity = 1) {
        super(void 0, intensity);
        const color1 = new Color().set(skyColor);
        const color2 = new Color().set(groundColor);
        const sky = new Vector3(color1.r, color1.g, color1.b);
        const ground = new Vector3(color2.r, color2.g, color2.b);
        const c0 = Math.sqrt(Math.PI);
        const c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
      }
    };
    HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
    var AmbientLightProbe = class extends LightProbe {
      constructor(color, intensity = 1) {
        super(void 0, intensity);
        const color1 = new Color().set(color);
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    };
    AmbientLightProbe.prototype.isAmbientLightProbe = true;
    var Clock = class {
      constructor(autoStart = true) {
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
      }
      start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      }
      stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      }
      getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      }
      getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          const newTime = now();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    function now() {
      return (typeof performance === "undefined" ? Date : performance).now();
    }
    var Audio = class extends Object3D {
      constructor(listener) {
        super();
        this.type = "Audio";
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = void 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = "empty";
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      }
      setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      }
      setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      }
      setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay)
          this.play();
        return this;
      }
      play(delay3 = 0) {
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay3;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
      pause() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      }
      stop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].connect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].disconnect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(value) {
        if (!value)
          value = [];
        if (this._connected === true) {
          this.disconnect();
          this.filters = value.slice();
          this.connect();
        } else {
          this.filters = value.slice();
        }
        return this;
      }
      setDetune(value) {
        this.detune = value;
        if (this.source.detune === void 0)
          return;
        if (this.isPlaying === true) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(filter2) {
        return this.setFilters(filter2 ? [filter2] : []);
      }
      setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = false;
      }
      getLoop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      }
      setLoop(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      }
      setLoopStart(value) {
        this.loopStart = value;
        return this;
      }
      setLoopEnd(value) {
        this.loopEnd = value;
        return this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    };
    var AudioAnalyser = class {
      constructor(audio, fftSize = 2048) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
      }
      getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      }
      getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for (let i2 = 0; i2 < data.length; i2++) {
          value += data[i2];
        }
        return value / data.length;
      }
    };
    var PropertyMixer = class {
      constructor(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
          case "string":
          case "bool":
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
          default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
      }
      accumulate(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset2 = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[offset2 + i2] = buffer[i2];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          const mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset2, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      }
      accumulateAdditive(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset2 = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset2, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      }
      apply(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset2 = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          const originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(buffer, offset2, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
          this._mixBufferRegionAdditive(buffer, offset2, this._addIndex * stride, 1, stride);
        }
        for (let i2 = stride, e = stride + stride; i2 !== e; ++i2) {
          if (buffer[i2] !== buffer[i2 + stride]) {
            binding.setValue(buffer, offset2);
            break;
          }
        }
      }
      saveOriginalState() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for (let i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
          buffer[i2] = buffer[originalValueOffset + i2 % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      }
      restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      }
      _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          this.buffer[i2] = 0;
        }
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
      _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for (let i2 = 0; i2 < this.valueSize; i2++) {
          this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
        }
      }
      _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[dstOffset + i2] = buffer[srcOffset + i2];
          }
        }
      }
      _slerp(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
      }
      _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
      }
      _lerp(buffer, dstOffset, srcOffset, t, stride) {
        const s = 1 - t;
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] * s + buffer[srcOffset + i2] * t;
        }
      }
      _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] + buffer[srcOffset + i2] * t;
        }
      }
    };
    var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
    var _supportedObjectNames = ["material", "materials", "bones"];
    var Composite = class {
      constructor(targetGroup, path, optionalParsedPath) {
        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
      }
      getValue(array, offset2) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array, offset2);
      }
      setValue(array, offset2) {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].setValue(array, offset2);
        }
      }
      bind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].bind();
        }
      }
      unbind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].unbind();
        }
      }
    };
    var PropertyBinding = class {
      constructor(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
      static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      }
      static sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      }
      static parseTrackName(trackName) {
        const matches2 = _trackRe.exec(trackName);
        if (!matches2) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
          nodeName: matches2[2],
          objectName: matches2[3],
          objectIndex: matches2[4],
          propertyName: matches2[5],
          propertyIndex: matches2[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          const objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      }
      static findNode(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          const bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          const searchNodeSubtree = function(children2) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              const childNode = children2[i2];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              const result = searchNodeSubtree(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          const subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      _getValue_direct(buffer, offset2) {
        buffer[offset2] = this.targetObject[this.propertyName];
      }
      _getValue_array(buffer, offset2) {
        const source = this.resolvedProperty;
        for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
          buffer[offset2++] = source[i2];
        }
      }
      _getValue_arrayElement(buffer, offset2) {
        buffer[offset2] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(buffer, offset2) {
        this.resolvedProperty.toArray(buffer, offset2);
      }
      _setValue_direct(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
      }
      _setValue_direct_setNeedsUpdate(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
        this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(buffer, offset2) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset2++];
        }
      }
      _setValue_array_setNeedsUpdate(buffer, offset2) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset2++];
        }
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset2) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset2++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
      }
      _setValue_arrayElement_setNeedsUpdate(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
        this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
      }
      _setValue_fromArray_setNeedsUpdate(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
        this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(targetArray, offset2) {
        this.bind();
        this.getValue(targetArray, offset2);
      }
      _setValue_unbound(sourceArray, offset2) {
        this.bind();
        this.setValue(sourceArray, offset2);
      }
      bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          let objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (let i2 = 0; i2 < targetObject.length; i2++) {
                if (targetObject[i2].name === objectIndex) {
                  objectIndex = i2;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          const nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (targetObject.geometry.isBufferGeometry) {
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            } else {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              return;
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      }
      unbind() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    };
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [
      PropertyBinding.prototype._getValue_direct,
      PropertyBinding.prototype._getValue_array,
      PropertyBinding.prototype._getValue_arrayElement,
      PropertyBinding.prototype._getValue_toArray
    ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
      [
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]
    ];
    var AnimationObjectGroup = class {
      constructor() {
        this.uuid = generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        const indices = {};
        this._indicesByUUID = indices;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          indices[arguments[i2].uuid] = i2;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        const scope = this;
        this.stats = {
          objects: {
            get total() {
              return scope._objects.length;
            },
            get inUse() {
              return this.total - scope.nCachedObjects_;
            }
          },
          get bindingsPerObject() {
            return scope._bindings.length;
          }
        };
      }
      add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid;
          let index2 = indicesByUUID[uuid];
          if (index2 === void 0) {
            index2 = nObjects++;
            indicesByUUID[uuid] = index2;
            objects.push(object);
            for (let j = 0, m = nBindings; j !== m; ++j) {
              bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            }
          } else if (index2 < nCachedObjects) {
            knownObject = objects[index2];
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index2;
            objects[index2] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
              let binding = bindingsForPath[index2];
              bindingsForPath[index2] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index2] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index2 = indicesByUUID[uuid];
          if (index2 !== void 0 && index2 >= nCachedObjects) {
            const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index2;
            objects[index2] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
              bindingsForPath[index2] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index2 = indicesByUUID[uuid];
          if (index2 !== void 0) {
            delete indicesByUUID[uuid];
            if (index2 < nCachedObjects) {
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index2;
              objects[index2] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index2] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              const lastIndex = --nObjects, lastObject = objects[lastIndex];
              if (lastIndex > 0) {
                indicesByUUID[lastObject.uuid] = index2;
              }
              objects[index2] = lastObject;
              objects.pop();
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j];
                bindingsForPath[index2] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      subscribe_(path, parsedPath) {
        const indicesByPath = this._bindingsIndicesByPath;
        let index2 = indicesByPath[path];
        const bindings = this._bindings;
        if (index2 !== void 0)
          return bindings[index2];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index2 = bindings.length;
        indicesByPath[path] = index2;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
          const object = objects[i2];
          bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      }
      unsubscribe_(path) {
        const indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path];
        if (index2 !== void 0) {
          const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index2;
          bindings[index2] = lastBindings;
          bindings.pop();
          parsedPaths[index2] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index2] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    };
    AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
    var AnimationAction = class {
      constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const interpolant = tracks[i2].createInterpolant(null);
          interpolants[i2] = interpolant;
          interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
      }
      play() {
        this._mixer._activateAction(this);
        return this;
      }
      stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
      }
      reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      }
      isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(time) {
        this._startTime = time;
        return this;
      }
      setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      }
      setEffectiveWeight(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
      }
      fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
      }
      crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      }
      crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      }
      stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      }
      setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      }
      syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      }
      halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      }
      warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now3;
        times[1] = now3 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      }
      stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time);
          return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
          const timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            return;
          }
          this._startTime = null;
          deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        const weight = this._updateWeight(time);
        if (weight > 0) {
          const interpolants = this._interpolants;
          const propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
              for (let j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode:
            default:
              for (let j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
              }
          }
        }
      }
      _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
          weight = this.weight;
          const interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      }
      _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          const interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      }
      _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
          if (loopCount === -1)
            return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            const loopDelta = Math.floor(time / duration);
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            const pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                const atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time;
          }
        }
        return time;
      }
      _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      }
      _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now3 = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now3;
        values[0] = weightNow;
        times[1] = now3 + duration;
        values[1] = weightThen;
        return this;
      }
    };
    var AnimationMixer = class extends EventDispatcher {
      constructor(root) {
        super();
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
      }
      _bindAction(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const track = tracks[i2], trackName = track.name;
          let binding = bindingsByName[trackName];
          if (binding !== void 0) {
            bindings[i2] = binding;
          } else {
            binding = bindings[i2];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i2] = binding;
          }
          interpolants[i2].resultBuffer = binding.buffer;
        }
      }
      _activateAction(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      }
      _deactivateAction(action) {
        if (this._isActiveAction(action)) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      }
      _initMemoryManager() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      }
      _isActiveAction(action) {
        const index2 = action._cacheIndex;
        return index2 !== null && index2 < this._nActiveActions;
      }
      _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          const knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      }
      _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      }
      _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
          const binding = bindings[i2];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      }
      _lendAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      }
      _takeBackAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      }
      _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      }
      _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      }
      _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      }
      _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      }
      _lendControlInterpolant() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      }
      _takeBackControlInterpolant(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      }
      clipAction(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === void 0) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode;
          }
        }
        if (actionsForClip !== void 0) {
          const existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
          return null;
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      }
      existingAction(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      }
      stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for (let i2 = nActions - 1; i2 >= 0; --i2) {
          actions[i2].stop();
        }
        return this;
      }
      update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (let i2 = 0; i2 !== nActions; ++i2) {
          const action = actions[i2];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for (let i2 = 0; i2 !== nBindings; ++i2) {
          bindings[i2].apply(accuIndex);
        }
        return this;
      }
      setTime(timeInSeconds) {
        this.time = 0;
        for (let i2 = 0; i2 < this._actions.length; i2++) {
          this._actions[i2].time = 0;
        }
        return this.update(timeInSeconds);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          const actionsToRemove = actionsForClip.knownActions;
          for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
            const action = actionsToRemove[i2];
            this._deactivateAction(action);
            const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      }
      uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (const clipUuid in actionsByClip) {
          const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (const trackName in bindingByName) {
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      }
      uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    };
    AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    var Uniform = class {
      constructor(value) {
        if (typeof value === "string") {
          console.warn("THREE.Uniform: Type parameter is no longer needed.");
          value = arguments[1];
        }
        this.value = value;
      }
      clone() {
        return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
      }
    };
    var InstancedInterleavedBuffer = class extends InterleavedBuffer {
      constructor(array, stride, meshPerAttribute = 1) {
        super(array, stride);
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      }
      toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    };
    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
    var GLBufferAttribute = class {
      constructor(buffer, type, itemSize, elementSize, count) {
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setBuffer(buffer) {
        this.buffer = buffer;
        return this;
      }
      setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
      }
      setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
      }
      setCount(count) {
        this.count = count;
        return this;
      }
    };
    GLBufferAttribute.prototype.isGLBufferAttribute = true;
    var _vector$4 = /* @__PURE__ */ new Vector2();
    var Box2 = class {
      constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      }
      getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      }
      intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
      }
      clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      translate(offset2) {
        this.min.add(offset2);
        this.max.add(offset2);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    Box2.prototype.isBox2 = true;
    var _startP = /* @__PURE__ */ new Vector3();
    var _startEnd = /* @__PURE__ */ new Vector3();
    var Line3 = class {
      constructor(start = new Vector3(), end = new Vector3()) {
        this.start = start;
        this.end = end;
      }
      set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      }
      copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      }
      getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(target) {
        return target.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(t, target) {
        return this.delta(target).multiplyScalar(t).add(this.start);
      }
      closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = clamp4(t, 0, 1);
        }
        return t;
      }
      closestPointToPoint(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t).add(this.start);
      }
      applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      }
      equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    var _vector$2 = /* @__PURE__ */ new Vector3();
    var _boneMatrix = /* @__PURE__ */ new Matrix4();
    var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
    var SkeletonHelper = class extends LineSegments {
      constructor(object) {
        const bones = getBoneList(object);
        const geometry = new BufferGeometry();
        const vertices = [];
        const colors = [];
        const color1 = new Color(0, 0, 1);
        const color2 = new Color(0, 1, 0);
        for (let i2 = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
          }
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
        super(geometry, material);
        this.type = "SkeletonHelper";
        this.isSkeletonHelper = true;
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
      }
      updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute("position");
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
            j += 2;
          }
        }
        geometry.getAttribute("position").needsUpdate = true;
        super.updateMatrixWorld(force);
      }
    };
    function getBoneList(object) {
      const boneList = [];
      if (object && object.isBone) {
        boneList.push(object);
      }
      for (let i2 = 0; i2 < object.children.length; i2++) {
        boneList.push.apply(boneList, getBoneList(object.children[i2]));
      }
      return boneList;
    }
    var GridHelper = class extends LineSegments {
      constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
        color1 = new Color(color1);
        color2 = new Color(color2);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
          vertices.push(-halfSize, 0, k, halfSize, 0, k);
          vertices.push(k, 0, -halfSize, k, 0, halfSize);
          const color = i2 === center ? color1 : color2;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "GridHelper";
      }
    };
    var ShapePath = class {
      constructor() {
        this.type = "ShapePath";
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
      }
      moveTo(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
      }
      lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      }
      splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
      }
      toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
          const shapes2 = [];
          for (let i2 = 0, l = inSubpaths.length; i2 < l; i2++) {
            const tmpPath2 = inSubpaths[i2];
            const tmpShape2 = new Shape();
            tmpShape2.curves = tmpPath2.curves;
            shapes2.push(tmpShape2);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          const polyLen = inPolygon.length;
          let inside = false;
          for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            let edgeLowPt = inPolygon[p];
            let edgeHighPt = inPolygon[q];
            let edgeDx = edgeHighPt.x - edgeLowPt.x;
            let edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                  return true;
              } else {
                const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                  return true;
                if (perpEdge < 0)
                  continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y)
                continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
            }
          }
          return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0)
          return [];
        if (noHoles === true)
          return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (let i2 = 0, l = subPaths.length; i2 < l; i2++) {
          tmpPath = subPaths[i2];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx])
              mainIdx++;
            newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst)
              mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
          }
        }
        if (!newShapes[0])
          return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          let ambiguous = false;
          const toChange = [];
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            const sho = newShapeHoles[sIdx];
            for (let hIdx = 0; hIdx < sho.length; hIdx++) {
              const ho = sho[hIdx];
              let hole_unassigned = true;
              for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (sIdx !== s2Idx)
                    toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
              }
            }
          }
          if (toChange.length > 0) {
            if (!ambiguous)
              newShapeHoles = betterShapeHoles;
          }
        }
        let tmpHoles;
        for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
          tmpShape = newShapes[i2].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[i2];
          for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }
        return shapes;
      }
    };
    var _floatView = new Float32Array(1);
    var _int32View = new Int32Array(_floatView.buffer);
    Curve.create = function(construct, getPoint) {
      console.log("THREE.Curve.create() has been deprecated");
      construct.prototype = Object.create(Curve.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;
      return construct;
    };
    Path.prototype.fromPoints = function(points) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
      return this.setFromPoints(points);
    };
    GridHelper.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    };
    SkeletonHelper.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    };
    Loader.prototype.extractUrlBase = function(url) {
      console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
      return LoaderUtils.extractUrlBase(url);
    };
    Loader.Handlers = {
      add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      },
      get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      }
    };
    Box2.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box2.prototype.empty = function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box2.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box2.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Box3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box3.prototype.empty = function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box3.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box3.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Box3.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Sphere.prototype.empty = function() {
      console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Frustum.prototype.setFromMatrix = function(m) {
      console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
      return this.setFromProjectionMatrix(m);
    };
    Line3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Matrix3.prototype.flattenToArrayOffset = function(array, offset2) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset2);
    };
    Matrix3.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return vector.applyMatrix3(this);
    };
    Matrix3.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    };
    Matrix3.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
      return attribute.applyMatrix3(this);
    };
    Matrix3.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    };
    Matrix3.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Matrix4.prototype.extractPosition = function(m) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(m);
    };
    Matrix4.prototype.flattenToArrayOffset = function(array, offset2) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset2);
    };
    Matrix4.prototype.getPosition = function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return new Vector3().setFromMatrixColumn(this, 3);
    };
    Matrix4.prototype.setRotationFromQuaternion = function(q) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(q);
    };
    Matrix4.prototype.multiplyToArray = function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    };
    Matrix4.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.multiplyVector4 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    };
    Matrix4.prototype.rotateAxis = function(v) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      v.transformDirection(this);
    };
    Matrix4.prototype.crossVector = function(vector) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.translate = function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    };
    Matrix4.prototype.rotateX = function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    };
    Matrix4.prototype.rotateY = function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    };
    Matrix4.prototype.rotateZ = function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    };
    Matrix4.prototype.rotateByAxis = function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    };
    Matrix4.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
      return attribute.applyMatrix4(this);
    };
    Matrix4.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    };
    Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(left, right, top, bottom, near, far);
    };
    Matrix4.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Plane.prototype.isIntersectionLine = function(line) {
      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
      return this.intersectsLine(line);
    };
    Quaternion.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    };
    Quaternion.prototype.inverse = function() {
      console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
      return this.invert();
    };
    Ray.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Ray.prototype.isIntersectionPlane = function(plane) {
      console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
      return this.intersectsPlane(plane);
    };
    Ray.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Triangle.prototype.area = function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    };
    Triangle.prototype.barycoordFromPoint = function(point, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return this.getBarycoord(point, target);
    };
    Triangle.prototype.midpoint = function(target) {
      console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
      return this.getMidpoint(target);
    };
    Triangle.prototypenormal = function(target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return this.getNormal(target);
    };
    Triangle.prototype.plane = function(target) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(target);
    };
    Triangle.barycoordFromPoint = function(point, a, b, c, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return Triangle.getBarycoord(point, a, b, c, target);
    };
    Triangle.normal = function(a, b, c, target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return Triangle.getNormal(a, b, c, target);
    };
    Shape.prototype.extractAllPoints = function(divisions) {
      console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
      return this.extractPoints(divisions);
    };
    Shape.prototype.extrude = function(options) {
      console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
      return new ExtrudeGeometry(this, options);
    };
    Shape.prototype.makeGeometry = function(options) {
      console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
      return new ShapeGeometry(this, options);
    };
    Vector2.prototype.fromAttribute = function(attribute, index2, offset2) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index2, offset2);
    };
    Vector2.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector2.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector3.prototype.setEulerFromRotationMatrix = function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    };
    Vector3.prototype.setEulerFromQuaternion = function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    };
    Vector3.prototype.getPositionFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(m);
    };
    Vector3.prototype.getScaleFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(m);
    };
    Vector3.prototype.getColumnFromMatrix = function(index2, matrix) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(matrix, index2);
    };
    Vector3.prototype.applyProjection = function(m) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(m);
    };
    Vector3.prototype.fromAttribute = function(attribute, index2, offset2) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index2, offset2);
    };
    Vector3.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector3.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector4.prototype.fromAttribute = function(attribute, index2, offset2) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index2, offset2);
    };
    Vector4.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Object3D.prototype.getChildByName = function(name) {
      console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
      return this.getObjectByName(name);
    };
    Object3D.prototype.renderDepth = function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    };
    Object3D.prototype.translate = function(distance, axis) {
      console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
      return this.translateOnAxis(axis, distance);
    };
    Object3D.prototype.getWorldRotation = function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    };
    Object3D.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(Object3D.prototype, {
      eulerOrder: {
        get: function() {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          return this.rotation.order;
        },
        set: function(value) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          this.rotation.order = value;
        }
      },
      useQuaternion: {
        get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
      }
    });
    Mesh.prototype.setDrawMode = function() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    };
    Object.defineProperties(Mesh.prototype, {
      drawMode: {
        get: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
          return TrianglesDrawMode;
        },
        set: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
      }
    });
    SkinnedMesh.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    };
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
      if (filmGauge !== void 0)
        this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light.prototype, {
      onlyShadow: {
        set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        }
      },
      shadowCameraFov: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
          this.shadow.camera.fov = value;
        }
      },
      shadowCameraLeft: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
          this.shadow.camera.left = value;
        }
      },
      shadowCameraRight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
          this.shadow.camera.right = value;
        }
      },
      shadowCameraTop: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
          this.shadow.camera.top = value;
        }
      },
      shadowCameraBottom: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
          this.shadow.camera.bottom = value;
        }
      },
      shadowCameraNear: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
          this.shadow.camera.near = value;
        }
      },
      shadowCameraFar: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
          this.shadow.camera.far = value;
        }
      },
      shadowCameraVisible: {
        set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
      },
      shadowBias: {
        set: function(value) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
          this.shadow.bias = value;
        }
      },
      shadowDarkness: {
        set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
      },
      shadowMapWidth: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
          this.shadow.mapSize.width = value;
        }
      },
      shadowMapHeight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
          this.shadow.mapSize.height = value;
        }
      }
    });
    Object.defineProperties(BufferAttribute.prototype, {
      length: {
        get: function() {
          console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
          return this.array.length;
        }
      },
      dynamic: {
        get: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          this.setUsage(DynamicDrawUsage);
        }
      }
    });
    BufferAttribute.prototype.setDynamic = function(value) {
      console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    };
    BufferAttribute.prototype.copyIndicesArray = function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, BufferAttribute.prototype.setArray = function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    BufferGeometry.prototype.addIndex = function(index2) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
      this.setIndex(index2);
    };
    BufferGeometry.prototype.addAttribute = function(name, attribute) {
      console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      }
      if (name === "index") {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
        this.setIndex(attribute);
        return this;
      }
      return this.setAttribute(name, attribute);
    };
    BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
      if (indexOffset !== void 0) {
        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
      }
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(start, count);
    };
    BufferGeometry.prototype.clearDrawCalls = function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
      this.clearGroups();
    };
    BufferGeometry.prototype.computeOffsets = function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    };
    BufferGeometry.prototype.removeAttribute = function(name) {
      console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
      return this.deleteAttribute(name);
    };
    BufferGeometry.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(BufferGeometry.prototype, {
      drawcalls: {
        get: function() {
          console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
          return this.groups;
        }
      },
      offsets: {
        get: function() {
          console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
          return this.groups;
        }
      }
    });
    InterleavedBuffer.prototype.setDynamic = function(value) {
      console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    };
    InterleavedBuffer.prototype.setArray = function() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    ExtrudeGeometry.prototype.getArrays = function() {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
    };
    ExtrudeGeometry.prototype.addShapeList = function() {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
    };
    ExtrudeGeometry.prototype.addShape = function() {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
    };
    Scene.prototype.dispose = function() {
      console.error("THREE.Scene: .dispose() has been removed.");
    };
    Uniform.prototype.onUpdate = function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    };
    Object.defineProperties(Material.prototype, {
      wrapAround: {
        get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }
      },
      overdraw: {
        get: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }
      },
      wrapRGB: {
        get: function() {
          console.warn("THREE.Material: .wrapRGB has been removed.");
          return new Color();
        }
      },
      shading: {
        get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = value === FlatShading;
        }
      },
      stencilMask: {
        get: function() {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          return this.stencilFuncMask;
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          this.stencilFuncMask = value;
        }
      },
      vertexTangents: {
        get: function() {
          console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        },
        set: function() {
          console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        }
      }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
      derivatives: {
        get: function() {
          console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          return this.extensions.derivatives;
        },
        set: function(value) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          this.extensions.derivatives = value;
        }
      }
    });
    WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    };
    WebGLRenderer.prototype.animate = function(callback) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(callback);
    };
    WebGLRenderer.prototype.getCurrentRenderTarget = function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    };
    WebGLRenderer.prototype.getMaxAnisotropy = function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    };
    WebGLRenderer.prototype.getPrecision = function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    };
    WebGLRenderer.prototype.resetGLState = function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    };
    WebGLRenderer.prototype.supportsFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    };
    WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    };
    WebGLRenderer.prototype.supportsStandardDerivatives = function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    };
    WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    };
    WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    };
    WebGLRenderer.prototype.supportsBlendMinMax = function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    };
    WebGLRenderer.prototype.supportsVertexTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    };
    WebGLRenderer.prototype.supportsInstancedArrays = function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    };
    WebGLRenderer.prototype.enableScissorTest = function(boolean) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(boolean);
    };
    WebGLRenderer.prototype.initMaterial = function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    };
    WebGLRenderer.prototype.addPrePlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    };
    WebGLRenderer.prototype.addPostPlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    };
    WebGLRenderer.prototype.updateShadowMap = function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
    WebGLRenderer.prototype.setFaceCulling = function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    };
    WebGLRenderer.prototype.allocTextureUnit = function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    };
    WebGLRenderer.prototype.setTexture = function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    };
    WebGLRenderer.prototype.setTexture2D = function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    };
    WebGLRenderer.prototype.setTextureCube = function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    };
    WebGLRenderer.prototype.getActiveMipMapLevel = function() {
      console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
      return this.getActiveMipmapLevel();
    };
    Object.defineProperties(WebGLRenderer.prototype, {
      shadowMapEnabled: {
        get: function() {
          return this.shadowMap.enabled;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
          this.shadowMap.enabled = value;
        }
      },
      shadowMapType: {
        get: function() {
          return this.shadowMap.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
          this.shadowMap.type = value;
        }
      },
      shadowMapCullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      context: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
          return this.getContext();
        }
      },
      vr: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
          return this.xr;
        }
      },
      gammaInput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
      },
      gammaOutput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          return false;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
      },
      toneMappingWhitePoint: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          return 1;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
      }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
      cullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      renderReverseSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
      },
      renderSingleSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
      }
    });
    Object.defineProperties(WebGLRenderTarget.prototype, {
      wrapS: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          return this.texture.wrapS;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          this.texture.wrapS = value;
        }
      },
      wrapT: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          return this.texture.wrapT;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          this.texture.wrapT = value;
        }
      },
      magFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          return this.texture.magFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          this.texture.magFilter = value;
        }
      },
      minFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          return this.texture.minFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          this.texture.minFilter = value;
        }
      },
      anisotropy: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          return this.texture.anisotropy;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          this.texture.anisotropy = value;
        }
      },
      offset: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          return this.texture.offset;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          this.texture.offset = value;
        }
      },
      repeat: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          return this.texture.repeat;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          this.texture.repeat = value;
        }
      },
      format: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          return this.texture.format;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          this.texture.format = value;
        }
      },
      type: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          return this.texture.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          this.texture.type = value;
        }
      },
      generateMipmaps: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          return this.texture.generateMipmaps;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          this.texture.generateMipmaps = value;
        }
      }
    });
    Audio.prototype.load = function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    };
    AudioAnalyser.prototype.getData = function() {
      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
      return this.getFrequencyData();
    };
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
      return this.update(renderer, scene);
    };
    CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
      console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
      return this.renderTarget.clear(renderer, color, depth, stencil);
    };
    ImageUtils.crossOrigin = void 0;
    ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const loader = new TextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      const texture = loader.load(url, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const loader = new CubeTextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      const texture = loader.load(urls, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
        revision: REVISION
      } }));
    }
    if (typeof window !== "undefined") {
      if (window.__THREE__) {
        console.warn("WARNING: Multiple instances of Three.js being imported.");
      } else {
        window.__THREE__ = REVISION;
      }
    }
  
    // node_modules/three/src/core/EventDispatcher.js
    var EventDispatcher2 = class {
      addEventListener(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
      hasEventListener(type, listener) {
        if (this._listeners === void 0)
          return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      removeEventListener(type, listener) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index2 = listenerArray.indexOf(listener);
          if (index2 !== -1) {
            listenerArray.splice(index2, 1);
          }
        }
      }
      dispatchEvent(event2) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[event2.type];
        if (listenerArray !== void 0) {
          event2.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l = array.length; i2 < l; i2++) {
            array[i2].call(this, event2);
          }
          event2.target = null;
        }
      }
    };
  
    // node_modules/three/src/constants.js
    var UVMapping2 = 300;
    var RepeatWrapping2 = 1e3;
    var ClampToEdgeWrapping2 = 1001;
    var MirroredRepeatWrapping2 = 1002;
    var LinearFilter2 = 1006;
    var LinearMipmapLinearFilter2 = 1008;
    var UnsignedByteType2 = 1009;
    var RGBFormat2 = 1022;
    var RGBAFormat2 = 1023;
    var LinearEncoding2 = 3e3;
  
    // node_modules/three/src/math/MathUtils.js
    var DEG2RAD2 = Math.PI / 180;
    var RAD2DEG2 = 180 / Math.PI;
    var _lut2 = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _lut2[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
    }
    var hasRandomUUID2 = typeof crypto !== "undefined" && "randomUUID" in crypto;
    function generateUUID2() {
      if (hasRandomUUID2) {
        return crypto.randomUUID().toUpperCase();
      }
      const d0 = Math.random() * 4294967295 | 0;
      const d1 = Math.random() * 4294967295 | 0;
      const d2 = Math.random() * 4294967295 | 0;
      const d3 = Math.random() * 4294967295 | 0;
      const uuid = _lut2[d0 & 255] + _lut2[d0 >> 8 & 255] + _lut2[d0 >> 16 & 255] + _lut2[d0 >> 24 & 255] + "-" + _lut2[d1 & 255] + _lut2[d1 >> 8 & 255] + "-" + _lut2[d1 >> 16 & 15 | 64] + _lut2[d1 >> 24 & 255] + "-" + _lut2[d2 & 63 | 128] + _lut2[d2 >> 8 & 255] + "-" + _lut2[d2 >> 16 & 255] + _lut2[d2 >> 24 & 255] + _lut2[d3 & 255] + _lut2[d3 >> 8 & 255] + _lut2[d3 >> 16 & 255] + _lut2[d3 >> 24 & 255];
      return uuid.toUpperCase();
    }
    function clamp5(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    function mapLinear(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    }
  
    // node_modules/three/src/math/Vector2.js
    var Vector22 = class {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y) {
        this.y = y;
        return this;
      }
      setComponent(index2, value) {
        switch (index2) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      }
      getComponent(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index2);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y;
      }
      cross(v) {
        return this.x * v.y - this.y * v.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y;
      }
      fromArray(array, offset2 = 0) {
        this.x = array[offset2];
        this.y = array[offset2 + 1];
        return this;
      }
      toArray(array = [], offset2 = 0) {
        array[offset2] = this.x;
        array[offset2 + 1] = this.y;
        return array;
      }
      fromBufferAttribute(attribute, index2, offset2) {
        if (offset2 !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        return this;
      }
      rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    Vector22.prototype.isVector2 = true;
  
    // node_modules/three/src/math/Matrix3.js
    var Matrix32 = class {
      constructor() {
        this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
      setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
      multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      transpose() {
        let tmp2;
        const m = this.elements;
        tmp2 = m[1];
        m[1] = m[3];
        m[3] = tmp2;
        tmp2 = m[2];
        m[2] = m[6];
        m[6] = tmp2;
        tmp2 = m[5];
        m[5] = m[7];
        m[7] = tmp2;
        return this;
      }
      getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
      transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      }
      setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
      }
      scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      }
      rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
      }
      translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      }
      equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      }
      fromArray(array, offset2 = 0) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset2];
        }
        return this;
      }
      toArray(array = [], offset2 = 0) {
        const te = this.elements;
        array[offset2] = te[0];
        array[offset2 + 1] = te[1];
        array[offset2 + 2] = te[2];
        array[offset2 + 3] = te[3];
        array[offset2 + 4] = te[4];
        array[offset2 + 5] = te[5];
        array[offset2 + 6] = te[6];
        array[offset2 + 7] = te[7];
        array[offset2 + 8] = te[8];
        return array;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    };
    Matrix32.prototype.isMatrix3 = true;
  
    // node_modules/three/src/utils.js
    function createElementNS2(name) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", name);
    }
  
    // node_modules/three/src/extras/ImageUtils.js
    var _canvas2;
    var ImageUtils2 = class {
      static getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas2 === void 0)
            _canvas2 = createElementNS2("canvas");
          _canvas2.width = image.width;
          _canvas2.height = image.height;
          const context3 = _canvas2.getContext("2d");
          if (image instanceof ImageData) {
            context3.putImageData(image, 0, 0);
          } else {
            context3.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas2;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
    };
  
    // node_modules/three/src/textures/Texture.js
    var textureId2 = 0;
    var Texture2 = class extends EventDispatcher2 {
      constructor(image = Texture2.DEFAULT_IMAGE, mapping = Texture2.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping2, wrapT = ClampToEdgeWrapping2, magFilter = LinearFilter2, minFilter = LinearMipmapLinearFilter2, format = RGBAFormat2, type = UnsignedByteType2, anisotropy = 1, encoding = LinearEncoding2) {
        super();
        Object.defineProperty(this, "id", { value: textureId2++ });
        this.uuid = generateUUID2();
        this.name = "";
        this.image = image;
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector22(0, 0);
        this.repeat = new Vector22(1, 1);
        this.center = new Vector22(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix32();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (this.image !== void 0) {
          const image = this.image;
          if (image.uuid === void 0) {
            image.uuid = generateUUID2();
          }
          if (!isRootObject && meta.images[image.uuid] === void 0) {
            let url;
            if (Array.isArray(image)) {
              url = [];
              for (let i2 = 0, l = image.length; i2 < l; i2++) {
                if (image[i2].isDataTexture) {
                  url.push(serializeImage2(image[i2].image));
                } else {
                  url.push(serializeImage2(image[i2]));
                }
              }
            } else {
              url = serializeImage2(image);
            }
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url
            };
          }
          output.image = image.uuid;
        }
        if (JSON.stringify(this.userData) !== "{}")
          output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(uv) {
        if (this.mapping !== UVMapping2)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping2:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping2:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping2:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping2:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping2:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping2:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
    };
    Texture2.DEFAULT_IMAGE = void 0;
    Texture2.DEFAULT_MAPPING = UVMapping2;
    Texture2.prototype.isTexture = true;
    function serializeImage2(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        return ImageUtils2.getDataURL(image);
      } else {
        if (image.data) {
          return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
          };
        } else {
          console.warn("THREE.Texture: Unable to serialize Texture.");
          return {};
        }
      }
    }
  
    // node_modules/three/src/textures/CanvasTexture.js
    var CanvasTexture2 = class extends Texture2 {
      constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
      }
    };
    CanvasTexture2.prototype.isCanvasTexture = true;
  
    // node_modules/three/src/textures/VideoTexture.js
    var VideoTexture2 = class extends Texture2 {
      constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.format = format !== void 0 ? format : RGBFormat2;
        this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter2;
        this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter2;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
          scope.needsUpdate = true;
          video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) {
          video.requestVideoFrameCallback(updateVideo);
        }
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    };
    VideoTexture2.prototype.isVideoTexture = true;
  
    // assets/scripts/utils/webgl/getTexture.js
    var textureCache = {};
    var pixel = new Image();
    pixel.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
    function getTexture(image, params = {}) {
      let texture;
      if (image instanceof Image || image instanceof HTMLVideoElement || image instanceof HTMLCanvasElement) {
        if (image instanceof HTMLVideoElement)
          texture = new VideoTexture2(image);
        else if (image instanceof HTMLCanvasElement)
          texture = new CanvasTexture2(image);
        else
          texture = new Texture2(image);
        setParams(texture, params);
        return texture;
      } else {
        let texture2 = textureCache[image];
        if (texture2) {
          let needsUpdate = Object.keys(params).reduce(function(reduce, key, i2) {
            let value = params[key];
            return reduce || value != texture2[key];
          }, false);
          setParams(texture2, params);
          texture2.needsUpdate = true;
          return texture2;
        }
        let img = new Image();
        texture2 = new Texture2(pixel);
        textureCache[image] = texture2;
        texture2.needsUpdate = false;
        if (image.includes("d1oy1berrwa8q2.cloudfront")) {
          img.crossOrigin = "anonymous";
        }
        img.src = image;
        texture2.promise = new Promise((resolve, reject) => {
          img.onload = function() {
            img.onload = null;
            texture2.image = img;
            setParams(texture2, params);
            resolve(texture2);
          };
        });
        return texture2;
      }
    }
    function setParams(texture, params = {}) {
      Object.assign(texture, {
        minFilter: LinearFilter2,
        magFilter: LinearFilter2,
        wrapS: ClampToEdgeWrapping2,
        wrapT: ClampToEdgeWrapping2,
        generateMipmaps: false
      }, params);
      texture.needsUpdate = true;
    }
  
    // assets/scripts/experiences/mixins/commonSceneMethods.js
    var commonSceneMethods_default = commonSceneMethods = {
      createScene() {
        this.scene = new Scene();
      },
      createCamera(keepAspectRatio = false) {
        const frustumSize = 1;
        this.aspect = keepAspectRatio ? window.innerWidth / window.innerHeight : 1;
        this.camera = new OrthographicCamera(frustumSize * this.aspect / -2, frustumSize * this.aspect / 2, frustumSize / 2, frustumSize / -2, -1e3, 1e3);
        this.camera.position.set(0, 0, 2);
      },
      createRtTexture(options = {}, isMultisample = false) {
        const normalizedDpr = Math.min(window.devicePixelRatio, 2);
        if (isMultisample && isWebGL2Ready()) {
          this.rtTexture = new WebGLMultisampleRenderTarget(this.$el.offsetWidth * normalizedDpr, this.$el.offsetHeight * normalizedDpr, options);
        } else {
          this.rtTexture = new WebGLRenderTarget(this.$el.offsetWidth * normalizedDpr, this.$el.offsetHeight * normalizedDpr, options);
        }
      },
      resizeRtTexture(width, height) {
        const normalizedDpr = Math.min(window.devicePixelRatio, 2);
        this.rtTexture.setSize(width * normalizedDpr, height * normalizedDpr);
      }
    };
  
    // assets/scripts/experiences/mixins/commonSceneUniforms.js
    var commonSceneUniforms_default = commonUniforms = {
      setResolutionUniforms(width, height) {
        this.material.uniforms.uResolution.value = [width, height];
      },
      setTextureUniforms(texture, uniform) {
        const texWidth = texture.image.width;
        const texHeight = texture.image.height;
        this.material.uniforms[uniform].value = texture;
        this.material.uniforms[`${uniform}Resolution`].value = [texWidth, texHeight];
      }
    };
  
    // assets/scripts/experiences/mixins/finalSceneAnimations.js
    var import_bezier_easing = __toModule(require_src());
    var SMOOTH_EASING = (0, import_bezier_easing.default)(0.38, 5e-3, 0.215, 1);
    var POWER2_OUT = (0, import_bezier_easing.default)(0.215, 0.61, 0.355, 1);
    var finalSceneAnimations_default = finalSceneAnimations = {
      setTweens() {
        this.setMasterAnimation();
        this.setMaskAnimation();
        this.setNoiseAnimation();
        this.setTextAnimation();
      },
      resetTweensData() {
        this.masterAnimationData.progress = 0;
        this.holdAnimationData.value = this.maskData.idle;
        this.holdAnimationData.progress = 0;
        this.maskAnimationData.value = this.maskData.idle;
        this.maskAnimationData.progress = 0;
        this.noiseAnimationData.value = 0;
      },
      setMasterAnimation() {
        this.masterTween = gsapWithCSS2.to(this.masterAnimationData, {
          duration: this.masterAnimationData.duration,
          progress: this.masterAnimationData.target,
          ease: "linear",
          onUpdate: () => {
            this.onMasterAnimating(this.masterAnimationData.progress);
          },
          onComplete: this.completeMasterAnimation.bind(this),
          paused: true,
          immediateRender: false
        });
      },
      startMasterAnimation() {
        return new Promise((resolve) => {
          this.moduleInstance.hasHoldAvailable = false;
          this.masterTween.restart().then(() => {
            resolve();
          });
          this.animateDepthEndScale();
          let index2 = 0;
          while (index2 < this.moduleInstance.$navItems.length) {
            this.moduleInstance.$navItems[index2].classList.remove("is-active");
            index2++;
          }
        });
      },
      completeMasterAnimation() {
        this.textIndex++;
        if (this.textIndex >= this.moduleInstance.$navItems.length) {
          this.textIndex = 0;
        }
        if (typeof this.moduleInstance.$navItems[this.textIndex] !== "undefined") {
          this.moduleInstance.$navItems[this.textIndex].classList.add("is-active");
        }
        this.resetTweensData();
        this.revealText(this.textIndex);
        this.loadNextDepthMaps().then(() => {
          this.moduleInstance.hasHoldAvailable = true;
        });
      },
      onMasterAnimating(progress) {
        this.onMaskAnimating(progress);
      },
      setMaskAnimation() {
        this.maskTween = gsapWithCSS2.to(this.maskAnimationData, {
          progress: 1,
          ease: "linear",
          onStart: () => {
            this.hasChangeDepthTexture = false;
            this.tdateNow = Date.now();
          },
          onComplete: () => {
            this.hasChangeDepthTexture = false;
          },
          onUpdate: () => {
            var _a;
            const valueStart = this.holdAnimationData.targetIn;
            const valueEnd = 1 + this.maskData.idle;
            const easedValue = mapRange(0, 1, valueStart, valueEnd, POWER2_OUT(this.maskAnimationData.progress));
            const computedValue = (easedValue + 1) % 1;
            this.material.uniforms.uMaskProgress.value = computedValue;
            const maskOutProgress = clamp(0, 1, mapRange(this.maskData.idle, 1, 0, 1, easedValue));
            if (maskOutProgress > 0 && maskOutProgress < 1) {
              this.onMaskAnimatingOut(maskOutProgress);
            }
            const maskInProgress = clamp(0, 1, mapRange(1, 1 + this.maskData.idle, 0, 1, easedValue));
            if (maskInProgress > 0 && maskInProgress < 1) {
              this.onMaskAnimatingIn(maskInProgress);
            }
            if (easedValue >= 1 && !this.hasChangeDepthTexture) {
              this.hasChangeDepthTexture = true;
              (_a = this.updateDepthTextures) == null ? void 0 : _a.call(this);
            }
          },
          paused: true,
          immediateRender: false
        });
      },
      onMaskAnimating(progress) {
        this.maskTween.progress(progress);
      },
      onMaskAnimatingIn(progress) {
        this.noiseAppearTween.progress(progress);
      },
      onMaskAnimatingOut(progress) {
        this.noiseDisappearTween.progress(progress);
      },
      animateHoldDown(callback = () => {
      }) {
        var _a;
        (_a = this.holdTween) == null ? void 0 : _a.kill();
        const valueStart = this.holdAnimationData.value;
        this.holdTween = gsapWithCSS2.to(this.holdAnimationData, {
          duration: this.holdAnimationData.durationIn,
          progress: 1,
          ease: "linear",
          onUpdate: () => {
            const valueEnd = this.holdAnimationData.targetIn;
            const easedValue = mapRange(0, 1, valueStart, valueEnd, SMOOTH_EASING(this.holdAnimationData.progress));
            this.onHoldDownAnimating(this.holdAnimationData.progress);
            this.material.uniforms.uMaskProgress.value = easedValue;
            this.holdAnimationData.value = easedValue;
          },
          onComplete: callback
        });
      },
      animateHoldUp() {
        var _a;
        (_a = this.holdTween) == null ? void 0 : _a.kill();
        const valueStart = this.holdAnimationData.value;
        this.holdTween = gsapWithCSS2.to(this.holdAnimationData, {
          duration: this.holdAnimationData.durationOut,
          progress: 0,
          ease: "linear",
          onUpdate: () => {
            const valueEnd = this.holdAnimationData.targetOut;
            const easedValue = mapRange(1, 0, valueStart, valueEnd, POWER2_OUT(this.holdAnimationData.progress));
            this.onHoldUpAnimating(this.holdAnimationData.progress);
            this.material.uniforms.uMaskProgress.value = easedValue;
            this.holdAnimationData.value = easedValue;
          }
        });
      },
      onHoldDownAnimating(progress) {
        const textProgress = SMOOTH_EASING(progress);
        this.textDisappearTween.progress(textProgress);
      },
      onHoldUpAnimating(progress) {
        const textProgress = mapRange(1, 0, 0, 1, POWER2_OUT(progress));
        this.textAppearTween.progress(textProgress);
      },
      animateHoverEnter() {
        var _a;
        (_a = this.hoverTween) == null ? void 0 : _a.kill();
        this.hoverTween = gsapWithCSS2.to(this.hoverAnimationData, {
          duration: this.hoverAnimationData.durationIn,
          progress: 1,
          ease: "power2.out",
          onUpdate: () => {
            this.material.uniforms.uHoverProgress.value = this.hoverAnimationData.progress;
          }
        });
      },
      animateHoverLeave() {
        var _a;
        (_a = this.hoverTween) == null ? void 0 : _a.kill();
        this.hoverTween = gsapWithCSS2.to(this.hoverAnimationData, {
          duration: this.hoverAnimationData.durationOut,
          progress: 0,
          ease: "power2.out",
          onUpdate: () => {
            this.material.uniforms.uHoverProgress.value = this.hoverAnimationData.progress;
          }
        });
      },
      setNoiseAnimation() {
        this.noiseDisappearTween = gsapWithCSS2.fromTo(this.noiseAnimationData, {
          value: 1
        }, {
          value: 0,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
        this.noiseAppearTween = gsapWithCSS2.fromTo(this.noiseAnimationData, {
          value: 0
        }, {
          value: 1,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
      },
      setTextAnimation() {
        this.textDisappearTween = gsapWithCSS2.fromTo(this.textAnimationData, {
          value: 1
        }, {
          value: 0,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uTextOpacityProgress.value = this.textAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
        this.textAppearTween = gsapWithCSS2.fromTo(this.textAnimationData, {
          value: 0
        }, {
          value: 1,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uTextOpacityProgress.value = this.textAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
      },
      revealText(textIndex) {
        var _a;
        const textInstance = this.rtTexturesInstances.find((item) => item.id === "typo");
        if (textInstance) {
          (_a = textInstance == null ? void 0 : textInstance.reveal) == null ? void 0 : _a.call(textInstance, textIndex);
          requestAnimationFrame(() => {
            this.textAnimationData.value = 1;
            this.material.uniforms.uTextOpacityProgress.value = 1;
          });
        }
      },
      animateDepthEndScale() {
        gsapWithCSS2.fromTo(this.depthScaleAnimationData, {
          scaleValue: this.depthScaleAnimationData.scaleStart
        }, {
          scaleValue: this.depthScaleAnimationData.scaleEnd,
          duration: this.depthScaleAnimationData.scaleDuration,
          ease: "power4.out",
          onUpdate: () => {
            this.material.uniforms.uDepthScale.value = this.depthScaleAnimationData.scaleValue;
          },
          onComplete: () => {
            this.material.uniforms.uHasTextureSwapped.value = false;
            this.material.uniforms.uDepthScale.value = this.depthScaleAnimationData.scaleValue = this.depthScaleAnimationData.scaleStart;
          }
        });
      },
      revealFull() {
        const startScaleValue = 0;
        const endScaleValue = this.maskData.idle;
        const timeline2 = gsapWithCSS2.timeline({
          onUpdate: () => {
            const currentProgress = timeline2.progress();
            if (currentProgress > 0.9 && !this.isRevealed) {
              this.isRevealed = true;
              html.classList.add("has-intro-revealed");
            }
          },
          onComplete: () => {
            requestAnimationFrame(() => {
              this.moduleInstance.hasHoldAvailable = true;
              this.moduleInstance.call("start", null, "Scroll");
              html.classList.add("has-logo-revealed");
            });
          }
        });
        const portalProgress = {
          value: 0
        };
        timeline2.to(portalProgress, {
          value: 1,
          duration: 1.2,
          ease: "linear",
          onUpdate: () => {
            const easedValue = clamp(startScaleValue, endScaleValue, mapRange(0, 1, startScaleValue, endScaleValue, POWER2_OUT(portalProgress.value)));
            this.material.uniforms.uMaskProgress.value = easedValue;
          }
        });
        this.moduleInstance.call("animateLogo", {
          timeline: timeline2,
          delay: "-=0.5",
          callback: () => {
            this.diveAnimation();
          }
        }, "Logo");
      },
      revealMin() {
        const startScaleValue = 0;
        const endScaleValue = this.maskData.idle;
        this.isRevealed = true;
        html.classList.add("has-logo-revealed");
        html.classList.add("has-intro-revealed");
        const timeline2 = gsapWithCSS2.timeline({
          onComplete: () => {
            requestAnimationFrame(() => {
              this.moduleInstance.hasHoldAvailable = true;
              this.moduleInstance.call("start", null, "Scroll");
            });
          }
        });
        const portalProgress = {
          value: 0
        };
        timeline2.to(portalProgress, {
          value: 1,
          duration: 1.2,
          ease: "linear",
          onUpdate: () => {
            const easedValue = clamp(startScaleValue, endScaleValue, mapRange(0, 1, startScaleValue, endScaleValue, POWER2_OUT(portalProgress.value)));
            this.material.uniforms.uMaskProgress.value = easedValue;
          },
          onComplete: () => {
            this.diveAnimation();
          }
        }, "+=1");
      },
      diveAnimation() {
        this.moduleInstance.hasHoldAvailable = false;
        this.animateHoldDown(() => {
          this.holdUp(true);
          this.startMasterAnimation().then(() => {
            html.classList.add("has-experience-revealed");
            window.dispatchEvent(new CustomEvent("resetCursorBind"));
          });
        });
      }
    };
  
    // assets/scripts/experiences/mixins/finalSceneHoldMethods.js
    var finalSceneHoldMethods_default = finalSceneHoldMethods = {
      holdDown() {
        var _a;
        if (this.holdData.isHolding || !this.moduleInstance.hasHoldAvailable)
          return;
        this.holdData.baseTime = Date.now();
        this.holdData.isHolding = true;
        this.moduleInstance.call("holdDown", this.holdData.holdDuration, "Cursor");
        (_a = this.animateHoldDown) == null ? void 0 : _a.call(this);
      },
      holdUp(isComplete = false) {
        var _a;
        if (!this.holdData.isHolding || !this.moduleInstance.hasHoldAvailable)
          return;
        this.holdData.isHolding = false;
        this.moduleInstance.call("holdUp", this.holdData.holdDuration, "Cursor");
        if (!isComplete) {
          (_a = this.animateHoldUp) == null ? void 0 : _a.call(this);
        }
      },
      updateHold() {
        var _a;
        if (!this.holdData.isHolding)
          return;
        const dateNow = Date.now();
        const elapsedTime = dateNow - this.holdData.baseTime;
        if (elapsedTime > this.holdData.holdDuration) {
          this.holdUp(true);
          (_a = this.startMasterAnimation) == null ? void 0 : _a.call(this);
        }
      }
    };
  
    // assets/scripts/experiences/mixins/finalSceneUniforms.js
    var DEFAULT_PORTAL_CIRCLE_WIDTH = 288;
    var finalSceneUniforms_default = finalSceneUniforms = {
      setInitialUniforms() {
        this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
        this.material.uniforms.uTextOpacityProgress.value = this.textAnimationData.value;
        this.material.uniforms.uDepthScale.value = this.depthScaleAnimationData.scaleValue;
        this.material.uniforms.uDepthScaleStart.value = this.depthScaleAnimationData.scaleStart;
        this.material.uniforms.uHasTextureSwapped.value = false;
      },
      setRTTextureUniforms(uniform, texture) {
        this.material.uniforms[uniform].value = texture;
      },
      setMaskIdleUniforms() {
        const idle = Math.round((1 / this.maskData.maxScale + Number.EPSILON) * 100) / 100;
        this.maskData.idle = this.material.uniforms.uMaskIdle.value = idle;
      },
      setMaskProgressUniforms() {
        if (this.isRevealed) {
          this.material.uniforms.uMaskProgress.value = this.maskData.idle;
        }
      },
      setMaxMaskScaleUniforms(maskTextureScale) {
        const canvasWidth = this.$el.offsetWidth;
        const canvasHeight = this.$el.offsetHeight;
        const circleWidth = DEFAULT_PORTAL_CIRCLE_WIDTH * maskTextureScale;
        const pythA = canvasHeight / 2;
        const pythB = canvasWidth / 2;
        const hypot = Math.hypot(pythA, pythB);
        const originalScale = hypot / circleWidth * 2;
        const roundedScale = Math.round((originalScale + Number.EPSILON) * 100) / 100;
        this.material.uniforms.uMaxMaskScale.value = roundedScale;
        return roundedScale;
      }
    };
  
    // node_modules/three/examples/jsm/shaders/CopyShader.js
    var CopyShader = {
      uniforms: {
        "tDiffuse": { value: null },
        "opacity": { value: 1 }
      },
      vertexShader: `
  
          varying vec2 vUv;
  
          void main() {
  
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
          }`,
      fragmentShader: `
  
          uniform float opacity;
  
          uniform sampler2D tDiffuse;
  
          varying vec2 vUv;
  
          void main() {
  
              vec4 texel = texture2D( tDiffuse, vUv );
              gl_FragColor = opacity * texel;
  
          }`
    };
  
    // node_modules/three/examples/jsm/postprocessing/Pass.js
    var Pass = class {
      constructor() {
        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;
        this.renderToScreen = false;
      }
      setSize() {
      }
      render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
      }
    };
    var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var _geometry2 = new BufferGeometry();
    _geometry2.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    _geometry2.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    var FullScreenQuad = class {
      constructor(material) {
        this._mesh = new Mesh(_geometry2, material);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(renderer) {
        renderer.render(this._mesh, _camera);
      }
      get material() {
        return this._mesh.material;
      }
      set material(value) {
        this._mesh.material = value;
      }
    };
  
    // node_modules/three/examples/jsm/postprocessing/ShaderPass.js
    var ShaderPass = class extends Pass {
      constructor(shader, textureID) {
        super();
        this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
        if (shader instanceof ShaderMaterial) {
          this.uniforms = shader.uniforms;
          this.material = shader;
        } else if (shader) {
          this.uniforms = UniformsUtils.clone(shader.uniforms);
          this.material = new ShaderMaterial({
            defines: Object.assign({}, shader.defines),
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          });
        }
        this.fsQuad = new FullScreenQuad(this.material);
      }
      render(renderer, writeBuffer, readBuffer) {
        if (this.uniforms[this.textureID]) {
          this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(writeBuffer);
          if (this.clear)
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          this.fsQuad.render(renderer);
        }
      }
    };
  
    // node_modules/three/examples/jsm/postprocessing/MaskPass.js
    var MaskPass = class extends Pass {
      constructor(scene, camera) {
        super();
        this.scene = scene;
        this.camera = camera;
        this.clear = true;
        this.needsSwap = false;
        this.inverse = false;
      }
      render(renderer, writeBuffer, readBuffer) {
        const context3 = renderer.getContext();
        const state = renderer.state;
        state.buffers.color.setMask(false);
        state.buffers.depth.setMask(false);
        state.buffers.color.setLocked(true);
        state.buffers.depth.setLocked(true);
        let writeValue, clearValue;
        if (this.inverse) {
          writeValue = 0;
          clearValue = 1;
        } else {
          writeValue = 1;
          clearValue = 0;
        }
        state.buffers.stencil.setTest(true);
        state.buffers.stencil.setOp(context3.REPLACE, context3.REPLACE, context3.REPLACE);
        state.buffers.stencil.setFunc(context3.ALWAYS, writeValue, 4294967295);
        state.buffers.stencil.setClear(clearValue);
        state.buffers.stencil.setLocked(true);
        renderer.setRenderTarget(readBuffer);
        if (this.clear)
          renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(writeBuffer);
        if (this.clear)
          renderer.clear();
        renderer.render(this.scene, this.camera);
        state.buffers.color.setLocked(false);
        state.buffers.depth.setLocked(false);
        state.buffers.stencil.setLocked(false);
        state.buffers.stencil.setFunc(context3.EQUAL, 1, 4294967295);
        state.buffers.stencil.setOp(context3.KEEP, context3.KEEP, context3.KEEP);
        state.buffers.stencil.setLocked(true);
      }
    };
    var ClearMaskPass = class extends Pass {
      constructor() {
        super();
        this.needsSwap = false;
      }
      render(renderer) {
        renderer.state.buffers.stencil.setLocked(false);
        renderer.state.buffers.stencil.setTest(false);
      }
    };
  
    // node_modules/three/examples/jsm/postprocessing/EffectComposer.js
    var EffectComposer = class {
      constructor(renderer, renderTarget) {
        this.renderer = renderer;
        if (renderTarget === void 0) {
          const parameters = {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            format: RGBAFormat
          };
          const size = renderer.getSize(new Vector2());
          this._pixelRatio = renderer.getPixelRatio();
          this._width = size.width;
          this._height = size.height;
          renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
          renderTarget.texture.name = "EffectComposer.rt1";
        } else {
          this._pixelRatio = 1;
          this._width = renderTarget.width;
          this._height = renderTarget.height;
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.renderTarget2.texture.name = "EffectComposer.rt2";
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
        this.renderToScreen = true;
        this.passes = [];
        if (CopyShader === void 0) {
          console.error("THREE.EffectComposer relies on CopyShader");
        }
        if (ShaderPass === void 0) {
          console.error("THREE.EffectComposer relies on ShaderPass");
        }
        this.copyPass = new ShaderPass(CopyShader);
        this.clock = new Clock();
      }
      swapBuffers() {
        const tmp2 = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp2;
      }
      addPass(pass) {
        this.passes.push(pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      insertPass(pass, index2) {
        this.passes.splice(index2, 0, pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      removePass(pass) {
        const index2 = this.passes.indexOf(pass);
        if (index2 !== -1) {
          this.passes.splice(index2, 1);
        }
      }
      isLastEnabledPass(passIndex) {
        for (let i2 = passIndex + 1; i2 < this.passes.length; i2++) {
          if (this.passes[i2].enabled) {
            return false;
          }
        }
        return true;
      }
      render(deltaTime) {
        if (deltaTime === void 0) {
          deltaTime = this.clock.getDelta();
        }
        const currentRenderTarget = this.renderer.getRenderTarget();
        let maskActive = false;
        for (let i2 = 0, il = this.passes.length; i2 < il; i2++) {
          const pass = this.passes[i2];
          if (pass.enabled === false)
            continue;
          pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i2);
          pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
          if (pass.needsSwap) {
            if (maskActive) {
              const context3 = this.renderer.getContext();
              const stencil = this.renderer.state.buffers.stencil;
              stencil.setFunc(context3.NOTEQUAL, 1, 4294967295);
              this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
              stencil.setFunc(context3.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          if (MaskPass !== void 0) {
            if (pass instanceof MaskPass) {
              maskActive = true;
            } else if (pass instanceof ClearMaskPass) {
              maskActive = false;
            }
          }
        }
        this.renderer.setRenderTarget(currentRenderTarget);
      }
      reset(renderTarget) {
        if (renderTarget === void 0) {
          const size = this.renderer.getSize(new Vector2());
          this._pixelRatio = this.renderer.getPixelRatio();
          this._width = size.width;
          this._height = size.height;
          renderTarget = this.renderTarget1.clone();
          renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
      }
      setSize(width, height) {
        this._width = width;
        this._height = height;
        const effectiveWidth = this._width * this._pixelRatio;
        const effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
        for (let i2 = 0; i2 < this.passes.length; i2++) {
          this.passes[i2].setSize(effectiveWidth, effectiveHeight);
        }
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
      }
    };
    var _camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var _geometry3 = new BufferGeometry();
    _geometry3.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    _geometry3.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  
    // node_modules/three/examples/jsm/postprocessing/RenderPass.js
    var RenderPass = class extends Pass {
      constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
        super();
        this.scene = scene;
        this.camera = camera;
        this.overrideMaterial = overrideMaterial;
        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
        this.clear = true;
        this.clearDepth = false;
        this.needsSwap = false;
        this._oldClearColor = new Color();
      }
      render(renderer, writeBuffer, readBuffer) {
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        let oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== void 0) {
          oldOverrideMaterial = this.scene.overrideMaterial;
          this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor) {
          renderer.getClearColor(this._oldClearColor);
          oldClearAlpha = renderer.getClearAlpha();
          renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) {
          renderer.clearDepth();
        }
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
        if (this.clear)
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        renderer.render(this.scene, this.camera);
        if (this.clearColor) {
          renderer.setClearColor(this._oldClearColor, oldClearAlpha);
        }
        if (this.overrideMaterial !== void 0) {
          this.scene.overrideMaterial = oldOverrideMaterial;
        }
        renderer.autoClear = oldAutoClear;
      }
    };
  
    // node_modules/three/examples/jsm/shaders/FXAAShader.js
    var FXAAShader = {
      uniforms: {
        "tDiffuse": { value: null },
        "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
      },
      vertexShader: `
  
          varying vec2 vUv;
  
          void main() {
  
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
          }`,
      fragmentShader: `
  
          precision highp float;
  
          uniform sampler2D tDiffuse;
  
          uniform vec2 resolution;
  
          varying vec2 vUv;
  
          #define FXAA_PC 1
          #define FXAA_GLSL_100 1
          #define FXAA_QUALITY_PRESET 12
  
          #define FXAA_GREEN_AS_LUMA 1
  
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_PC_CONSOLE
                  //
                  // The console algorithm for PC is included
                  // for developers targeting really low spec machines.
                  // Likely better to just run FXAA_PC, and use a really low preset.
                  //
                  #define FXAA_PC_CONSOLE 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_GLSL_120
                  #define FXAA_GLSL_120 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_GLSL_130
                  #define FXAA_GLSL_130 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_HLSL_3
                  #define FXAA_HLSL_3 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_HLSL_4
                  #define FXAA_HLSL_4 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_HLSL_5
                  #define FXAA_HLSL_5 0
          #endif
          /*==========================================================================*/
          #ifndef FXAA_GREEN_AS_LUMA
                  //
                  // For those using non-linear color,
                  // and either not able to get luma in alpha, or not wanting to,
                  // this enables FXAA to run using green as a proxy for luma.
                  // So with this enabled, no need to pack luma in alpha.
                  //
                  // This will turn off AA on anything which lacks some amount of green.
                  // Pure red and blue or combination of only R and B, will get no AA.
                  //
                  // Might want to lower the settings for both,
                  //		fxaaConsoleEdgeThresholdMin
                  //		fxaaQualityEdgeThresholdMin
                  // In order to insure AA does not get turned off on colors
                  // which contain a minor amount of green.
                  //
                  // 1 = On.
                  // 0 = Off.
                  //
                  #define FXAA_GREEN_AS_LUMA 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_EARLY_EXIT
                  //
                  // Controls algorithm's early exit path.
                  // On PS3 turning this ON adds 2 cycles to the shader.
                  // On 360 turning this OFF adds 10ths of a millisecond to the shader.
                  // Turning this off on console will result in a more blurry image.
                  // So this defaults to on.
                  //
                  // 1 = On.
                  // 0 = Off.
                  //
                  #define FXAA_EARLY_EXIT 1
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_DISCARD
                  //
                  // Only valid for PC OpenGL currently.
                  // Probably will not work when FXAA_GREEN_AS_LUMA = 1.
                  //
                  // 1 = Use discard on pixels which don't need AA.
                  //		 For APIs which enable concurrent TEX+ROP from same surface.
                  // 0 = Return unchanged color on pixels which don't need AA.
                  //
                  #define FXAA_DISCARD 0
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_FAST_PIXEL_OFFSET
                  //
                  // Used for GLSL 120 only.
                  //
                  // 1 = GL API supports fast pixel offsets
                  // 0 = do not use fast pixel offsets
                  //
                  #ifdef GL_EXT_gpu_shader4
                          #define FXAA_FAST_PIXEL_OFFSET 1
                  #endif
                  #ifdef GL_NV_gpu_shader5
                          #define FXAA_FAST_PIXEL_OFFSET 1
                  #endif
                  #ifdef GL_ARB_gpu_shader5
                          #define FXAA_FAST_PIXEL_OFFSET 1
                  #endif
                  #ifndef FXAA_FAST_PIXEL_OFFSET
                          #define FXAA_FAST_PIXEL_OFFSET 0
                  #endif
          #endif
          /*--------------------------------------------------------------------------*/
          #ifndef FXAA_GATHER4_ALPHA
                  //
                  // 1 = API supports gather4 on alpha channel.
                  // 0 = API does not support gather4 on alpha channel.
                  //
                  #if (FXAA_HLSL_5 == 1)
                          #define FXAA_GATHER4_ALPHA 1
                  #endif
                  #ifdef GL_ARB_gpu_shader5
                          #define FXAA_GATHER4_ALPHA 1
                  #endif
                  #ifdef GL_NV_gpu_shader5
                          #define FXAA_GATHER4_ALPHA 1
                  #endif
                  #ifndef FXAA_GATHER4_ALPHA
                          #define FXAA_GATHER4_ALPHA 0
                  #endif
          #endif
  
  
          /*============================================================================
                                                          FXAA QUALITY - TUNING KNOBS
          ------------------------------------------------------------------------------
          NOTE the other tuning knobs are now in the shader function inputs!
          ============================================================================*/
          #ifndef FXAA_QUALITY_PRESET
                  //
                  // Choose the quality preset.
                  // This needs to be compiled into the shader as it effects code.
                  // Best option to include multiple presets is to
                  // in each shader define the preset, then include this file.
                  //
                  // OPTIONS
                  // -----------------------------------------------------------------------
                  // 10 to 15 - default medium dither (10=fastest, 15=highest quality)
                  // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
                  // 39			 - no dither, very expensive
                  //
                  // NOTES
                  // -----------------------------------------------------------------------
                  // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
                  // 13 = about same speed as FXAA 3.9 and better than 12
                  // 23 = closest to FXAA 3.9 visually and performance wise
                  //	_ = the lowest digit is directly related to performance
                  // _	= the highest digit is directly related to style
                  //
                  #define FXAA_QUALITY_PRESET 12
          #endif
  
  
          /*============================================================================
  
                                                               FXAA QUALITY - PRESETS
  
          ============================================================================*/
  
          /*============================================================================
                                                   FXAA QUALITY - MEDIUM DITHER PRESETS
          ============================================================================*/
          #if (FXAA_QUALITY_PRESET == 10)
                  #define FXAA_QUALITY_PS 3
                  #define FXAA_QUALITY_P0 1.5
                  #define FXAA_QUALITY_P1 3.0
                  #define FXAA_QUALITY_P2 12.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 11)
                  #define FXAA_QUALITY_PS 4
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 3.0
                  #define FXAA_QUALITY_P3 12.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 12)
                  #define FXAA_QUALITY_PS 5
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 4.0
                  #define FXAA_QUALITY_P4 12.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 13)
                  #define FXAA_QUALITY_PS 6
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 4.0
                  #define FXAA_QUALITY_P5 12.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 14)
                  #define FXAA_QUALITY_PS 7
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 4.0
                  #define FXAA_QUALITY_P6 12.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 15)
                  #define FXAA_QUALITY_PS 8
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 4.0
                  #define FXAA_QUALITY_P7 12.0
          #endif
  
          /*============================================================================
                                                   FXAA QUALITY - LOW DITHER PRESETS
          ============================================================================*/
          #if (FXAA_QUALITY_PRESET == 20)
                  #define FXAA_QUALITY_PS 3
                  #define FXAA_QUALITY_P0 1.5
                  #define FXAA_QUALITY_P1 2.0
                  #define FXAA_QUALITY_P2 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 21)
                  #define FXAA_QUALITY_PS 4
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 22)
                  #define FXAA_QUALITY_PS 5
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 23)
                  #define FXAA_QUALITY_PS 6
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 24)
                  #define FXAA_QUALITY_PS 7
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 3.0
                  #define FXAA_QUALITY_P6 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 25)
                  #define FXAA_QUALITY_PS 8
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 4.0
                  #define FXAA_QUALITY_P7 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 26)
                  #define FXAA_QUALITY_PS 9
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 2.0
                  #define FXAA_QUALITY_P7 4.0
                  #define FXAA_QUALITY_P8 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 27)
                  #define FXAA_QUALITY_PS 10
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 2.0
                  #define FXAA_QUALITY_P7 2.0
                  #define FXAA_QUALITY_P8 4.0
                  #define FXAA_QUALITY_P9 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 28)
                  #define FXAA_QUALITY_PS 11
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 2.0
                  #define FXAA_QUALITY_P7 2.0
                  #define FXAA_QUALITY_P8 2.0
                  #define FXAA_QUALITY_P9 4.0
                  #define FXAA_QUALITY_P10 8.0
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_QUALITY_PRESET == 29)
                  #define FXAA_QUALITY_PS 12
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.5
                  #define FXAA_QUALITY_P2 2.0
                  #define FXAA_QUALITY_P3 2.0
                  #define FXAA_QUALITY_P4 2.0
                  #define FXAA_QUALITY_P5 2.0
                  #define FXAA_QUALITY_P6 2.0
                  #define FXAA_QUALITY_P7 2.0
                  #define FXAA_QUALITY_P8 2.0
                  #define FXAA_QUALITY_P9 2.0
                  #define FXAA_QUALITY_P10 4.0
                  #define FXAA_QUALITY_P11 8.0
          #endif
  
          /*============================================================================
                                                   FXAA QUALITY - EXTREME QUALITY
          ============================================================================*/
          #if (FXAA_QUALITY_PRESET == 39)
                  #define FXAA_QUALITY_PS 12
                  #define FXAA_QUALITY_P0 1.0
                  #define FXAA_QUALITY_P1 1.0
                  #define FXAA_QUALITY_P2 1.0
                  #define FXAA_QUALITY_P3 1.0
                  #define FXAA_QUALITY_P4 1.0
                  #define FXAA_QUALITY_P5 1.5
                  #define FXAA_QUALITY_P6 2.0
                  #define FXAA_QUALITY_P7 2.0
                  #define FXAA_QUALITY_P8 2.0
                  #define FXAA_QUALITY_P9 2.0
                  #define FXAA_QUALITY_P10 4.0
                  #define FXAA_QUALITY_P11 8.0
          #endif
  
  
  
          /*============================================================================
  
                                                                          API PORTING
  
          ============================================================================*/
          #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
                  #define FxaaBool bool
                  #define FxaaDiscard discard
                  #define FxaaFloat float
                  #define FxaaFloat2 vec2
                  #define FxaaFloat3 vec3
                  #define FxaaFloat4 vec4
                  #define FxaaHalf float
                  #define FxaaHalf2 vec2
                  #define FxaaHalf3 vec3
                  #define FxaaHalf4 vec4
                  #define FxaaInt2 ivec2
                  #define FxaaSat(x) clamp(x, 0.0, 1.0)
                  #define FxaaTex sampler2D
          #else
                  #define FxaaBool bool
                  #define FxaaDiscard clip(-1)
                  #define FxaaFloat float
                  #define FxaaFloat2 float2
                  #define FxaaFloat3 float3
                  #define FxaaFloat4 float4
                  #define FxaaHalf half
                  #define FxaaHalf2 half2
                  #define FxaaHalf3 half3
                  #define FxaaHalf4 half4
                  #define FxaaSat(x) saturate(x)
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_GLSL_100 == 1)
              #define FxaaTexTop(t, p) texture2D(t, p, 0.0)
              #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_GLSL_120 == 1)
                  // Requires,
                  //	#version 120
                  // And at least,
                  //	#extension GL_EXT_gpu_shader4 : enable
                  //	(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
                  #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
                  #if (FXAA_FAST_PIXEL_OFFSET == 1)
                          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
                  #else
                          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
                  #endif
                  #if (FXAA_GATHER4_ALPHA == 1)
                          // use #extension GL_ARB_gpu_shader5 : enable
                          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
                          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
                          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)
                          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
                  #endif
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_GLSL_130 == 1)
                  // Requires "#version 130" or better
                  #define FxaaTexTop(t, p) textureLod(t, p, 0.0)
                  #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
                  #if (FXAA_GATHER4_ALPHA == 1)
                          // use #extension GL_ARB_gpu_shader5 : enable
                          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
                          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
                          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)
                          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
                  #endif
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_HLSL_3 == 1)
                  #define FxaaInt2 float2
                  #define FxaaTex sampler2D
                  #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
                  #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_HLSL_4 == 1)
                  #define FxaaInt2 int2
                  struct FxaaTex { SamplerState smpl; Texture2D tex; };
                  #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
                  #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
          #endif
          /*--------------------------------------------------------------------------*/
          #if (FXAA_HLSL_5 == 1)
                  #define FxaaInt2 int2
                  struct FxaaTex { SamplerState smpl; Texture2D tex; };
                  #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
                  #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
                  #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
                  #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
                  #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
                  #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
          #endif
  
  
          /*============================================================================
                                               GREEN AS LUMA OPTION SUPPORT FUNCTION
          ============================================================================*/
          #if (FXAA_GREEN_AS_LUMA == 0)
                  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
          #else
                  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
          #endif
  
  
  
  
          /*============================================================================
  
                                                                   FXAA3 QUALITY - PC
  
          ============================================================================*/
          #if (FXAA_PC == 1)
          /*--------------------------------------------------------------------------*/
          FxaaFloat4 FxaaPixelShader(
                  //
                  // Use noperspective interpolation here (turn off perspective interpolation).
                  // {xy} = center of pixel
                  FxaaFloat2 pos,
                  //
                  // Used only for FXAA Console, and not used on the 360 version.
                  // Use noperspective interpolation here (turn off perspective interpolation).
                  // {xy_} = upper left of pixel
                  // {_zw} = lower right of pixel
                  FxaaFloat4 fxaaConsolePosPos,
                  //
                  // Input color texture.
                  // {rgb_} = color in linear or perceptual color space
                  // if (FXAA_GREEN_AS_LUMA == 0)
                  //		 {__a} = luma in perceptual color space (not linear)
                  FxaaTex tex,
                  //
                  // Only used on the optimized 360 version of FXAA Console.
                  // For everything but 360, just use the same input here as for "tex".
                  // For 360, same texture, just alias with a 2nd sampler.
                  // This sampler needs to have an exponent bias of -1.
                  FxaaTex fxaaConsole360TexExpBiasNegOne,
                  //
                  // Only used on the optimized 360 version of FXAA Console.
                  // For everything but 360, just use the same input here as for "tex".
                  // For 360, same texture, just alias with a 3nd sampler.
                  // This sampler needs to have an exponent bias of -2.
                  FxaaTex fxaaConsole360TexExpBiasNegTwo,
                  //
                  // Only used on FXAA Quality.
                  // This must be from a constant/uniform.
                  // {x_} = 1.0/screenWidthInPixels
                  // {_y} = 1.0/screenHeightInPixels
                  FxaaFloat2 fxaaQualityRcpFrame,
                  //
                  // Only used on FXAA Console.
                  // This must be from a constant/uniform.
                  // This effects sub-pixel AA quality and inversely sharpness.
                  //	 Where N ranges between,
                  //		 N = 0.50 (default)
                  //		 N = 0.33 (sharper)
                  // {x__} = -N/screenWidthInPixels
                  // {_y_} = -N/screenHeightInPixels
                  // {_z_} =	N/screenWidthInPixels
                  // {__w} =	N/screenHeightInPixels
                  FxaaFloat4 fxaaConsoleRcpFrameOpt,
                  //
                  // Only used on FXAA Console.
                  // Not used on 360, but used on PS3 and PC.
                  // This must be from a constant/uniform.
                  // {x__} = -2.0/screenWidthInPixels
                  // {_y_} = -2.0/screenHeightInPixels
                  // {_z_} =	2.0/screenWidthInPixels
                  // {__w} =	2.0/screenHeightInPixels
                  FxaaFloat4 fxaaConsoleRcpFrameOpt2,
                  //
                  // Only used on FXAA Console.
                  // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
                  // This must be from a constant/uniform.
                  // {x__} =	8.0/screenWidthInPixels
                  // {_y_} =	8.0/screenHeightInPixels
                  // {_z_} = -4.0/screenWidthInPixels
                  // {__w} = -4.0/screenHeightInPixels
                  FxaaFloat4 fxaaConsole360RcpFrameOpt2,
                  //
                  // Only used on FXAA Quality.
                  // This used to be the FXAA_QUALITY_SUBPIX define.
                  // It is here now to allow easier tuning.
                  // Choose the amount of sub-pixel aliasing removal.
                  // This can effect sharpness.
                  //	 1.00 - upper limit (softer)
                  //	 0.75 - default amount of filtering
                  //	 0.50 - lower limit (sharper, less sub-pixel aliasing removal)
                  //	 0.25 - almost off
                  //	 0.00 - completely off
                  FxaaFloat fxaaQualitySubpix,
                  //
                  // Only used on FXAA Quality.
                  // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
                  // It is here now to allow easier tuning.
                  // The minimum amount of local contrast required to apply algorithm.
                  //	 0.333 - too little (faster)
                  //	 0.250 - low quality
                  //	 0.166 - default
                  //	 0.125 - high quality
                  //	 0.063 - overkill (slower)
                  FxaaFloat fxaaQualityEdgeThreshold,
                  //
                  // Only used on FXAA Quality.
                  // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
                  // It is here now to allow easier tuning.
                  // Trims the algorithm from processing darks.
                  //	 0.0833 - upper limit (default, the start of visible unfiltered edges)
                  //	 0.0625 - high quality (faster)
                  //	 0.0312 - visible limit (slower)
                  // Special notes when using FXAA_GREEN_AS_LUMA,
                  //	 Likely want to set this to zero.
                  //	 As colors that are mostly not-green
                  //	 will appear very dark in the green channel!
                  //	 Tune by looking at mostly non-green content,
                  //	 then start at zero and increase until aliasing is a problem.
                  FxaaFloat fxaaQualityEdgeThresholdMin,
                  //
                  // Only used on FXAA Console.
                  // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.
                  // It is here now to allow easier tuning.
                  // This does not effect PS3, as this needs to be compiled in.
                  //	 Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.
                  //	 Due to the PS3 being ALU bound,
                  //	 there are only three safe values here: 2 and 4 and 8.
                  //	 These options use the shaders ability to a free *|/ by 2|4|8.
                  // For all other platforms can be a non-power of two.
                  //	 8.0 is sharper (default!!!)
                  //	 4.0 is softer
                  //	 2.0 is really soft (good only for vector graphics inputs)
                  FxaaFloat fxaaConsoleEdgeSharpness,
                  //
                  // Only used on FXAA Console.
                  // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.
                  // It is here now to allow easier tuning.
                  // This does not effect PS3, as this needs to be compiled in.
                  //	 Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.
                  //	 Due to the PS3 being ALU bound,
                  //	 there are only two safe values here: 1/4 and 1/8.
                  //	 These options use the shaders ability to a free *|/ by 2|4|8.
                  // The console setting has a different mapping than the quality setting.
                  // Other platforms can use other values.
                  //	 0.125 leaves less aliasing, but is softer (default!!!)
                  //	 0.25 leaves more aliasing, and is sharper
                  FxaaFloat fxaaConsoleEdgeThreshold,
                  //
                  // Only used on FXAA Console.
                  // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.
                  // It is here now to allow easier tuning.
                  // Trims the algorithm from processing darks.
                  // The console setting has a different mapping than the quality setting.
                  // This only applies when FXAA_EARLY_EXIT is 1.
                  // This does not apply to PS3,
                  // PS3 was simplified to avoid more shader instructions.
                  //	 0.06 - faster but more aliasing in darks
                  //	 0.05 - default
                  //	 0.04 - slower and less aliasing in darks
                  // Special notes when using FXAA_GREEN_AS_LUMA,
                  //	 Likely want to set this to zero.
                  //	 As colors that are mostly not-green
                  //	 will appear very dark in the green channel!
                  //	 Tune by looking at mostly non-green content,
                  //	 then start at zero and increase until aliasing is a problem.
                  FxaaFloat fxaaConsoleEdgeThresholdMin,
                  //
                  // Extra constants for 360 FXAA Console only.
                  // Use zeros or anything else for other platforms.
                  // These must be in physical constant registers and NOT immediates.
                  // Immediates will result in compiler un-optimizing.
                  // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
                  FxaaFloat4 fxaaConsole360ConstDir
          ) {
          /*--------------------------------------------------------------------------*/
                  FxaaFloat2 posM;
                  posM.x = pos.x;
                  posM.y = pos.y;
                  #if (FXAA_GATHER4_ALPHA == 1)
                          #if (FXAA_DISCARD == 0)
                                  FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
                                  #if (FXAA_GREEN_AS_LUMA == 0)
                                          #define lumaM rgbyM.w
                                  #else
                                          #define lumaM rgbyM.y
                                  #endif
                          #endif
                          #if (FXAA_GREEN_AS_LUMA == 0)
                                  FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
                                  FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
                          #else
                                  FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
                                  FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
                          #endif
                          #if (FXAA_DISCARD == 1)
                                  #define lumaM luma4A.w
                          #endif
                          #define lumaE luma4A.z
                          #define lumaS luma4A.x
                          #define lumaSE luma4A.y
                          #define lumaNW luma4B.w
                          #define lumaN luma4B.z
                          #define lumaW luma4B.x
                  #else
                          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
                          #if (FXAA_GREEN_AS_LUMA == 0)
                                  #define lumaM rgbyM.w
                          #else
                                  #define lumaM rgbyM.y
                          #endif
                          #if (FXAA_GLSL_100 == 1)
                              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
                          #else
                              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
                          #endif
                  #endif
          /*--------------------------------------------------------------------------*/
                  FxaaFloat maxSM = max(lumaS, lumaM);
                  FxaaFloat minSM = min(lumaS, lumaM);
                  FxaaFloat maxESM = max(lumaE, maxSM);
                  FxaaFloat minESM = min(lumaE, minSM);
                  FxaaFloat maxWN = max(lumaN, lumaW);
                  FxaaFloat minWN = min(lumaN, lumaW);
                  FxaaFloat rangeMax = max(maxWN, maxESM);
                  FxaaFloat rangeMin = min(minWN, minESM);
                  FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
                  FxaaFloat range = rangeMax - rangeMin;
                  FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
                  FxaaBool earlyExit = range < rangeMaxClamped;
          /*--------------------------------------------------------------------------*/
                  if(earlyExit)
                          #if (FXAA_DISCARD == 1)
                                  FxaaDiscard;
                          #else
                                  return rgbyM;
                          #endif
          /*--------------------------------------------------------------------------*/
                  #if (FXAA_GATHER4_ALPHA == 0)
                          #if (FXAA_GLSL_100 == 1)
                              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
                          #else
                              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
                              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
                          #endif
                  #else
                          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
                          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
                  #endif
          /*--------------------------------------------------------------------------*/
                  FxaaFloat lumaNS = lumaN + lumaS;
                  FxaaFloat lumaWE = lumaW + lumaE;
                  FxaaFloat subpixRcpRange = 1.0/range;
                  FxaaFloat subpixNSWE = lumaNS + lumaWE;
                  FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
                  FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat lumaNESE = lumaNE + lumaSE;
                  FxaaFloat lumaNWNE = lumaNW + lumaNE;
                  FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
                  FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat lumaNWSW = lumaNW + lumaSW;
                  FxaaFloat lumaSWSE = lumaSW + lumaSE;
                  FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
                  FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
                  FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
                  FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
                  FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
                  FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
                  FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
                  FxaaBool horzSpan = edgeHorz >= edgeVert;
                  FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
          /*--------------------------------------------------------------------------*/
                  if(!horzSpan) lumaN = lumaW;
                  if(!horzSpan) lumaS = lumaE;
                  if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
                  FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat gradientN = lumaN - lumaM;
                  FxaaFloat gradientS = lumaS - lumaM;
                  FxaaFloat lumaNN = lumaN + lumaM;
                  FxaaFloat lumaSS = lumaS + lumaM;
                  FxaaBool pairN = abs(gradientN) >= abs(gradientS);
                  FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
                  if(pairN) lengthSign = -lengthSign;
                  FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
          /*--------------------------------------------------------------------------*/
                  FxaaFloat2 posB;
                  posB.x = posM.x;
                  posB.y = posM.y;
                  FxaaFloat2 offNP;
                  offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
                  offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
                  if(!horzSpan) posB.x += lengthSign * 0.5;
                  if( horzSpan) posB.y += lengthSign * 0.5;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat2 posN;
                  posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
                  posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
                  FxaaFloat2 posP;
                  posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
                  posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
                  FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
                  FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
                  FxaaFloat subpixE = subpixC * subpixC;
                  FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
          /*--------------------------------------------------------------------------*/
                  if(!pairN) lumaNN = lumaSS;
                  FxaaFloat gradientScaled = gradient * 1.0/4.0;
                  FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
                  FxaaFloat subpixF = subpixD * subpixE;
                  FxaaBool lumaMLTZero = lumaMM < 0.0;
          /*--------------------------------------------------------------------------*/
                  lumaEndN -= lumaNN * 0.5;
                  lumaEndP -= lumaNN * 0.5;
                  FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
                  FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
                  FxaaBool doneNP = (!doneN) || (!doneP);
                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
          /*--------------------------------------------------------------------------*/
                  if(doneNP) {
                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                          doneN = abs(lumaEndN) >= gradientScaled;
                          doneP = abs(lumaEndP) >= gradientScaled;
                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
                          doneNP = (!doneN) || (!doneP);
                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
          /*--------------------------------------------------------------------------*/
                          #if (FXAA_QUALITY_PS > 3)
                          if(doneNP) {
                                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                  doneN = abs(lumaEndN) >= gradientScaled;
                                  doneP = abs(lumaEndP) >= gradientScaled;
                                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
                                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
                                  doneNP = (!doneN) || (!doneP);
                                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
                                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
          /*--------------------------------------------------------------------------*/
                                  #if (FXAA_QUALITY_PS > 4)
                                  if(doneNP) {
                                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                          doneN = abs(lumaEndN) >= gradientScaled;
                                          doneP = abs(lumaEndP) >= gradientScaled;
                                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
                                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
                                          doneNP = (!doneN) || (!doneP);
                                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
                                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
          /*--------------------------------------------------------------------------*/
                                          #if (FXAA_QUALITY_PS > 5)
                                          if(doneNP) {
                                                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                                  doneN = abs(lumaEndN) >= gradientScaled;
                                                  doneP = abs(lumaEndP) >= gradientScaled;
                                                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
                                                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
                                                  doneNP = (!doneN) || (!doneP);
                                                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
                                                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
          /*--------------------------------------------------------------------------*/
                                                  #if (FXAA_QUALITY_PS > 6)
                                                  if(doneNP) {
                                                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                                          doneN = abs(lumaEndN) >= gradientScaled;
                                                          doneP = abs(lumaEndP) >= gradientScaled;
                                                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
                                                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
                                                          doneNP = (!doneN) || (!doneP);
                                                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
                                                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
          /*--------------------------------------------------------------------------*/
                                                          #if (FXAA_QUALITY_PS > 7)
                                                          if(doneNP) {
                                                                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                                                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                                                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                                                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                                                  doneN = abs(lumaEndN) >= gradientScaled;
                                                                  doneP = abs(lumaEndP) >= gradientScaled;
                                                                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
                                                                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
                                                                  doneNP = (!doneN) || (!doneP);
                                                                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
                                                                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
          /*--------------------------------------------------------------------------*/
                  #if (FXAA_QUALITY_PS > 8)
                  if(doneNP) {
                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                          doneN = abs(lumaEndN) >= gradientScaled;
                          doneP = abs(lumaEndP) >= gradientScaled;
                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
                          doneNP = (!doneN) || (!doneP);
                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
          /*--------------------------------------------------------------------------*/
                          #if (FXAA_QUALITY_PS > 9)
                          if(doneNP) {
                                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                  doneN = abs(lumaEndN) >= gradientScaled;
                                  doneP = abs(lumaEndP) >= gradientScaled;
                                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
                                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
                                  doneNP = (!doneN) || (!doneP);
                                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
                                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
          /*--------------------------------------------------------------------------*/
                                  #if (FXAA_QUALITY_PS > 10)
                                  if(doneNP) {
                                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                          doneN = abs(lumaEndN) >= gradientScaled;
                                          doneP = abs(lumaEndP) >= gradientScaled;
                                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
                                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
                                          doneNP = (!doneN) || (!doneP);
                                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
                                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
          /*--------------------------------------------------------------------------*/
                                          #if (FXAA_QUALITY_PS > 11)
                                          if(doneNP) {
                                                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                                  doneN = abs(lumaEndN) >= gradientScaled;
                                                  doneP = abs(lumaEndP) >= gradientScaled;
                                                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
                                                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
                                                  doneNP = (!doneN) || (!doneP);
                                                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
                                                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
          /*--------------------------------------------------------------------------*/
                                                  #if (FXAA_QUALITY_PS > 12)
                                                  if(doneNP) {
                                                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                                          doneN = abs(lumaEndN) >= gradientScaled;
                                                          doneP = abs(lumaEndP) >= gradientScaled;
                                                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
                                                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
                                                          doneNP = (!doneN) || (!doneP);
                                                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
                                                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
          /*--------------------------------------------------------------------------*/
                                                  }
                                                  #endif
          /*--------------------------------------------------------------------------*/
                                          }
                                          #endif
          /*--------------------------------------------------------------------------*/
                                  }
                                  #endif
          /*--------------------------------------------------------------------------*/
                          }
                          #endif
          /*--------------------------------------------------------------------------*/
                  }
                  #endif
          /*--------------------------------------------------------------------------*/
                                                          }
                                                          #endif
          /*--------------------------------------------------------------------------*/
                                                  }
                                                  #endif
          /*--------------------------------------------------------------------------*/
                                          }
                                          #endif
          /*--------------------------------------------------------------------------*/
                                  }
                                  #endif
          /*--------------------------------------------------------------------------*/
                          }
                          #endif
          /*--------------------------------------------------------------------------*/
                  }
          /*--------------------------------------------------------------------------*/
                  FxaaFloat dstN = posM.x - posN.x;
                  FxaaFloat dstP = posP.x - posM.x;
                  if(!horzSpan) dstN = posM.y - posN.y;
                  if(!horzSpan) dstP = posP.y - posM.y;
          /*--------------------------------------------------------------------------*/
                  FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
                  FxaaFloat spanLength = (dstP + dstN);
                  FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
                  FxaaFloat spanLengthRcp = 1.0/spanLength;
          /*--------------------------------------------------------------------------*/
                  FxaaBool directionN = dstN < dstP;
                  FxaaFloat dst = min(dstN, dstP);
                  FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
                  FxaaFloat subpixG = subpixF * subpixF;
                  FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
                  FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
          /*--------------------------------------------------------------------------*/
                  FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
                  FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
                  if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
                  if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
                  #if (FXAA_DISCARD == 1)
                          return FxaaTexTop(tex, posM);
                  #else
                          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
                  #endif
          }
          /*==========================================================================*/
          #endif
  
          void main() {
              gl_FragColor = FxaaPixelShader(
                  vUv,
                  vec4(0.0),
                  tDiffuse,
                  tDiffuse,
                  tDiffuse,
                  resolution,
                  vec4(0.0),
                  vec4(0.0),
                  vec4(0.0),
                  0.75,
                  0.166,
                  0.0833,
                  0.0,
                  0.0,
                  0.0,
                  vec4(0.0)
              );
  
              // TODO avoid querying texture twice for same texel
              gl_FragColor.a = texture2D(tDiffuse, vUv).a;
          }`
    };
  
    // assets/scripts/experiences/scenes/Depthmap/shaders/fragment.glsl
    var fragment_default = "varying vec2 vUv;uniform vec2 uResolution;uniform vec2 uMouse;uniform vec2 uThreshold;uniform float uTime;uniform sampler2D uBackgroundTexture;uniform vec2 uBackgroundTextureResolution;uniform sampler2D uDepthmapTexture;uniform vec2 uDepthmapTextureResolution;vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec2 mirrored(vec2 v){vec2 m=mod(v,2.);return mix(m,2.0-m,step(1.0,m));}void main(){vec2 texDepthCoords=backgroundUV(vUv,uResolution,uDepthmapTextureResolution);vec4 texDepth=texture2D(uDepthmapTexture,mirrored(texDepthCoords));vec2 fake3d=vec2(texDepthCoords.x+(texDepth.r-0.5)*(uMouse.x+cos(uTime*0.5)*0.66)/uThreshold.x,texDepthCoords.y+(texDepth.r-0.5)*(uMouse.y+sin(uTime*0.5)*0.66)/uThreshold.y);vec4 finaleTexture=texture2D(uBackgroundTexture,mirrored(fake3d));vec2 vignetteUv=vUv;vignetteUv*=1.0-vignetteUv.yx;float vignette=vignetteUv.x*vignetteUv.y*15.0;vignette=pow(vignette,0.025);finaleTexture.rgb-=1.-vec3(vignette);gl_FragColor=finaleTexture;}";
  
    // assets/scripts/experiences/shaders/vertex.glsl
    var vertex_default = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/experiences/scenes/Depthmap/Depthmap.js
    var Depthmap = class {
      constructor({ id: id2, $el, moduleInstance }) {
        var _a, _b, _c;
        Object.assign(this, commonSceneMethods_default);
        Object.assign(this, commonSceneUniforms_default);
        this.$el = $el;
        this.id = id2;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        (_a = this.createScene) == null ? void 0 : _a.call(this);
        (_b = this.createCamera) == null ? void 0 : _b.call(this);
        (_c = this.createRtTexture) == null ? void 0 : _c.call(this);
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          var _a;
          this.setPlane();
          (_a = this.setResolutionUniforms) == null ? void 0 : _a.call(this, this.$el.offsetWidth, this.$el.offsetHeight);
        });
      }
      resize(width, height) {
        this.compute(width, height);
      }
      update(time, deltaTime, frame) {
        this.material.uniforms.uTime.value = time;
      }
      mouseMove(mouseCoords) {
        let { x, y, smoothX, smoothY } = mouseCoords;
        const halfX = this.material.uniforms.uResolution.value[0] / 2;
        const halfY = this.material.uniforms.uResolution.value[1] / 2;
        x = (halfX - smoothX) / halfX;
        y = (halfY - smoothY) / halfY;
        this.material.uniforms.uMouse.value = [x, y];
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uMouse: { value: [0, 0] },
            uThreshold: { value: [65, 80] },
            uTime: { value: 0 },
            uResolution: { value: [0, 0] },
            uBackgroundTexture: { value: null },
            uBackgroundTextureResolution: { value: [0, 0] },
            uDepthmapTexture: { value: null },
            uDepthmapTextureResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default,
          fragmentShader: fragment_default
        });
        const geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(geometry, this.material);
        this.scene.add(this.plane);
      }
      setTextures(backgroundTexture, depthmapTexture) {
        var _a, _b;
        (_a = this.setTextureUniforms) == null ? void 0 : _a.call(this, backgroundTexture, "uBackgroundTexture");
        (_b = this.setTextureUniforms) == null ? void 0 : _b.call(this, depthmapTexture, "uDepthmapTexture");
      }
      compute(width, height) {
        var _a, _b;
        (_a = this.resizeRtTexture) == null ? void 0 : _a.call(this, width, height);
        (_b = this.setResolutionUniforms) == null ? void 0 : _b.call(this, width, height);
      }
    };
  
    // assets/scripts/experiences/scenes/Portal/shaders/fragment.glsl
    var fragment_default2 = "varying vec2 vUv;uniform vec2 uResolution;uniform sampler2D uTexture;uniform vec2 uTextureResolution;vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec3 samplef(vec4 tTexture,vec2 tc){return pow(tTexture.rgb,vec3(2.2,2.2,2.2));}vec3 highlights(vec3 pixel,float thres){float val=(pixel.x+pixel.y+pixel.z)/3.0;return pixel*smoothstep(thres-0.1,thres+0.1,val);}vec3 hsample(vec4 tTexture,vec2 tc){return highlights(samplef(tTexture,tc),0.6);}vec3 blur(vec4 tTexture,vec2 tc,float offs){vec4 xoffs=offs*vec4(-2.0,-1.0,1.0,2.0)/uResolution.x;vec4 yoffs=offs*vec4(-2.0,-1.0,1.0,2.0)/uResolution.y;vec3 color=vec3(0.0,0.0,0.0);color+=hsample(tTexture,tc+vec2(xoffs.x,yoffs.x))*0.00366;color+=hsample(tTexture,tc+vec2(xoffs.y,yoffs.x))*0.01465;color+=hsample(tTexture,tc+vec2(0.0,yoffs.x))*0.02564;color+=hsample(tTexture,tc+vec2(xoffs.z,yoffs.x))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.w,yoffs.x))*0.00366;color+=hsample(tTexture,tc+vec2(xoffs.x,yoffs.y))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.y,yoffs.y))*0.05861;color+=hsample(tTexture,tc+vec2(0.0,yoffs.y))*0.09524;color+=hsample(tTexture,tc+vec2(xoffs.z,yoffs.y))*0.05861;color+=hsample(tTexture,tc+vec2(xoffs.w,yoffs.y))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.x,0.0))*0.02564;color+=hsample(tTexture,tc+vec2(xoffs.y,0.0))*0.09524;color+=hsample(tTexture,tc+vec2(0.0,0.0))*0.15018;color+=hsample(tTexture,tc+vec2(xoffs.z,0.0))*0.09524;color+=hsample(tTexture,tc+vec2(xoffs.w,0.0))*0.02564;color+=hsample(tTexture,tc+vec2(xoffs.x,yoffs.z))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.y,yoffs.z))*0.05861;color+=hsample(tTexture,tc+vec2(0.0,yoffs.z))*0.09524;color+=hsample(tTexture,tc+vec2(xoffs.z,yoffs.z))*0.05861;color+=hsample(tTexture,tc+vec2(xoffs.w,yoffs.z))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.x,yoffs.w))*0.00366;color+=hsample(tTexture,tc+vec2(xoffs.y,yoffs.w))*0.01465;color+=hsample(tTexture,tc+vec2(0.0,yoffs.w))*0.02564;color+=hsample(tTexture,tc+vec2(xoffs.z,yoffs.w))*0.01465;color+=hsample(tTexture,tc+vec2(xoffs.w,yoffs.w))*0.00366;return color;}void main(){vec2 texCoords=backgroundUV(vUv,uResolution,uTextureResolution);vec4 portalTexture=texture2D(uTexture,texCoords);vec3 color=blur(portalTexture,texCoords,1.0);color+=blur(portalTexture,texCoords,2.0);color+=blur(portalTexture,texCoords,3.0);color+=blur(portalTexture,texCoords,4.0);color/=3.0;color+=samplef(portalTexture,texCoords);vec4 fragColor=vec4(0.,0.,0.,1.);fragColor.rgb=mix(samplef(portalTexture,texCoords),color,1.);gl_FragColor=fragColor;}";
  
    // assets/scripts/experiences/scenes/Portal/Portal.js
    var Portal = class {
      constructor({ id: id2, $el, moduleInstance }) {
        var _a, _b, _c;
        Object.assign(this, commonSceneMethods_default);
        Object.assign(this, commonSceneUniforms_default);
        this.$el = $el;
        this.id = id2;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        (_a = this.createScene) == null ? void 0 : _a.call(this);
        (_b = this.createCamera) == null ? void 0 : _b.call(this);
        (_c = this.createRtTexture) == null ? void 0 : _c.call(this);
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          var _a;
          this.setPlane();
          (_a = this.setResolutionUniforms) == null ? void 0 : _a.call(this, this.$el.offsetWidth, this.$el.offsetHeight);
        });
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        if (this.material) {
          this.material.uniforms.uTime.value = this.time;
        }
      }
      resize(width, height) {
        this.compute(width, height);
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uResolution: { value: [0, 0] },
            uTexture: { value: null },
            uTextureResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default,
          fragmentShader: fragment_default2
        });
        const geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(geometry, this.material);
        this.scene.add(this.plane);
      }
      setTexture(texture) {
        var _a;
        (_a = this.setTextureUniforms) == null ? void 0 : _a.call(this, texture, "uTexture");
      }
      compute(width, height) {
        var _a, _b;
        (_a = this.resizeRtTexture) == null ? void 0 : _a.call(this, width, height);
        (_b = this.setResolutionUniforms) == null ? void 0 : _b.call(this, width, height);
      }
    };
  
    // node_modules/three/examples/jsm/loaders/FontLoader.js
    var FontLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text2) {
          let json;
          try {
            json = JSON.parse(text2);
          } catch (e) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
            json = JSON.parse(text2.substring(65, text2.length - 2));
          }
          const font = scope.parse(json);
          if (onLoad)
            onLoad(font);
        }, onProgress, onError);
      }
      parse(json) {
        return new Font(json);
      }
    };
    var Font = class {
      constructor(data) {
        this.type = "Font";
        this.data = data;
      }
      generateShapes(text2, size = 100) {
        const shapes = [];
        const paths = createPaths(text2, size, this.data);
        for (let p = 0, pl = paths.length; p < pl; p++) {
          Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
      }
    };
    function createPaths(text2, size, data) {
      const chars = Array.from(text2);
      const scale = size / data.resolution;
      const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
      const paths = [];
      let offsetX = 0, offsetY = 0;
      for (let i2 = 0; i2 < chars.length; i2++) {
        const char = chars[i2];
        if (char === "\n") {
          offsetX = 0;
          offsetY -= line_height;
        } else {
          const ret = createPath(char, scale, offsetX, offsetY, data);
          offsetX += ret.offsetX;
          paths.push(ret.path);
        }
      }
      return paths;
    }
    function createPath(char, scale, offsetX, offsetY, data) {
      const glyph = data.glyphs[char] || data.glyphs["?"];
      if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
        return;
      }
      const path = new ShapePath();
      let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
      if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for (let i2 = 0, l = outline.length; i2 < l; ) {
          const action = outline[i2++];
          switch (action) {
            case "m":
              x = outline[i2++] * scale + offsetX;
              y = outline[i2++] * scale + offsetY;
              path.moveTo(x, y);
              break;
            case "l":
              x = outline[i2++] * scale + offsetX;
              y = outline[i2++] * scale + offsetY;
              path.lineTo(x, y);
              break;
            case "q":
              cpx = outline[i2++] * scale + offsetX;
              cpy = outline[i2++] * scale + offsetY;
              cpx1 = outline[i2++] * scale + offsetX;
              cpy1 = outline[i2++] * scale + offsetY;
              path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
              break;
            case "b":
              cpx = outline[i2++] * scale + offsetX;
              cpy = outline[i2++] * scale + offsetY;
              cpx1 = outline[i2++] * scale + offsetX;
              cpy1 = outline[i2++] * scale + offsetY;
              cpx2 = outline[i2++] * scale + offsetX;
              cpy2 = outline[i2++] * scale + offsetY;
              path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
              break;
          }
        }
      }
      return { offsetX: glyph.ha * scale, path };
    }
    Font.prototype.isFont = true;
  
    // node_modules/three/examples/jsm/geometries/TextGeometry.js
    var TextGeometry = class extends ExtrudeGeometry {
      constructor(text2, parameters = {}) {
        const font = parameters.font;
        if (!(font && font.isFont)) {
          console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
          return new BufferGeometry();
        }
        const shapes = font.generateShapes(text2, parameters.size);
        parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
        if (parameters.bevelThickness === void 0)
          parameters.bevelThickness = 10;
        if (parameters.bevelSize === void 0)
          parameters.bevelSize = 8;
        if (parameters.bevelEnabled === void 0)
          parameters.bevelEnabled = false;
        super(shapes, parameters);
        this.type = "TextGeometry";
      }
    };
  
    // assets/scripts/experiences/scenes/Typo/TypoData.json
    var TypoData_default = [
      {
        fr: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "Nous",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.05,
                  y: "*1.2"
                }
              },
              {
                value: "Cr\xE9ons",
                align: "right",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.1,
                  y: 0
                }
              },
              {
                value: "des",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.15,
                  y: 0
                }
              },
              {
                value: "Portails",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.15,
                  y: "*-1.3"
                }
              },
              {
                value: "vers",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.25,
                  y: "*-1.3"
                }
              },
              {
                value: "l'\xC9merveillement",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0.01,
                  y: "*-2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": {
              default: 0.06,
              modifiers: [
                {
                  condition: "window.innerWidth > 450",
                  value: 0.065
                }
              ]
            },
            blocks: [
              {
                value: "Nous Cr\xE9ons",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.3"
                }
              },
              {
                value: "des Portails",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: 0
                }
              },
              {
                value: "vers",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.05,
                  y: "*-1.4"
                }
              },
              {
                value: "l'\xC9mer-",
                align: "left",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.02,
                  y: "*-1.4"
                }
              },
              {
                value: "veillement",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*0.9",
                position: {
                  x: -0.05,
                  y: "*-2.65"
                }
              }
            ]
          }
        },
        en: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "We Create",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.0"
                }
              },
              {
                value: "Havens",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.025,
                  y: "*-0.1"
                }
              },
              {
                value: "Endless",
                align: "left",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0.05,
                  y: "*-1.3"
                }
              },
              {
                value: "for",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-1.3"
                }
              },
              {
                value: "Wonder",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.15,
                  y: "*-2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.065,
            blocks: [
              {
                value: "We Create",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.2"
                }
              },
              {
                value: "Havens",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: 0
                }
              },
              {
                value: "for Endless",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-1.3"
                }
              },
              {
                value: "Wonder",
                align: "center",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-2.5"
                }
              }
            ]
          }
        }
      },
      {
        fr: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "Notre",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.24,
                  y: "*1.2"
                }
              },
              {
                value: "Gentillesse",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.08,
                  y: "*1.2"
                }
              },
              {
                value: "contribue",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.18,
                  y: 0
                }
              },
              {
                value: "\xE0",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.35,
                  y: 0
                }
              },
              {
                value: "l'Excellence",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0.25,
                  y: "*-1.3"
                }
              },
              {
                value: "Cr\xE9ative",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.12,
                  y: "*-2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": {
              default: 0.055,
              modifiers: [
                {
                  condition: "window.innerWidth > 450",
                  value: 0.055
                }
              ]
            },
            blocks: [
              {
                value: "Notre",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*2.5"
                }
              },
              {
                value: "Gentillesse",
                align: "center",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.2"
                }
              },
              {
                value: "contribue",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: 0
                }
              },
              {
                value: "\xE0 l'Excellence",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-1.3"
                }
              },
              {
                value: "Cr\xE9ative",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-2.5"
                }
              }
            ]
          }
        },
        en: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "We Value",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.0"
                }
              },
              {
                value: "Kindness",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.015,
                  y: "*-0.1"
                }
              },
              {
                value: "unlocks",
                align: "left",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0.1,
                  y: "*-1.3"
                }
              },
              {
                value: "that",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.1,
                  y: "*-1.3"
                }
              },
              {
                value: "Creativity",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.16,
                  y: "* -2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.06,
            blocks: [
              {
                value: "We Value",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.2"
                }
              },
              {
                value: "Kindness",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-0.1"
                }
              },
              {
                value: "unlocks",
                align: "left",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.05,
                  y: "*-1.4"
                }
              },
              {
                value: "that",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.07,
                  y: "*-1.4"
                }
              },
              {
                value: "Creativity",
                align: "center",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0,
                  y: "* -2.8"
                }
              }
            ]
          }
        }
      },
      {
        fr: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "Nous",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.18,
                  y: "*1.2"
                }
              },
              {
                value: "Prosp\xE9rons",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.08,
                  y: "*1.2"
                }
              },
              {
                value: "en",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.4,
                  y: 0
                }
              },
              {
                value: "D\xE9veloppant",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.25,
                  y: 0
                }
              },
              {
                value: "jeux",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.25,
                  y: "*-1.3"
                }
              },
              {
                value: "des",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0,
                  y: "*-1.3"
                }
              },
              {
                value: "inspirants",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.08,
                  y: "*-2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.05,
            blocks: [
              {
                value: "Nous",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*2.2"
                }
              },
              {
                value: "Prosp\xE9rons",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*0.9"
                }
              },
              {
                value: "en",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.18,
                  y: "*-0.5"
                }
              },
              {
                value: "D\xE9veloppant",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.15,
                  y: "*-0.5"
                }
              },
              {
                value: "des jeux",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.08,
                  y: "*-1.8"
                }
              },
              {
                value: "inspirants",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0.05,
                  y: "*-3.1"
                }
              }
            ]
          }
        },
        en: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "We Build",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.0"
                }
              },
              {
                value: "Opportunities",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-0.1"
                }
              },
              {
                value: "Fearless",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.1,
                  y: "*-1.3"
                }
              },
              {
                value: "for",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.25,
                  y: "*-1.3"
                }
              },
              {
                value: "Optimism",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.3,
                  y: "*-2.5"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.06,
            blocks: [
              {
                value: "We Build",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.1"
                }
              },
              {
                value: "Opportunities",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-0.1"
                }
              },
              {
                value: "Fearless",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.06,
                  y: "*-1.4"
                }
              },
              {
                value: "for",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.145,
                  y: "*-1.4"
                }
              },
              {
                value: "Optimism",
                align: "center",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-2.7"
                }
              }
            ]
          }
        }
      },
      {
        fr: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "Id\xE9es,",
                align: "right",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.05,
                  y: "*0.8"
                }
              },
              {
                value: "Passion",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0.08,
                  y: "*0.8"
                }
              },
              {
                value: "et un",
                align: "right",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.15,
                  y: "*-0.5"
                }
              },
              {
                value: "Intr\xE9pide",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.02,
                  y: "*-0.5"
                }
              },
              {
                value: "Optimisme",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-1.8"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.055,
            blocks: [
              {
                value: "Id\xE9es,",
                align: "right",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.05,
                  y: "*1.0"
                }
              },
              {
                value: "Passion",
                align: "left",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*1.0"
                }
              },
              {
                value: "et",
                align: "right",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.06,
                  y: "*-0.1"
                }
              },
              {
                value: "un",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0.08,
                  y: "*-0.1"
                }
              },
              {
                value: "Intr\xE9pide",
                align: "center",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: 0.04,
                  y: "*-1.3"
                }
              },
              {
                value: "Optimisme",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.04,
                  y: "*-2.5"
                }
              }
            ]
          }
        },
        en: {
          isWideCondition: "window.innerWidth/window.innerHeight >= 9/7",
          wideData: {
            "font-size": 0.1,
            blocks: [
              {
                value: "We Thrive",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*0.8"
                }
              },
              {
                value: "on",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.3,
                  y: "*-0.4"
                }
              },
              {
                value: "Inspiring",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.1,
                  y: "*-0.4"
                }
              },
              {
                value: "Play",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: -0.15,
                  y: "*-1.7"
                }
              }
            ]
          },
          tallData: {
            "font-size": 0.06,
            blocks: [
              {
                value: "We Thrive",
                align: "center",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: 0,
                  y: "*0.8"
                }
              },
              {
                value: "on",
                align: "right",
                font: "LexendLight",
                size: "*1",
                position: {
                  x: -0.14,
                  y: "*-0.4"
                }
              },
              {
                value: "Inspiring",
                align: "left",
                font: "LibreCaslonRegular",
                size: "*1",
                position: {
                  x: -0.1,
                  y: "*-0.4"
                }
              },
              {
                value: "Play",
                align: "center",
                font: "LibreCaslonItalic",
                size: "*1",
                position: {
                  x: 0,
                  y: "*-1.7"
                }
              }
            ]
          }
        }
      }
    ];
  
    // assets/scripts/experiences/scenes/Typo/Typo.js
    var CURVESEGMENTS = 5;
    var Typo = class {
      constructor({ id: id2, $el, moduleInstance }) {
        var _a, _b, _c;
        Object.assign(this, commonSceneMethods_default);
        Object.assign(this, commonSceneUniforms_default);
        this.$el = $el;
        this.id = id2;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.currentSlide = 0;
        this.viewport = {
          width: window.innerWidth,
          height: window.innerHeight
        };
        (_a = this.createScene) == null ? void 0 : _a.call(this);
        (_b = this.createCamera) == null ? void 0 : _b.call(this, true);
        (_c = this.createRtTexture) == null ? void 0 : _c.call(this, { format: RGBFormat }, true);
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          yield this.loadFonts();
          this.setTextData();
          this.setScene();
          this.setTimeline();
        });
      }
      setSlide(id2) {
        this.currentSlide = id2;
        this.setTextData(id2);
        this.setScene();
        this.setTimeline();
      }
      resize(width, height) {
        const aspect2 = width / height;
        const aspectBreakpoint = 9 / 7;
        const aspectChanged = this.aspect >= aspectBreakpoint && aspect2 < aspectBreakpoint || this.aspect < aspectBreakpoint && aspect2 >= aspectBreakpoint;
        const widthBreakpoint = 450;
        const widthChanged = this.viewport.width >= widthBreakpoint && width < widthBreakpoint || this.viewport.width < widthBreakpoint && width >= widthBreakpoint;
        this.compute(width, height);
        if (aspectChanged || widthChanged) {
          this.setTextData();
          this.setScene();
          const progress = this.timeline && this.timeline.progress ? this.timeline.progress() : 0;
          this.setTimeline();
          this.timeline.progress(progress);
        }
      }
      update(time, deltaTime, frame) {
        this.time = time;
      }
      mouseMove(mouseCoords) {
        const getCartesianCoordinates = (x, y) => {
          x = mapLinear(x, 0, this.viewport.width, -1, 1);
          y = mapLinear(y, 0, this.viewport.height, -1, 1);
          return {
            x: x + Math.cos(this.time * 0.5) * -0.66,
            y: y + Math.sin(this.time * 0.5) * -0.66
          };
        };
        const cartesianCoordinates = {
          raw: getCartesianCoordinates(mouseCoords.x, mouseCoords.y),
          smooth: getCartesianCoordinates(mouseCoords.smoothX, mouseCoords.smoothY)
        };
        if (this.group && this.group.position) {
          this.group.position.x = -cartesianCoordinates.smooth.x * 0.01;
          this.group.position.y = -cartesianCoordinates.smooth.y * 0.01;
        }
      }
      compute(width, height) {
        var _a;
        (_a = this.resizeRtTexture) == null ? void 0 : _a.call(this, width, height);
        const frustumSize = 1;
        this.aspect = width / height;
        this.camera.left = frustumSize * this.aspect / -2;
        this.camera.right = frustumSize * this.aspect / 2;
        this.camera.top = frustumSize / 2;
        this.camera.bottom = frustumSize / -2;
        this.camera.updateProjectionMatrix();
        this.viewport = {
          width,
          height
        };
      }
      loadFonts() {
        return __async(this, null, function* () {
          this.fonts = {};
          const fontLoader = new FontLoader();
          const fontPromises = [];
          const fonts2 = [
            {
              name: "LexendLight",
              file: "/assets/fonts/Lexend-Light.json"
            },
            {
              name: "LibreCaslonRegular",
              file: "/assets/fonts/LibreCaslonText_Regular.json"
            },
            {
              name: "LibreCaslonItalic",
              file: "/assets/fonts/LibreCaslonText_Italic.json"
            }
          ];
          for (let font of fonts2) {
            fontPromises.push(new Promise((resolve) => {
              fontLoader.load(font.file + "?v=" + assetsVersion, (fontface) => {
                this.fonts[font.name] = fontface;
                resolve();
              });
            }));
          }
          yield Promise.all(fontPromises);
        });
      }
      setTextData(id = this.currentSlide) {
        const isWide = eval(TypoData_default[id][lang].isWideCondition);
        if (isWide) {
          this.textData = TypoData_default[id][lang].wideData;
        } else {
          this.textData = TypoData_default[id][lang].tallData;
        }
        let fontSize;
        if (typeof this.textData["font-size"] === "object") {
          fontSize = this.textData["font-size"].default;
          for (let modifier of this.textData["font-size"].modifiers) {
            if (eval(modifier.condition))
              fontSize = modifier.value;
          }
        } else
          fontSize = this.textData["font-size"];
        for (let i = 0; i < this.textData.blocks.length; i++) {
          this.textData.blocks[i].size = typeof this.textData.blocks[i].size === "string" ? eval(fontSize + this.textData.blocks[i].size) : this.textData.blocks[i].size;
          this.textData.blocks[i].position.x = typeof this.textData.blocks[i].position.x === "string" ? eval(fontSize + this.textData.blocks[i].position.x) : this.textData.blocks[i].position.x;
          this.textData.blocks[i].position.y = typeof this.textData.blocks[i].position.y === "string" ? eval(fontSize + this.textData.blocks[i].position.y) : this.textData.blocks[i].position.y;
        }
      }
      clearScene() {
        this.scene.clear();
      }
      setScene() {
        this.clearScene();
        this.group = new Group();
        this.chars = [];
        for (let i2 = 0; i2 < this.textData.blocks.length; i2++) {
          const text2 = this.textData.blocks[i2];
          const textGeometry = new TextGeometry(text2.value, {
            font: this.fonts[text2.font],
            size: text2.size,
            height: 0,
            curveSegments: CURVESEGMENTS
          });
          textGeometry.computeBoundingBox();
          let x;
          let y = text2.position.y;
          const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
          switch (text2.align) {
            case "left":
              x = text2.position.x;
              break;
            case "center":
              x = text2.position.x - textWidth / 2;
              break;
            case "right":
              x = text2.position.x - textWidth;
              break;
          }
          let offset2 = 0;
          const chars = text2.value.split("");
          const lineChars = [];
          for (let j = chars.length - 1; j >= 0; j--) {
            const charGeometry = new TextGeometry(chars[j], {
              font: this.fonts[text2.font],
              size: text2.size,
              height: 0,
              curveSegments: CURVESEGMENTS
            });
            charGeometry.computeBoundingBox();
            charGeometry.translate(-charGeometry.boundingBox.max.x, 0, 0);
            const remainingGeometry = new TextGeometry(text2.value.slice(0, j), {
              font: this.fonts[text2.font],
              size: text2.size,
              height: 0,
              curveSegments: CURVESEGMENTS
            });
            remainingGeometry.computeBoundingBox();
            let remainingWidth = remainingGeometry.boundingBox.max.x - remainingGeometry.boundingBox.min.x;
            const position = {
              x: x + textWidth + offset2,
              y
            };
            const textMaterial = new ShaderMaterial({
              extensions: {
                derivatives: "#extension GL_OES_standard_derivatives : enable"
              },
              uniforms: {
                uOpacity: { value: 1 }
              },
              transparent: true,
              vertexShader: vertex_default,
              fragmentShader: `
                          precision mediump float;
                          uniform float uOpacity;
  
                          void main() {
                             gl_FragColor = vec4(uOpacity,uOpacity,uOpacity,1.);
                          }
                      `
            });
            const mesh = new Mesh(charGeometry, textMaterial);
            mesh.position.x = position.x;
            mesh.position.y = position.y;
            this.group.add(mesh);
            lineChars.push({
              text: text2,
              value: chars[j],
              mesh,
              geometry: charGeometry,
              position,
              progress: 1
            });
            offset2 = remainingWidth - textWidth;
          }
          lineChars.reverse();
          this.chars = this.chars.concat(lineChars);
          this.scene.add(this.group);
        }
      }
      setTimeline() {
        this.timeline = gsapWithCSS2.timeline({
          onUpdate: () => {
            for (let char of this.chars) {
              char.mesh.position.y = char.position.y - char.text.size * (1 - char.progress);
              char.mesh.material.uniforms.uOpacity.value = char.progress;
            }
          }
        });
        this.timeline.from(this.chars, {
          progress: 0,
          duration: 2,
          stagger: 0.03,
          ease: "power4.out"
        });
        this.timeline.progress(0.01);
        this.timeline.pause();
        this.timeline.progress(0);
      }
      reveal(id2 = null) {
        if (id2 != null)
          this.setSlide(id2);
        this.timeline.restart();
      }
    };
  
    // assets/scripts/experiences/shaders/fragment.glsl
    var fragment_default3 = "varying vec2 vUv;uniform float uTime;uniform vec2 uResolution;uniform float uNoiseProgress;uniform float uTextOpacityProgress;uniform float uMaskProgress;uniform float uMaskIdle;uniform float uMaxMaskScale;uniform float uDepthScale;uniform float uDepthScaleStart;uniform sampler2D uPortalTexture;uniform sampler2D uDepthStartTexture;uniform sampler2D uDepthEndTexture;uniform sampler2D uTypoTexture;uniform sampler2D uNoiseTexture;uniform vec2 uNoiseTextureResolution;uniform sampler2D uMaskTexture;uniform vec2 uMaskTextureResolution;uniform float uHoverProgress;uniform bool uHasTextureSwapped;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec3 backgroundColor=vec3(0.,0.,0.);void main(){float portalOpacity=1.;float textOpacity=uTextOpacityProgress;float noiseMultiplier=.01;float noiseOffsetY=0.06*uTime;vec2 noiseCoords=backgroundUV(vUv,uResolution,uNoiseTextureResolution);noiseCoords.y+=noiseOffsetY;vec4 noiseTexture=texture2D(uNoiseTexture,noiseCoords);noiseTexture-=0.5;noiseTexture.xy*=noiseMultiplier;vec2 depthStartCoords=vUv;if(uHasTextureSwapped){float depthStartScale=uDepthScale;depthStartCoords*=1./depthStartScale;depthStartCoords-=1./depthStartScale*.5-0.5;}vec4 depthStartTexture=texture2D(uDepthStartTexture,depthStartCoords);vec2 depthEndCoords=vUv;float depthEndScale=1.;if(!uHasTextureSwapped){depthEndScale=uDepthScale;}else{depthEndScale=uDepthScaleStart;}depthEndCoords*=1./depthEndScale;depthEndCoords-=1./depthEndScale*.5-0.5;vec4 depthEndTexturedNoisy=texture2D(uDepthEndTexture,vec2(depthEndCoords.x+(noiseTexture.x*uNoiseProgress),depthEndCoords.y+(noiseTexture.y*uNoiseProgress)));depthEndTexturedNoisy.a=portalOpacity;if(depthEndTexturedNoisy.a<1.0){if(depthStartTexture.a<1.){depthEndTexturedNoisy=mix(depthEndTexturedNoisy,vec4(backgroundColor,1),1.-portalOpacity);}else{depthEndTexturedNoisy=mix(depthEndTexturedNoisy,depthStartTexture,1.-portalOpacity);}}depthEndTexturedNoisy.rgb+=uHoverProgress*(0.1*(1.-uMaskProgress));vec2 maskCoords=backgroundUV(vUv,uResolution,uMaskTextureResolution);float maskScaleEnter=clamp(map(uMaskProgress,0.,uMaskIdle,1.,0.),0.,1.);float maskScaleOut=clamp(map(uMaskProgress,uMaskIdle,1.,1.,uMaxMaskScale),1.,uMaxMaskScale);float maskScale=maskScaleOut-maskScaleEnter;maskCoords*=1./maskScale;maskCoords-=1./maskScale*.5-0.5;vec4 maskTexture=texture2D(uMaskTexture,maskCoords);if(depthStartTexture.a<1.){depthStartTexture.rgb+=backgroundColor;depthStartTexture.a=1.;}vec4 backgroundComp=mix(depthStartTexture,depthEndTexturedNoisy,step(0.01,maskTexture.r));vec2 typoCoords=vUv;vec4 typoStartTexture=texture2D(uTypoTexture,vUv);typoStartTexture.rgb*=floor((1.-maskTexture.r)+.5);vec4 typeEndTexturedNoisy=texture2D(uTypoTexture,vec2(typoCoords.x+(noiseTexture.x*uNoiseProgress),typoCoords.y+(noiseTexture.y*uNoiseProgress)));typeEndTexturedNoisy.rgb*=floor(maskTexture.r+.5);vec4 typoComp=mix(typoStartTexture,typeEndTexturedNoisy,maskTexture.r);typoComp.a=textOpacity;if(typoComp.a<1.0){typoComp=mix(typoComp,vec4(0.,0.,0.,0.),1.-textOpacity);}vec4 mixComp=typoComp;if(mixComp.r<1.){mixComp.rgb+=backgroundComp.rgb;}vec2 portalCoords=vUv;portalCoords*=1./maskScale;portalCoords-=1./maskScale*.5-0.5;vec4 portalTexture=texture2D(uPortalTexture,portalCoords);vec4 experienceComp=vec4(mixComp.rgb+portalTexture.rgb,1.);vec4 finalComp=experienceComp;gl_FragColor=finalComp;}";
  
    // assets/scripts/classes/Cookies/CookieManager.js
    "use strict";
    var COOKIES_TYPE = {
      GDPR_COOKIE: "accept_cookies",
      SKIP_INTRO_COOKIE: "skip_intro_cookie"
    };
    var COOKIES_TYPE_DURATION = {
      GDPR_COOKIE_DURATION: 129600,
      SKIP_INTRO_COOKIE_DURATION: 4320
    };
    var $CookieManager = class {
      constructor() {
        __publicField(this, "duration", COOKIES_TYPE_DURATION.GDPR_COOKIE_DURATION);
        __publicField(this, "acceptedCookies", false);
      }
      registerCookie(name, value, duration) {
        if (!name) {
          return;
        }
        if (!value) {
          value = true;
        }
        let initialDuration = this.duration;
        if (duration) {
          initialDuration = duration;
        }
        const endDate = new Date();
        endDate.setTime(endDate.getTime() + initialDuration * 60 * 1e3);
        const cookie = {
          name,
          endDate,
          value
        };
        const expires = "expires=" + cookie.endDate.toUTCString();
        document.cookie = cookie.name + "=" + cookie.value + ";" + expires + ";path=/";
      }
      unregisterCookie(name) {
        if (!name) {
          return;
        }
        const date = new Date();
        date.setTime(date.getTime() - 1e3 * 60 * 60 * 24);
        const expires = "expires=" + date.toUTCString();
        document.cookie = name + "=; " + expires;
      }
      getCookie(name) {
        if (!name) {
          return;
        }
        const cookieName = name + "=";
        const wCookieArr = document.cookie.split(";");
        for (let i2 = 0; i2 < wCookieArr.length; i2++) {
          let cookie = wCookieArr[i2];
          while (cookie.charAt(0) == " ") {
            cookie = cookie.substring(1);
          }
          if (cookie.indexOf(cookieName) == 0) {
            return cookie.substring(cookieName.length, cookie.length);
          }
        }
        return "";
      }
      checkCookie(name) {
        const cookie_exists = this.getCookie(name);
        return cookie_exists;
      }
      hasAcceptedCookies() {
        if (this.acceptedCookies) {
          return true;
        } else if (this.getCookie(COOKIES_TYPE.GDPR_COOKIE)) {
          this.acceptedCookies = true;
          return true;
        }
        return false;
      }
      acceptCookies() {
        this.registerCookie(COOKIES_TYPE.GDPR_COOKIE, true);
        this.acceptedCookies = true;
      }
    };
    var CookieManager = new $CookieManager();
  
    // assets/scripts/experiences/Experiences.js
    var DEFAULT_PORTAL_WIDTH2 = 259;
    var HOLD_DURATION = 800;
    var EXPERIENCE_INSTANCES = [
      {
        id: "portal",
        uniform: "uPortalTexture",
        class: Portal
      },
      {
        id: "depthStart",
        uniform: "uDepthStartTexture",
        class: Depthmap
      },
      {
        id: "depthEnd",
        uniform: "uDepthEndTexture",
        class: Depthmap
      },
      {
        id: "typo",
        uniform: "uTypoTexture",
        class: Typo
      }
    ];
    var Experiences = class {
      constructor({ $el, moduleInstance, images, paneObj }) {
        var _a, _b;
        Object.assign(this, commonSceneMethods_default);
        Object.assign(this, commonSceneUniforms_default);
        Object.assign(this, finalSceneUniforms_default);
        Object.assign(this, finalSceneHoldMethods_default);
        Object.assign(this, finalSceneAnimations_default);
        this.$el = $el;
        this.moduleInstance = moduleInstance;
        this.images = images;
        this.paneObj = paneObj;
        this.masterAnimationData = {
          progress: 0,
          target: 1,
          duration: 1.4
        };
        this.maskData = {
          maxScale: 1
        };
        this.maskAnimationData = {
          progress: 0,
          value: 0
        };
        this.noiseAnimationData = {
          value: 1
        };
        this.holdData = {
          holdDuration: HOLD_DURATION,
          baseTime: Date.now(),
          isHolding: false
        };
        this.holdAnimationData = {
          progress: 0,
          value: 0,
          targetIn: 0,
          targetOut: 0,
          durationIn: HOLD_DURATION / 1e3,
          durationOut: 0.3,
          scaleMultiplier: 0.8
        };
        this.hoverAnimationData = {
          progress: 0,
          durationIn: 0.6,
          durationOut: 0.6,
          allowed: !window.matchMedia("(hover: none)").matches
        };
        this.textAnimationData = {
          value: 1
        };
        this.depthScaleAnimationData = {
          scaleStart: 1.6,
          scaleEnd: 1,
          scaleValue: 1,
          scaleDuration: 1.6
        };
        this.depthScaleAnimationData.scaleValue = this.depthScaleAnimationData.scaleStart;
        this.rtTexturesInstances = [];
        this.textures = {
          depthStartBackground: null,
          depthStartDepthmap: null
        };
        this.startTextureIndex = -1;
        this.endTextureIndex = 0;
        this.textIndex = -1;
        this.allTextureLoaded = false;
        this.isInteractiveAreaHovered = false;
        this.isRevealed = false;
        this.hasInteracted = false;
        this.width = $el.offsetWidth;
        this.height = $el.offsetHeight;
        this.dpr = window.devicePixelRatio;
        this.normalizedDpr = Math.min(this.dpr, 2);
        this.isRenderReady = false;
        this.hasPostProcessing = this.normalizedDpr <= 1;
        (_a = this.createScene) == null ? void 0 : _a.call(this);
        (_b = this.createCamera) == null ? void 0 : _b.call(this);
        this.createRenderer();
        this.postProcess();
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          this.setPlane();
          EXPERIENCE_INSTANCES.forEach((experience) => {
            var _a;
            const experienceInstance = new experience.class({
              id: experience.id,
              $el: this.$el,
              moduleInstance: this.moduleInstance
            });
            this.rtTexturesInstances.push(experienceInstance);
            (_a = this.setRTTextureUniforms) == null ? void 0 : _a.call(this, experience.uniform, experienceInstance.rtTexture.texture);
          });
          if (this.paneObj) {
            this.setupPane();
          }
        });
      }
      destroy() {
        this.rtTexturesInstances.forEach((rtTexturesInstance) => {
          var _a;
          return (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.destroy) == null ? void 0 : _a.call(rtTexturesInstance);
        });
      }
      loadAssets() {
        var _a, _b, _c, _d, _e;
        const promises = [];
        if ((_a = this.images) == null ? void 0 : _a.portalImage) {
          const portalPromise = this.loadPortalTexture(this.images.portalImage).then((texture) => {
            this.setPortalTexture(texture);
          });
          promises.push(portalPromise);
        }
        if ((_c = (_b = this.images) == null ? void 0 : _b.depthImages) == null ? void 0 : _c.length) {
          const firstDepthPromise = this.loadFirstDepthMaps().then(() => {
            this.loadNextDepthMaps();
          });
          promises.push(firstDepthPromise);
        }
        if ((_d = this.images) == null ? void 0 : _d.noiseImage) {
          const noisePromise = this.loadNoiseTexture(this.images.noiseImage).then((texture) => {
            this.setNoiseTexture(texture);
          });
          promises.push(noisePromise);
        }
        if ((_e = this.images) == null ? void 0 : _e.maskImage) {
          const maskPromise = this.loadMaskTexture(this.images.maskImage).then((texture) => {
            this.setMaskTexture(texture);
            this.maskTexture = texture;
          });
          promises.push(maskPromise);
        }
        return Promise.all(promises).then(() => {
          this.onAssetsLoaded();
        });
      }
      onAssetsLoaded() {
        var _a, _b, _c;
        this.width = this.$el.offsetWidth;
        this.height = this.$el.offsetHeight;
        this.compute(this.width, this.height);
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.compute) == null ? void 0 : _a.call(rtTexturesInstance, this.width, this.height);
          rtTexturesInstancesIndex++;
        }
        (_b = this.setInitialUniforms) == null ? void 0 : _b.call(this);
        (_c = this.setTweens) == null ? void 0 : _c.call(this);
        this.isRenderReady = true;
        this.material.uniforms.uMaskProgress.value = 0;
        requestAnimationFrame(() => {
          if (!window.isNotFirstLoading) {
            window.isNotFirstLoading = true;
            this.revealExperience();
          } else {
            this.revealMin();
          }
        });
      }
      resize() {
        var _a;
        if (!this.isRenderReady)
          return;
        this.width = this.$el.offsetWidth;
        this.height = this.$el.offsetHeight;
        this.compute(this.width, this.height);
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.resize) == null ? void 0 : _a.call(rtTexturesInstance, this.width, this.height);
          rtTexturesInstancesIndex++;
        }
      }
      update(time, deltaTime, frame) {
        var _a;
        if (!this.isRenderReady)
          return;
        this.material.uniforms.uTime.value = time;
        this.updateHold();
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.update) == null ? void 0 : _a.call(rtTexturesInstance, time, deltaTime, frame);
          rtTexturesInstancesIndex++;
          this.renderer.setRenderTarget(rtTexturesInstance.rtTexture);
          this.renderer.render(rtTexturesInstance.scene, rtTexturesInstance.camera);
          this.renderer.setRenderTarget(null);
        }
        if (this.hasPostProcessing) {
          this.composer.render(this.scene, this.camera);
        } else {
          this.renderer.render(this.scene, this.camera);
        }
      }
      pointerDown() {
        var _a;
        this.pointerDownTime = Date.now();
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.pointerDown) == null ? void 0 : _a.call(rtTexturesInstance);
          rtTexturesInstancesIndex++;
        }
        this.holdDown();
      }
      pointerUp() {
        var _a;
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.pointerUp) == null ? void 0 : _a.call(rtTexturesInstance);
          rtTexturesInstancesIndex++;
        }
        this.holdUp();
      }
      mouseMove(mouseCoords) {
        var _a;
        let rtTexturesInstancesIndex = 0;
        while (rtTexturesInstancesIndex < this.rtTexturesInstances.length) {
          const rtTexturesInstance = this.rtTexturesInstances[rtTexturesInstancesIndex];
          (_a = rtTexturesInstance == null ? void 0 : rtTexturesInstance.mouseMove) == null ? void 0 : _a.call(rtTexturesInstance, mouseCoords);
          rtTexturesInstancesIndex++;
        }
      }
      mouseEnter() {
        if (this.isInteractiveAreaHovered || !this.hoverAnimationData.allowed)
          return;
        this.isInteractiveAreaHovered = true;
        this.animateHoverEnter();
      }
      mouseLeave() {
        if (!this.isInteractiveAreaHovered || this.holdData.isHolding || !this.hoverAnimationData.allowed)
          return;
        this.isInteractiveAreaHovered = false;
        this.animateHoverLeave();
      }
      click() {
        if (this.moduleInstance.hasHoldAvailable) {
          this.diveAnimation();
        }
      }
      createRenderer() {
        this.renderer = new WebGLRenderer({ alpha: true });
        this.renderer.setPixelRatio(this.normalizedDpr);
        this.renderer.setSize(this.width, this.height);
        this.renderer.setClearColor(0, 1);
        this.$el.appendChild(this.renderer.domElement);
      }
      postProcess() {
        const renderScene = new RenderPass(this.scene, this.camera);
        this.fxaaPass = new ShaderPass(FXAAShader);
        this.fxaaPass.material.uniforms["resolution"].value.x = 1 / (this.width * this.normalizedDpr);
        this.fxaaPass.material.uniforms["resolution"].value.y = 1 / (this.height * this.normalizedDpr);
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(renderScene);
        this.composer.addPass(this.fxaaPass);
        this.composer.setPixelRatio(this.normalizedDpr);
        this.composer.setSize(this.width, this.height);
      }
      setPlane() {
        const rtTexturesUniforms = {};
        EXPERIENCE_INSTANCES.forEach((experience) => {
          rtTexturesUniforms[experience.uniform] = { value: null };
        });
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: __spreadValues({
            uTime: { value: 0 },
            uResolution: { value: [0, 0] },
            uHasTextureSwapped: { value: false },
            uNoiseProgress: { value: 0 },
            uTextOpacityProgress: { value: 0 },
            uMaskProgress: { value: 0 },
            uMaskIdle: { value: 0 },
            uMaxMaskScale: { value: 0 },
            uMaskTexture: { value: null },
            uMaskTextureResolution: { value: [0, 0] },
            uNoiseTexture: { value: null },
            uNoiseTextureResolution: { value: [0, 0] },
            uDepthScale: { value: 1 },
            uDepthScaleStart: { value: 1 },
            uHoverProgress: { value: 0 }
          }, rtTexturesUniforms),
          vertexShader: vertex_default,
          fragmentShader: fragment_default3
        });
        const geometry = new PlaneGeometry(1, 1, 1, 1);
        const plane = new Mesh(geometry, this.material);
        this.scene.add(plane);
      }
      loadPortalTexture(src2) {
        return getTexture(src2).promise;
      }
      setPortalTexture(texture) {
        const portalInstance = this.rtTexturesInstances.find((item) => item.id === "portal");
        portalInstance.setTexture(texture);
      }
      loadMaskTexture(src2) {
        return getTexture(src2).promise;
      }
      setMaskTexture(texture) {
        var _a;
        (_a = this.setTextureUniforms) == null ? void 0 : _a.call(this, texture, "uMaskTexture");
      }
      loadNoiseTexture(src2) {
        return getTexture(src2).promise;
      }
      setNoiseTexture(texture) {
        var _a;
        texture.wrapT = RepeatWrapping;
        texture.repeat.set(1, 1);
        (_a = this.setTextureUniforms) == null ? void 0 : _a.call(this, texture, "uNoiseTexture");
      }
      loadFirstDepthMaps() {
        return new Promise((resolve) => {
          const depthmapTexturesPromises = [];
          if (this.images.depthImages[this.startTextureIndex]) {
            const depthStartTexturePromise = this.loadDepthStartTexture(this.images.depthImages[this.startTextureIndex].background, this.images.depthImages[this.startTextureIndex].depthmap);
            depthmapTexturesPromises.push(depthStartTexturePromise);
          }
          if (this.images.depthImages[this.endTextureIndex]) {
            const depthEndTexturePromise = this.loadDepthEndTexture(this.images.depthImages[this.endTextureIndex].background, this.images.depthImages[this.endTextureIndex].depthmap);
            depthmapTexturesPromises.push(depthEndTexturePromise);
          }
          Promise.all([...depthmapTexturesPromises]).then((values) => {
            this.updateDepthTextures();
            resolve();
          });
        });
      }
      loadNextDepthMaps() {
        var _a, _b;
        if (!((_b = (_a = this.images) == null ? void 0 : _a.depthImages) == null ? void 0 : _b.length))
          return new Promise((resolve) => resolve());
        this.startTextureIndex = this.endTextureIndex;
        this.endTextureIndex = (this.endTextureIndex + 1) % this.images.depthImages.length;
        const depthmapTexturesPromises = [];
        if (this.images.depthImages[this.startTextureIndex]) {
          const depthStartTexturePromise = this.loadDepthStartTexture(this.images.depthImages[this.startTextureIndex].background, this.images.depthImages[this.startTextureIndex].depthmap);
          depthmapTexturesPromises.push(depthStartTexturePromise);
        }
        if (this.images.depthImages[this.endTextureIndex]) {
          const depthEndTexturePromise = this.loadDepthEndTexture(this.images.depthImages[this.endTextureIndex].background, this.images.depthImages[this.endTextureIndex].depthmap);
          depthmapTexturesPromises.push(depthEndTexturePromise);
        }
        return Promise.all([...depthmapTexturesPromises]);
      }
      loadDepthStartTexture(backgroundSrc, depthmapSrc) {
        return new Promise((resolve) => __async(this, null, function* () {
          const backgroundTexture = yield getTexture(backgroundSrc).promise;
          const depthmapTexture = yield getTexture(depthmapSrc).promise;
          this.textures.depthStartBackground = backgroundTexture;
          this.textures.depthStartDepthmap = depthmapTexture;
          resolve([backgroundTexture, depthmapTexture]);
        }));
      }
      loadDepthEndTexture(backgroundSrc, depthmapSrc) {
        return new Promise((resolve) => __async(this, null, function* () {
          const backgroundTexture = yield getTexture(backgroundSrc).promise;
          const depthmapTexture = yield getTexture(depthmapSrc).promise;
          this.textures.depthEndBackground = backgroundTexture;
          this.textures.depthEndDepthmap = depthmapTexture;
          resolve([backgroundTexture, depthmapTexture]);
        }));
      }
      setDepthStartTexture() {
        const depthStartInstance = this.rtTexturesInstances.find((item) => item.id === "depthStart");
        depthStartInstance.setTextures(this.textures.depthStartBackground, this.textures.depthStartDepthmap);
      }
      setDepthEndTexture() {
        const depthEndInstance = this.rtTexturesInstances.find((item) => item.id === "depthEnd");
        depthEndInstance.setTextures(this.textures.depthEndBackground, this.textures.depthEndDepthmap);
      }
      updateDepthTextures() {
        this.textures.depthStartBackground && this.textures.depthStartDepthmap && this.setDepthStartTexture();
        this.textures.depthEndBackground && this.textures.depthEndDepthmap && this.setDepthEndTexture();
        this.material.uniforms.uHasTextureSwapped.value = true;
      }
      reset() {
        var _a, _b, _c;
        const maskTextureScale = this.computeMaskTextureScale(this.maskTexture);
        this.maskData.maxScale = (_a = this.setMaxMaskScaleUniforms) == null ? void 0 : _a.call(this, maskTextureScale);
        this.moduleInstance.call("updateScale", maskTextureScale, "Logo");
        this.setInteractiveAreaWidth(maskTextureScale);
        (_b = this.setMaskIdleUniforms) == null ? void 0 : _b.call(this);
        this.resetMaskAnimation();
        (_c = this.setMaskProgressUniforms) == null ? void 0 : _c.call(this);
        this.resetHoldAnimation();
      }
      resetMaskAnimation() {
        this.maskAnimationData.value = this.maskData.idle;
      }
      resetHoldAnimation() {
        this.holdAnimationData.targetIn = this.maskData.idle * this.holdAnimationData.scaleMultiplier;
        this.holdAnimationData.targetOut = this.maskData.idle;
        this.holdAnimationData.value = this.maskData.idle;
      }
      compute(width, height) {
        var _a;
        (_a = this.setResolutionUniforms) == null ? void 0 : _a.call(this, width * this.normalizedDpr, height * this.normalizedDpr);
        this.reset();
        this.renderer.setSize(width, height);
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.fxaaPass.material.uniforms["resolution"].value.x = 1 / (this.width * this.normalizedDpr);
        this.fxaaPass.material.uniforms["resolution"].value.y = 1 / (this.height * this.normalizedDpr);
        this.composer.setPixelRatio(this.normalizedDpr);
        this.composer.setSize(this.width, this.height);
      }
      computeMaskTextureScale(maskTexture) {
        if (!maskTexture)
          return 1;
        const canvasWidth = this.$el.offsetWidth;
        const canvasHeight = this.$el.offsetHeight;
        const originalTexWidth = maskTexture.image.width;
        const originalTexHeight = maskTexture.image.height;
        const tAspect = originalTexWidth / originalTexHeight;
        const pAspect = canvasWidth / canvasHeight;
        const pwidth = canvasWidth;
        const pheight = canvasHeight;
        let currentTexWidth = 0;
        if (tAspect > pAspect) {
          currentTexWidth = pheight * tAspect;
        } else {
          currentTexWidth = pwidth;
        }
        return currentTexWidth / originalTexWidth;
      }
      setInteractiveAreaWidth(textureScale) {
        const portalWidth = Math.round(DEFAULT_PORTAL_WIDTH2 * textureScale);
        const portalRadius = portalWidth * 0.5;
        this.moduleInstance.$interactiveArea.style.width = `${portalWidth}px`;
        this.moduleInstance.$interactiveArea.style.borderRadius = `${portalRadius}px ${portalRadius}px 0 0`;
      }
      revealExperience() {
        this.revealFull();
      }
      setupPane() {
        this.paneObj.pane.addInput(this, "hasPostProcessing", {
          label: "FXAA"
        });
        const dataFolder = this.paneObj.pane.addFolder({
          title: "Import/Export",
          expanded: false
        });
        dataFolder.addButton({
          title: "Import"
        }).on("click", () => {
          openFileDialog(".json,application/json", (e) => {
            const reader = new FileReader();
            reader.addEventListener("load", (event2) => {
              const result = JSON.parse(event2.currentTarget.result);
              this.paneObj.pane.importPreset(result);
            });
            reader.readAsText(e.target.files[0]);
          });
        });
        dataFolder.addButton({
          title: "Export"
        }).on("click", () => {
          const preset = JSON.stringify(this.paneObj.pane.exportPreset());
          const hiddenElement = document.createElement("a");
          hiddenElement.href = "data:application/json," + encodeURI(preset);
          hiddenElement.target = "_blank";
          hiddenElement.download = `preset_${Date.now()}.json`;
          hiddenElement.click();
        });
      }
    };
  
    // assets/scripts/modules/Experiences.js
    var PANE_ENABLED = false;
    var Experiences_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.onUpdateBind = this.onUpdate.bind(this);
        this.onPointerDownBind = this.onPointerDown.bind(this);
        this.onPointerUpBind = this.onPointerUp.bind(this);
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.$navItems = this.$("navItem");
        this.$inner = this.$("inner")[0];
        this.$overlay = this.$("overlay")[0];
        this.$interactiveArea = this.$("interactiveArea")[0];
        this.$navItems = this.$("navItem");
        this.isRafPlaying = false;
        this.hasHoldAvailable = false;
        this.imagesData = this.getData("images");
        this.hasAssetsLoaded = false;
      }
      init() {
        var _a;
        if (!this.imagesData) {
          console.warn("You need images to start the experience");
        }
        this.images = JSON.parse(this.imagesData);
        (_a = this._init) == null ? void 0 : _a.call(this);
        if (PANE_ENABLED) {
          this.createPane();
          this.setupPane();
        }
        this.initCanvas();
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
        this.call("stop", null, "Scroll");
        requestAnimationFrame(() => {
          this.call("setCursorState", "", "Cursor");
        });
      }
      destroy() {
        var _a, _b, _c;
        super.destroy();
        (_a = this._destroy) == null ? void 0 : _a.call(this);
        this.unbindEvents();
        this.pause();
        (_c = (_b = this.canvas) == null ? void 0 : _b.destroy) == null ? void 0 : _c.call(_b);
      }
      bindEvents() {
        var _a, _b, _c, _d;
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
        this.el.addEventListener("pointerdown", this.onPointerDownBind);
        this.el.addEventListener("pointerleave", this.onPointerUpBind);
        this.el.addEventListener("pointerup", this.onPointerUpBind);
        (_a = this.$interactiveArea) == null ? void 0 : _a.addEventListener("mouseenter", this.onMouseEnterBind);
        (_b = this.$interactiveArea) == null ? void 0 : _b.addEventListener("mouseleave", this.onMouseLeaveBind);
        (_c = this.$interactiveArea) == null ? void 0 : _c.addEventListener("pointerdown", this.onPointerDownBind);
        (_d = this.$interactiveArea) == null ? void 0 : _d.addEventListener("pointerup", this.onPointerUpBind);
      }
      unbindEvents() {
        var _a, _b, _c, _d;
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
        this.el.removeEventListener("pointerdown", this.onPointerDownBind);
        this.el.removeEventListener("pointerleave", this.onPointerUpBind);
        this.el.removeEventListener("pointerup", this.onPointerUpBind);
        (_a = this.$interactiveArea) == null ? void 0 : _a.removeEventListener("mouseenter", this.onMouseEnterBind);
        (_b = this.$interactiveArea) == null ? void 0 : _b.removeEventListener("mouseleave", this.onMouseLeaveBind);
        (_c = this.$interactiveArea) == null ? void 0 : _c.removeEventListener("pointerdown", this.onPointerDownBind);
        (_d = this.$interactiveArea) == null ? void 0 : _d.removeEventListener("pointerup", this.onPointerUpBind);
      }
      onResize() {
        var _a, _b;
        (_b = (_a = this.canvas) == null ? void 0 : _a.resize) == null ? void 0 : _b.call(_a);
      }
      onFontsLoaded() {
        var _a, _b, _c, _d;
        (_b = (_a = this.canvas) == null ? void 0 : _a.resize) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.canvas) == null ? void 0 : _c.loadAssets) == null ? void 0 : _d.call(_c).then(() => {
          const experienceEvent = new CustomEvent("experienceReady");
          window.dispatchEvent(experienceEvent);
          this.hasAssetsLoaded = true;
        });
      }
      onUpdate(time, deltaTime, frame) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (_b = (_a = this.fpsGraph) == null ? void 0 : _a.begin) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.canvas) == null ? void 0 : _c.update) == null ? void 0 : _d.call(_c, time, deltaTime, frame);
        (_f = (_e = this.canvas) == null ? void 0 : _e.mouseMove) == null ? void 0 : _f.call(_e, {
          x: Mouse_default.x,
          y: Mouse_default.y,
          smoothX: Mouse_default.smoothX,
          smoothY: Mouse_default.smoothY
        });
        (_h = (_g = this.fpsGraph) == null ? void 0 : _g.end) == null ? void 0 : _h.call(_g);
      }
      onPointerDown(e) {
        var _a, _b;
        this.pointerDownTime = Date.now();
        if (e.pointerType != "touch")
          (_b = (_a = this.canvas) == null ? void 0 : _a.pointerDown) == null ? void 0 : _b.call(_a);
      }
      onPointerUp(e) {
        var _a, _b, _c, _d;
        if (e.pointerType != "touch")
          (_b = (_a = this.canvas) == null ? void 0 : _a.pointerUp) == null ? void 0 : _b.call(_a);
        if (e.currentTarget == this.$interactiveArea) {
          if (Date.now() - this.pointerDownTime < 100) {
            (_d = (_c = this.canvas) == null ? void 0 : _c.click) == null ? void 0 : _d.call(_c, e);
          }
        }
      }
      onMouseEnter() {
        var _a, _b;
        (_b = (_a = this.canvas) == null ? void 0 : _a.mouseEnter) == null ? void 0 : _b.call(_a);
      }
      onMouseLeave() {
        var _a, _b;
        (_b = (_a = this.canvas) == null ? void 0 : _a.mouseLeave) == null ? void 0 : _b.call(_a);
      }
      onProgress(progress) {
        if (this.$inner) {
          gsapWithCSS2.set(this.$inner, { y: `${progress * -10}%`, scale: 1 + progress * 0.1, force3D: true });
          gsapWithCSS2.set(this.$overlay, { opacity: progress * 0.8 });
        }
      }
      initCanvas() {
        this.canvas = new Experiences({
          $el: this.$inner,
          moduleInstance: this,
          images: this.images,
          paneObj: this.paneObj
        });
      }
      revealExperience() {
        var _a, _b;
        (_b = (_a = this.canvas) == null ? void 0 : _a.revealExperience) == null ? void 0 : _b.call(_a);
      }
      play() {
        if (this.isRafPlaying)
          return;
        this.isRafPlaying = true;
        if (this.hasAssetsLoaded) {
          this.hasHoldAvailable = true;
        }
        gsapWithCSS2.ticker.add(this.onUpdateBind);
      }
      pause() {
        if (!this.isRafPlaying)
          return;
        this.isRafPlaying = false;
        this.hasHoldAvailable = false;
        gsapWithCSS2.ticker.remove(this.onUpdateBind);
      }
      createPane() {
        this.paneObj = {};
        this.paneObj.pane = new Pane();
        this.paneObj.pane.registerPlugin(EssentialsPlugin);
        this.paneObj.params = {};
        this.paneObj.pane.containerElem_.style.zIndex = 1e3;
        this.paneObj.pane.hidden = true;
        const onKeyUp = (e) => {
          if (e.key == "Escape") {
            this.paneObj.pane.hidden = !this.paneObj.pane.hidden;
          }
        };
        window.addEventListener("keyup", onKeyUp);
      }
      setupPane() {
        this.paneObj.pane.addButton({
          title: "Close"
        }).on("click", () => {
          this.paneObj.pane.hidden = true;
        });
        this.fpsGraph = this.paneObj.pane.addBlade({
          view: "fpsgraph",
          label: "fpsgraph",
          lineCount: 2,
          interval: 80
        });
      }
    };
  
    // node_modules/ssr-window/ssr-window.esm.js
    function isObject(obj) {
      return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
    }
    function extend(target = {}, src2 = {}) {
      Object.keys(src2).forEach((key) => {
        if (typeof target[key] === "undefined")
          target[key] = src2[key];
        else if (isObject(src2[key]) && isObject(target[key]) && Object.keys(src2[key]).length > 0) {
          extend(target[key], src2[key]);
        }
      });
    }
    var ssrDocument = {
      body: {},
      addEventListener() {
      },
      removeEventListener() {
      },
      activeElement: {
        blur() {
        },
        nodeName: ""
      },
      querySelector() {
        return null;
      },
      querySelectorAll() {
        return [];
      },
      getElementById() {
        return null;
      },
      createEvent() {
        return {
          initEvent() {
          }
        };
      },
      createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {
          },
          getElementsByTagName() {
            return [];
          }
        };
      },
      createElementNS() {
        return {};
      },
      importNode() {
        return null;
      },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
      }
    };
    function getDocument() {
      const doc = typeof document !== "undefined" ? document : {};
      extend(doc, ssrDocument);
      return doc;
    }
    var ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ""
      },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
      },
      history: {
        replaceState() {
        },
        pushState() {
        },
        go() {
        },
        back() {
        }
      },
      CustomEvent: function CustomEvent2() {
        return this;
      },
      addEventListener() {
      },
      removeEventListener() {
      },
      getComputedStyle() {
        return {
          getPropertyValue() {
            return "";
          }
        };
      },
      Image() {
      },
      Date() {
      },
      screen: {},
      setTimeout() {
      },
      clearTimeout() {
      },
      matchMedia() {
        return {};
      },
      requestAnimationFrame(callback) {
        if (typeof setTimeout === "undefined") {
          callback();
          return null;
        }
        return setTimeout(callback, 0);
      },
      cancelAnimationFrame(id2) {
        if (typeof setTimeout === "undefined") {
          return;
        }
        clearTimeout(id2);
      }
    };
    function getWindow() {
      const win = typeof window !== "undefined" ? window : {};
      extend(win, ssrWindow);
      return win;
    }
  
    // node_modules/dom7/dom7.esm.js
    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, "__proto__", {
        get() {
          return proto;
        },
        set(value) {
          proto.__proto__ = value;
        }
      });
    }
    var Dom7 = class extends Array {
      constructor(items) {
        if (typeof items === "number") {
          super(items);
        } else {
          super(...items || []);
          makeReactive(this);
        }
      }
    };
    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach((el) => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      const uniqueArray = [];
      for (let i2 = 0; i2 < arr.length; i2 += 1) {
        if (uniqueArray.indexOf(arr[i2]) === -1)
          uniqueArray.push(arr[i2]);
      }
      return uniqueArray;
    }
    function qsa(selector3, context3) {
      if (typeof selector3 !== "string") {
        return [selector3];
      }
      const a = [];
      const res = context3.querySelectorAll(selector3);
      for (let i2 = 0; i2 < res.length; i2 += 1) {
        a.push(res[i2]);
      }
      return a;
    }
    function $(selector3, context3) {
      const window2 = getWindow();
      const document2 = getDocument();
      let arr = [];
      if (!context3 && selector3 instanceof Dom7) {
        return selector3;
      }
      if (!selector3) {
        return new Dom7(arr);
      }
      if (typeof selector3 === "string") {
        const html3 = selector3.trim();
        if (html3.indexOf("<") >= 0 && html3.indexOf(">") >= 0) {
          let toCreate = "div";
          if (html3.indexOf("<li") === 0)
            toCreate = "ul";
          if (html3.indexOf("<tr") === 0)
            toCreate = "tbody";
          if (html3.indexOf("<td") === 0 || html3.indexOf("<th") === 0)
            toCreate = "tr";
          if (html3.indexOf("<tbody") === 0)
            toCreate = "table";
          if (html3.indexOf("<option") === 0)
            toCreate = "select";
          const tempParent = document2.createElement(toCreate);
          tempParent.innerHTML = html3;
          for (let i2 = 0; i2 < tempParent.childNodes.length; i2 += 1) {
            arr.push(tempParent.childNodes[i2]);
          }
        } else {
          arr = qsa(selector3.trim(), context3 || document2);
        }
      } else if (selector3.nodeType || selector3 === window2 || selector3 === document2) {
        arr.push(selector3);
      } else if (Array.isArray(selector3)) {
        if (selector3 instanceof Dom7)
          return selector3;
        arr = selector3;
      }
      return new Dom7(arrayUnique(arr));
    }
    $.fn = Dom7.prototype;
    function addClass(...classes) {
      const classNames = arrayFlat(classes.map((c) => c.split(" ")));
      this.forEach((el) => {
        el.classList.add(...classNames);
      });
      return this;
    }
    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map((c) => c.split(" ")));
      this.forEach((el) => {
        el.classList.remove(...classNames);
      });
      return this;
    }
    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map((c) => c.split(" ")));
      this.forEach((el) => {
        classNames.forEach((className) => {
          el.classList.toggle(className);
        });
      });
    }
    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map((c) => c.split(" ")));
      return arrayFilter(this, (el) => {
        return classNames.filter((className) => el.classList.contains(className)).length > 0;
      }).length > 0;
    }
    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === "string") {
        if (this[0])
          return this[0].getAttribute(attrs);
        return void 0;
      }
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        if (arguments.length === 2) {
          this[i2].setAttribute(attrs, value);
        } else {
          for (const attrName in attrs) {
            this[i2][attrName] = attrs[attrName];
            this[i2].setAttribute(attrName, attrs[attrName]);
          }
        }
      }
      return this;
    }
    function removeAttr(attr2) {
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        this[i2].removeAttribute(attr2);
      }
      return this;
    }
    function transform(transform3) {
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        this[i2].style.transform = transform3;
      }
      return this;
    }
    function transition(duration) {
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        this[i2].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
      }
      return this;
    }
    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;
      if (typeof args[1] === "function") {
        [eventType, listener, capture] = args;
        targetSelector = void 0;
      }
      if (!capture)
        capture = false;
      function handleLiveEvent(e) {
        const target = e.target;
        if (!target)
          return;
        const eventData = e.target.dom7EventData || [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        if ($(target).is(targetSelector))
          listener.apply(target, eventData);
        else {
          const parents2 = $(target).parents();
          for (let k = 0; k < parents2.length; k += 1) {
            if ($(parents2[k]).is(targetSelector))
              listener.apply(parents2[k], eventData);
          }
        }
      }
      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        listener.apply(this, eventData);
      }
      const events2 = eventType.split(" ");
      let j;
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        const el = this[i2];
        if (!targetSelector) {
          for (j = 0; j < events2.length; j += 1) {
            const event2 = events2[j];
            if (!el.dom7Listeners)
              el.dom7Listeners = {};
            if (!el.dom7Listeners[event2])
              el.dom7Listeners[event2] = [];
            el.dom7Listeners[event2].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event2, handleEvent, capture);
          }
        } else {
          for (j = 0; j < events2.length; j += 1) {
            const event2 = events2[j];
            if (!el.dom7LiveListeners)
              el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event2])
              el.dom7LiveListeners[event2] = [];
            el.dom7LiveListeners[event2].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event2, handleLiveEvent, capture);
          }
        }
      }
      return this;
    }
    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;
      if (typeof args[1] === "function") {
        [eventType, listener, capture] = args;
        targetSelector = void 0;
      }
      if (!capture)
        capture = false;
      const events2 = eventType.split(" ");
      for (let i2 = 0; i2 < events2.length; i2 += 1) {
        const event2 = events2[i2];
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;
          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event2];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event2];
          }
          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];
              if (listener && handler.listener === listener) {
                el.removeEventListener(event2, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event2, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event2, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }
      return this;
    }
    function trigger(...args) {
      const window2 = getWindow();
      const events2 = args[0].split(" ");
      const eventData = args[1];
      for (let i2 = 0; i2 < events2.length; i2 += 1) {
        const event2 = events2[i2];
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          if (window2.CustomEvent) {
            const evt = new window2.CustomEvent(event2, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }
      return this;
    }
    function transitionEnd(callback) {
      const dom = this;
      function fireCallBack(e) {
        if (e.target !== this)
          return;
        callback.call(this, e);
        dom.off("transitionend", fireCallBack);
      }
      if (callback) {
        dom.on("transitionend", fireCallBack);
      }
      return this;
    }
    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles2 = this.styles();
          return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
        }
        return this[0].offsetWidth;
      }
      return null;
    }
    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles2 = this.styles();
          return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
        }
        return this[0].offsetHeight;
      }
      return null;
    }
    function offset() {
      if (this.length > 0) {
        const window2 = getWindow();
        const document2 = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body2 = document2.body;
        const clientTop = el.clientTop || body2.clientTop || 0;
        const clientLeft = el.clientLeft || body2.clientLeft || 0;
        const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
        const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }
      return null;
    }
    function styles() {
      const window2 = getWindow();
      if (this[0])
        return window2.getComputedStyle(this[0], null);
      return {};
    }
    function css(props, value) {
      const window2 = getWindow();
      let i2;
      if (arguments.length === 1) {
        if (typeof props === "string") {
          if (this[0])
            return window2.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          for (i2 = 0; i2 < this.length; i2 += 1) {
            for (const prop in props) {
              this[i2].style[prop] = props[prop];
            }
          }
          return this;
        }
      }
      if (arguments.length === 2 && typeof props === "string") {
        for (i2 = 0; i2 < this.length; i2 += 1) {
          this[i2].style[props] = value;
        }
        return this;
      }
      return this;
    }
    function each(callback) {
      if (!callback)
        return this;
      this.forEach((el, index2) => {
        callback.apply(el, [el, index2]);
      });
      return this;
    }
    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }
    function html2(html3) {
      if (typeof html3 === "undefined") {
        return this[0] ? this[0].innerHTML : null;
      }
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        this[i2].innerHTML = html3;
      }
      return this;
    }
    function text(text2) {
      if (typeof text2 === "undefined") {
        return this[0] ? this[0].textContent.trim() : null;
      }
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        this[i2].textContent = text2;
      }
      return this;
    }
    function is(selector3) {
      const window2 = getWindow();
      const document2 = getDocument();
      const el = this[0];
      let compareWith;
      let i2;
      if (!el || typeof selector3 === "undefined")
        return false;
      if (typeof selector3 === "string") {
        if (el.matches)
          return el.matches(selector3);
        if (el.webkitMatchesSelector)
          return el.webkitMatchesSelector(selector3);
        if (el.msMatchesSelector)
          return el.msMatchesSelector(selector3);
        compareWith = $(selector3);
        for (i2 = 0; i2 < compareWith.length; i2 += 1) {
          if (compareWith[i2] === el)
            return true;
        }
        return false;
      }
      if (selector3 === document2) {
        return el === document2;
      }
      if (selector3 === window2) {
        return el === window2;
      }
      if (selector3.nodeType || selector3 instanceof Dom7) {
        compareWith = selector3.nodeType ? [selector3] : selector3;
        for (i2 = 0; i2 < compareWith.length; i2 += 1) {
          if (compareWith[i2] === el)
            return true;
        }
        return false;
      }
      return false;
    }
    function index() {
      let child = this[0];
      let i2;
      if (child) {
        i2 = 0;
        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1)
            i2 += 1;
        }
        return i2;
      }
      return void 0;
    }
    function eq(index2) {
      if (typeof index2 === "undefined")
        return this;
      const length = this.length;
      if (index2 > length - 1) {
        return $([]);
      }
      if (index2 < 0) {
        const returnIndex = length + index2;
        if (returnIndex < 0)
          return $([]);
        return $([this[returnIndex]]);
      }
      return $([this[index2]]);
    }
    function append(...els) {
      let newChild;
      const document2 = getDocument();
      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];
        for (let i2 = 0; i2 < this.length; i2 += 1) {
          if (typeof newChild === "string") {
            const tempDiv = document2.createElement("div");
            tempDiv.innerHTML = newChild;
            while (tempDiv.firstChild) {
              this[i2].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i2].appendChild(newChild[j]);
            }
          } else {
            this[i2].appendChild(newChild);
          }
        }
      }
      return this;
    }
    function prepend(newChild) {
      const document2 = getDocument();
      let i2;
      let j;
      for (i2 = 0; i2 < this.length; i2 += 1) {
        if (typeof newChild === "string") {
          const tempDiv = document2.createElement("div");
          tempDiv.innerHTML = newChild;
          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i2].insertBefore(tempDiv.childNodes[j], this[i2].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i2].insertBefore(newChild[j], this[i2].childNodes[0]);
          }
        } else {
          this[i2].insertBefore(newChild, this[i2].childNodes[0]);
        }
      }
      return this;
    }
    function next(selector3) {
      if (this.length > 0) {
        if (selector3) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector3)) {
            return $([this[0].nextElementSibling]);
          }
          return $([]);
        }
        if (this[0].nextElementSibling)
          return $([this[0].nextElementSibling]);
        return $([]);
      }
      return $([]);
    }
    function nextAll(selector3) {
      const nextEls = [];
      let el = this[0];
      if (!el)
        return $([]);
      while (el.nextElementSibling) {
        const next2 = el.nextElementSibling;
        if (selector3) {
          if ($(next2).is(selector3))
            nextEls.push(next2);
        } else
          nextEls.push(next2);
        el = next2;
      }
      return $(nextEls);
    }
    function prev(selector3) {
      if (this.length > 0) {
        const el = this[0];
        if (selector3) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector3)) {
            return $([el.previousElementSibling]);
          }
          return $([]);
        }
        if (el.previousElementSibling)
          return $([el.previousElementSibling]);
        return $([]);
      }
      return $([]);
    }
    function prevAll(selector3) {
      const prevEls = [];
      let el = this[0];
      if (!el)
        return $([]);
      while (el.previousElementSibling) {
        const prev2 = el.previousElementSibling;
        if (selector3) {
          if ($(prev2).is(selector3))
            prevEls.push(prev2);
        } else
          prevEls.push(prev2);
        el = prev2;
      }
      return $(prevEls);
    }
    function parent(selector3) {
      const parents2 = [];
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        if (this[i2].parentNode !== null) {
          if (selector3) {
            if ($(this[i2].parentNode).is(selector3))
              parents2.push(this[i2].parentNode);
          } else {
            parents2.push(this[i2].parentNode);
          }
        }
      }
      return $(parents2);
    }
    function parents(selector3) {
      const parents2 = [];
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        let parent2 = this[i2].parentNode;
        while (parent2) {
          if (selector3) {
            if ($(parent2).is(selector3))
              parents2.push(parent2);
          } else {
            parents2.push(parent2);
          }
          parent2 = parent2.parentNode;
        }
      }
      return $(parents2);
    }
    function closest(selector3) {
      let closest2 = this;
      if (typeof selector3 === "undefined") {
        return $([]);
      }
      if (!closest2.is(selector3)) {
        closest2 = closest2.parents(selector3).eq(0);
      }
      return closest2;
    }
    function find(selector3) {
      const foundElements = [];
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        const found = this[i2].querySelectorAll(selector3);
        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }
      return $(foundElements);
    }
    function children(selector3) {
      const children2 = [];
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        const childNodes = this[i2].children;
        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector3 || $(childNodes[j]).is(selector3)) {
            children2.push(childNodes[j]);
          }
        }
      }
      return $(children2);
    }
    function remove() {
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        if (this[i2].parentNode)
          this[i2].parentNode.removeChild(this[i2]);
      }
      return this;
    }
    var noTrigger = "resize scroll".split(" ");
    function shortcut(name) {
      function eventHandler(...args) {
        if (typeof args[0] === "undefined") {
          for (let i2 = 0; i2 < this.length; i2 += 1) {
            if (noTrigger.indexOf(name) < 0) {
              if (name in this[i2])
                this[i2][name]();
              else {
                $(this[i2]).trigger(name);
              }
            }
          }
          return this;
        }
        return this.on(name, ...args);
      }
      return eventHandler;
    }
    var click = shortcut("click");
    var blur = shortcut("blur");
    var focus = shortcut("focus");
    var focusin = shortcut("focusin");
    var focusout = shortcut("focusout");
    var keyup = shortcut("keyup");
    var keydown = shortcut("keydown");
    var keypress = shortcut("keypress");
    var submit = shortcut("submit");
    var change = shortcut("change");
    var mousedown = shortcut("mousedown");
    var mousemove = shortcut("mousemove");
    var mouseup = shortcut("mouseup");
    var mouseenter = shortcut("mouseenter");
    var mouseleave = shortcut("mouseleave");
    var mouseout = shortcut("mouseout");
    var mouseover = shortcut("mouseover");
    var touchstart = shortcut("touchstart");
    var touchend = shortcut("touchend");
    var touchmove = shortcut("touchmove");
    var resize = shortcut("resize");
    var scroll = shortcut("scroll");
  
    // node_modules/swiper/shared/dom.js
    var Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition,
      on,
      off,
      trigger,
      transitionEnd,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html: html2,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove
    };
    Object.keys(Methods).forEach((methodName) => {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });
    var dom_default = $;
  
    // node_modules/swiper/shared/utils.js
    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach((key) => {
        try {
          object[key] = null;
        } catch (e) {
        }
        try {
          delete object[key];
        } catch (e) {
        }
      });
    }
    function nextTick(callback, delay3) {
      if (delay3 === void 0) {
        delay3 = 0;
      }
      return setTimeout(callback, delay3);
    }
    function now2() {
      return Date.now();
    }
    function getComputedStyle2(el) {
      const window2 = getWindow();
      let style;
      if (window2.getComputedStyle) {
        style = window2.getComputedStyle(el, null);
      }
      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }
      if (!style) {
        style = el.style;
      }
      return style;
    }
    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = "x";
      }
      const window2 = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle2(el, null);
      if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) {
          curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
        }
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
      }
      if (axis === "x") {
        if (window2.WebKitCSSMatrix)
          curTransform = transformMatrix.m41;
        else if (matrix.length === 16)
          curTransform = parseFloat(matrix[12]);
        else
          curTransform = parseFloat(matrix[4]);
      }
      if (axis === "y") {
        if (window2.WebKitCSSMatrix)
          curTransform = transformMatrix.m42;
        else if (matrix.length === 16)
          curTransform = parseFloat(matrix[13]);
        else
          curTransform = parseFloat(matrix[5]);
      }
      return curTransform || 0;
    }
    function isObject2(o) {
      return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
    }
    function isNode(node) {
      if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
        return node instanceof HTMLElement;
      }
      return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend2() {
      const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
      const noExtend = ["__proto__", "constructor", "prototype"];
      for (let i2 = 1; i2 < arguments.length; i2 += 1) {
        const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) {
              if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend2(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
                to[nextKey] = {};
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend2(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to;
    }
    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
      let {
        swiper,
        targetPosition,
        side
      } = _ref;
      const window2 = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = "none";
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? "next" : "prev";
      const isOutOfBound = (current, target) => {
        return dir === "next" && current >= target || dir === "prev" && current <= target;
      };
      const animate = () => {
        time = new Date().getTime();
        if (startTime === null) {
          startTime = time;
        }
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = "hidden";
          swiper.wrapperEl.style.scrollSnapType = "";
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = "";
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window2.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }
        swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
      };
      animate();
    }
  
    // node_modules/swiper/shared/get-support.js
    var support;
    function calcSupport() {
      const window2 = getWindow();
      const document2 = getDocument();
      return {
        smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          let supportsPassive = false;
          try {
            const opts = Object.defineProperty({}, "passive", {
              get() {
                supportsPassive = true;
              }
            });
            window2.addEventListener("testPassiveListener", null, opts);
          } catch (e) {
          }
          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return "ongesturestart" in window2;
        }()
      };
    }
    function getSupport() {
      if (!support) {
        support = calcSupport();
      }
      return support;
    }
  
    // node_modules/swiper/shared/get-device.js
    var deviceCached;
    function calcDevice(_temp) {
      let {
        userAgent
      } = _temp === void 0 ? {} : _temp;
      const support3 = getSupport();
      const window2 = getWindow();
      const platform = window2.navigator.platform;
      const ua = userAgent || window2.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window2.screen.width;
      const screenHeight = window2.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === "Win32";
      let macos = platform === "MacIntel";
      const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
      if (!ipad && macos && support3.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad)
          ipad = [0, 1, "13_0_0"];
        macos = false;
      }
      if (android && !windows) {
        device.os = "android";
        device.android = true;
      }
      if (ipad || iphone || ipod) {
        device.os = "ios";
        device.ios = true;
      }
      return device;
    }
    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }
      return deviceCached;
    }
  
    // node_modules/swiper/shared/get-browser.js
    var browser;
    function calcBrowser() {
      const window2 = getWindow();
      function isSafari() {
        const ua = window2.navigator.userAgent.toLowerCase();
        return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
      }
      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
      };
    }
    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }
      return browser;
    }
  
    // node_modules/swiper/core/modules/resize/resize.js
    function Resize(_ref) {
      let {
        swiper,
        on: on2,
        emit
      } = _ref;
      const window2 = getWindow();
      let observer = null;
      let animationFrame = null;
      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized)
          return;
        emit("beforeResize");
        emit("resize");
      };
      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized)
          return;
        observer = new ResizeObserver((entries) => {
          animationFrame = window2.requestAnimationFrame(() => {
            const {
              width,
              height
            } = swiper;
            let newWidth = width;
            let newHeight = height;
            entries.forEach((_ref2) => {
              let {
                contentBoxSize,
                contentRect,
                target
              } = _ref2;
              if (target && target !== swiper.el)
                return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width || newHeight !== height) {
              resizeHandler();
            }
          });
        });
        observer.observe(swiper.el);
      };
      const removeObserver = () => {
        if (animationFrame) {
          window2.cancelAnimationFrame(animationFrame);
        }
        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };
      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized)
          return;
        emit("orientationchange");
      };
      on2("init", () => {
        if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
          createObserver();
          return;
        }
        window2.addEventListener("resize", resizeHandler);
        window2.addEventListener("orientationchange", orientationChangeHandler);
      });
      on2("destroy", () => {
        removeObserver();
        window2.removeEventListener("resize", resizeHandler);
        window2.removeEventListener("orientationchange", orientationChangeHandler);
      });
    }
  
    // node_modules/swiper/core/modules/observer/observer.js
    function Observer(_ref) {
      let {
        swiper,
        extendParams,
        on: on2,
        emit
      } = _ref;
      const observers = [];
      const window2 = getWindow();
      const attach = function(target, options) {
        if (options === void 0) {
          options = {};
        }
        const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations) => {
          if (mutations.length === 1) {
            emit("observerUpdate", mutations[0]);
            return;
          }
          const observerUpdate = function observerUpdate2() {
            emit("observerUpdate", mutations[0]);
          };
          if (window2.requestAnimationFrame) {
            window2.requestAnimationFrame(observerUpdate);
          } else {
            window2.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === "undefined" ? true : options.attributes,
          childList: typeof options.childList === "undefined" ? true : options.childList,
          characterData: typeof options.characterData === "undefined" ? true : options.characterData
        });
        observers.push(observer);
      };
      const init6 = () => {
        if (!swiper.params.observer)
          return;
        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();
          for (let i2 = 0; i2 < containerParents.length; i2 += 1) {
            attach(containerParents[i2]);
          }
        }
        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        });
        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };
      const destroy = () => {
        observers.forEach((observer) => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };
      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on2("init", init6);
      on2("destroy", destroy);
    }
  
    // node_modules/swiper/core/events-emitter.js
    var events_emitter_default = {
      on(events2, handler, priority) {
        const self2 = this;
        if (typeof handler !== "function")
          return self2;
        const method = priority ? "unshift" : "push";
        events2.split(" ").forEach((event2) => {
          if (!self2.eventsListeners[event2])
            self2.eventsListeners[event2] = [];
          self2.eventsListeners[event2][method](handler);
        });
        return self2;
      },
      once(events2, handler, priority) {
        const self2 = this;
        if (typeof handler !== "function")
          return self2;
        function onceHandler() {
          self2.off(events2, onceHandler);
          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events2, onceHandler, priority);
      },
      onAny(handler, priority) {
        const self2 = this;
        if (typeof handler !== "function")
          return self2;
        const method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) {
          self2.eventsAnyListeners[method](handler);
        }
        return self2;
      },
      offAny(handler) {
        const self2 = this;
        if (!self2.eventsAnyListeners)
          return self2;
        const index2 = self2.eventsAnyListeners.indexOf(handler);
        if (index2 >= 0) {
          self2.eventsAnyListeners.splice(index2, 1);
        }
        return self2;
      },
      off(events2, handler) {
        const self2 = this;
        if (!self2.eventsListeners)
          return self2;
        events2.split(" ").forEach((event2) => {
          if (typeof handler === "undefined") {
            self2.eventsListeners[event2] = [];
          } else if (self2.eventsListeners[event2]) {
            self2.eventsListeners[event2].forEach((eventHandler, index2) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self2.eventsListeners[event2].splice(index2, 1);
              }
            });
          }
        });
        return self2;
      },
      emit() {
        const self2 = this;
        if (!self2.eventsListeners)
          return self2;
        let events2;
        let data;
        let context3;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          events2 = args[0];
          data = args.slice(1, args.length);
          context3 = self2;
        } else {
          events2 = args[0].events;
          data = args[0].data;
          context3 = args[0].context || self2;
        }
        data.unshift(context3);
        const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
        eventsArray.forEach((event2) => {
          if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
            self2.eventsAnyListeners.forEach((eventHandler) => {
              eventHandler.apply(context3, [event2, ...data]);
            });
          }
          if (self2.eventsListeners && self2.eventsListeners[event2]) {
            self2.eventsListeners[event2].forEach((eventHandler) => {
              eventHandler.apply(context3, data);
            });
          }
        });
        return self2;
      }
    };
  
    // node_modules/swiper/core/update/updateSize.js
    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;
      if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }
      if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }
      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      }
      width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
      height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
      if (Number.isNaN(width))
        width = 0;
      if (Number.isNaN(height))
        height = 0;
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
      });
    }
  
    // node_modules/swiper/core/update/updateSlides.js
    function updateSlides() {
      const swiper = this;
      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        }
        return {
          "width": "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          "marginRight": "marginBottom"
        }[property];
      }
      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }
      const params = swiper.params;
      const {
        $wrapperEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === "function") {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }
      let offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === "function") {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }
      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index2 = 0;
      if (typeof swiperSize === "undefined") {
        return;
      }
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
      }
      swiper.virtualSize = -spaceBetween;
      if (rtl)
        slides.css({
          marginLeft: "",
          marginBottom: "",
          marginTop: ""
        });
      else
        slides.css({
          marginRight: "",
          marginBottom: "",
          marginTop: ""
        });
      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
        setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
      }
      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      }
      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
        return typeof params.breakpoints[key].slidesPerView !== "undefined";
      }).length > 0;
      for (let i2 = 0; i2 < slidesLength; i2 += 1) {
        slideSize = 0;
        const slide = slides.eq(i2);
        if (gridEnabled) {
          swiper.grid.updateSlide(i2, slide, slidesLength, getDirectionLabel);
        }
        if (slide.css("display") === "none")
          continue;
        if (params.slidesPerView === "auto") {
          if (shouldResetSlideSize) {
            slides[i2].style[getDirectionLabel("width")] = ``;
          }
          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;
          if (currentTransform) {
            slide[0].style.transform = "none";
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = "none";
          }
          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            const width = getDirectionPropertyValue(slideStyles, "width");
            const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
            const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
            const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
            const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
            const boxSizing = slideStyles.getPropertyValue("box-sizing");
            if (boxSizing && boxSizing === "border-box") {
              slideSize = width + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide[0];
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }
          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }
          if (params.roundLengths)
            slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths)
            slideSize = Math.floor(slideSize);
          if (slides[i2]) {
            slides[i2].style[getDirectionLabel("width")] = `${slideSize}px`;
          }
        }
        if (slides[i2]) {
          slides[i2].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i2 !== 0)
            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i2 === 0)
            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1e3)
            slidePosition = 0;
          if (params.roundLengths)
            slidePosition = Math.floor(slidePosition);
          if (index2 % params.slidesPerGroup === 0)
            snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths)
            slidePosition = Math.floor(slidePosition);
          if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)
            snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index2 += 1;
      }
      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
        $wrapperEl.css({
          width: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }
      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }
      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      }
      if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
          let slidesGridItem = snapGrid[i2];
          if (params.roundLengths)
            slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i2] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }
      if (snapGrid.length === 0)
        snapGrid = [0];
      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
        slides.filter((_, slideIndex) => {
          if (!params.cssMode)
            return true;
          if (slideIndex === slides.length - 1) {
            return false;
          }
          return true;
        }).css({
          [key]: `${spaceBetween}px`
        });
      }
      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map((snap3) => {
          if (snap3 < 0)
            return -offsetBefore;
          if (snap3 > maxSnap)
            return maxSnap + offsetAfter;
          return snap3;
        });
      }
      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap3, snapIndex) => {
            snapGrid[snapIndex] = snap3 - allSlidesOffset;
          });
          slidesGrid.forEach((snap3, snapIndex) => {
            slidesGrid[snapIndex] = snap3 + allSlidesOffset;
          });
        }
      }
      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });
      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
        setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
      }
      if (slidesLength !== previousSlidesLength) {
        swiper.emit("slidesLengthChange");
      }
      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow)
          swiper.checkOverflow();
        swiper.emit("snapGridLengthChange");
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit("slidesGridLengthChange");
      }
      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }
      if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
          if (!hasClassBackfaceClassAdded)
            swiper.$el.addClass(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
          swiper.$el.removeClass(backFaceHiddenClass);
        }
      }
    }
  
    // node_modules/swiper/core/update/updateAutoHeight.js
    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i2;
      if (typeof speed === "number") {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }
      const getSlideByIndex = (index2) => {
        if (isVirtual) {
          return swiper.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
        }
        return swiper.slides.eq(index2)[0];
      };
      if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each((slide) => {
            activeSlides.push(slide);
          });
        } else {
          for (i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1) {
            const index2 = swiper.activeIndex + i2;
            if (index2 > swiper.slides.length && !isVirtual)
              break;
            activeSlides.push(getSlideByIndex(index2));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      }
      for (i2 = 0; i2 < activeSlides.length; i2 += 1) {
        if (typeof activeSlides[i2] !== "undefined") {
          const height = activeSlides[i2].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      }
      if (newHeight || newHeight === 0)
        swiper.$wrapperEl.css("height", `${newHeight}px`);
    }
  
    // node_modules/swiper/core/update/updateSlidesOffset.js
    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        slides[i2].swiperSlideOffset = swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop;
      }
    }
  
    // node_modules/swiper/core/update/updateSlidesProgress.js
    function updateSlidesProgress(translate2) {
      if (translate2 === void 0) {
        translate2 = this && this.translate || 0;
      }
      const swiper = this;
      const params = swiper.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper;
      if (slides.length === 0)
        return;
      if (typeof slides[0].swiperSlideOffset === "undefined")
        swiper.updateSlidesOffset();
      let offsetCenter = -translate2;
      if (rtl)
        offsetCenter = translate2;
      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        const slide = slides[i2];
        let slideOffset = slide.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i2);
          slides.eq(i2).addClass(params.slideVisibleClass);
        }
        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }
      swiper.visibleSlides = dom_default(swiper.visibleSlides);
    }
  
    // node_modules/swiper/core/update/updateProgress.js
    function updateProgress(translate2) {
      const swiper = this;
      if (typeof translate2 === "undefined") {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }
      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;
      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate2 - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }
      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
        swiper.updateSlidesProgress(translate2);
      if (isBeginning && !wasBeginning) {
        swiper.emit("reachBeginning toEdge");
      }
      if (isEnd && !wasEnd) {
        swiper.emit("reachEnd toEdge");
      }
      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit("fromEdge");
      }
      swiper.emit("progress", progress);
    }
  
    // node_modules/swiper/core/update/updateSlidesClasses.js
    function updateSlidesClasses() {
      const swiper = this;
      const {
        slides,
        params,
        $wrapperEl,
        activeIndex,
        realIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
      let activeSlide;
      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      }
      activeSlide.addClass(params.slideActiveClass);
      if (params.loop) {
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      }
      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      }
      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }
      if (params.loop) {
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
        }
      }
      swiper.emitSlidesClasses();
    }
  
    // node_modules/swiper/core/update/updateActiveIndex.js
    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;
      if (typeof activeIndex === "undefined") {
        for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
          if (typeof slidesGrid[i2 + 1] !== "undefined") {
            if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
              activeIndex = i2;
            } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
              activeIndex = i2 + 1;
            }
          } else if (translate2 >= slidesGrid[i2]) {
            activeIndex = i2;
          }
        }
        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === "undefined")
            activeIndex = 0;
        }
      }
      if (snapGrid.indexOf(translate2) >= 0) {
        snapIndex = snapGrid.indexOf(translate2);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }
      if (snapIndex >= snapGrid.length)
        snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit("snapIndexChange");
        }
        return;
      }
      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      swiper.emit("activeIndexChange");
      swiper.emit("snapIndexChange");
      if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
      }
      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit("slideChange");
      }
    }
  
    // node_modules/swiper/core/update/updateClickedSlide.js
    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = dom_default(e).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;
      if (slide) {
        for (let i2 = 0; i2 < swiper.slides.length; i2 += 1) {
          if (swiper.slides[i2] === slide) {
            slideFound = true;
            slideIndex = i2;
            break;
          }
        }
      }
      if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = void 0;
        swiper.clickedIndex = void 0;
        return;
      }
      if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }
  
    // node_modules/swiper/core/update/index.js
    var update_default = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };
  
    // node_modules/swiper/core/translate/getTranslate.js
    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? "x" : "y";
      }
      const swiper = this;
      const {
        params,
        rtlTranslate: rtl,
        translate: translate2,
        $wrapperEl
      } = swiper;
      if (params.virtualTranslate) {
        return rtl ? -translate2 : translate2;
      }
      if (params.cssMode) {
        return translate2;
      }
      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl)
        currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }
  
    // node_modules/swiper/core/translate/setTranslate.js
    function setTranslate(translate2, byController) {
      const swiper = this;
      const {
        rtlTranslate: rtl,
        params,
        $wrapperEl,
        wrapperEl,
        progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;
      if (swiper.isHorizontal()) {
        x = rtl ? -translate2 : translate2;
      } else {
        y = translate2;
      }
      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }
      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }
      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y;
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== progress) {
        swiper.updateProgress(translate2);
      }
      swiper.emit("setTranslate", swiper.translate, byController);
    }
  
    // node_modules/swiper/core/translate/minTranslate.js
    function minTranslate() {
      return -this.snapGrid[0];
    }
  
    // node_modules/swiper/core/translate/maxTranslate.js
    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }
  
    // node_modules/swiper/core/translate/translateTo.js
    function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
      if (translate2 === void 0) {
        translate2 = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (translateBounds === void 0) {
        translateBounds = true;
      }
      const swiper = this;
      const {
        params,
        wrapperEl
      } = swiper;
      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }
      const minTranslate2 = swiper.minTranslate();
      const maxTranslate2 = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate2 > minTranslate2)
        newTranslate = minTranslate2;
      else if (translateBounds && translate2 < maxTranslate2)
        newTranslate = maxTranslate2;
      else
        newTranslate = translate2;
      swiper.updateProgress(newTranslate);
      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: -newTranslate,
              side: isH ? "left" : "top"
            });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? "left" : "top"]: -newTranslate,
            behavior: "smooth"
          });
        }
        return true;
      }
      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit("beforeTransitionStart", speed, internal);
          swiper.emit("transitionEnd");
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit("beforeTransitionStart", speed, internal);
          swiper.emit("transitionStart");
        }
        if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd3(e) {
              if (!swiper || swiper.destroyed)
                return;
              if (e.target !== this)
                return;
              swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;
              if (runCallbacks) {
                swiper.emit("transitionEnd");
              }
            };
          }
          swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
        }
      }
      return true;
    }
  
    // node_modules/swiper/core/translate/index.js
    var translate_default = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };
  
    // node_modules/swiper/core/transition/setTransition.js
    function setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }
      swiper.emit("setTransition", duration, byController);
    }
  
    // node_modules/swiper/core/transition/transitionEmit.js
    function transitionEmit(_ref) {
      let {
        swiper,
        runCallbacks,
        direction,
        step
      } = _ref;
      const {
        activeIndex,
        previousIndex
      } = swiper;
      let dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex)
          dir = "next";
        else if (activeIndex < previousIndex)
          dir = "prev";
        else
          dir = "reset";
      }
      swiper.emit(`transition${step}`);
      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }
        swiper.emit(`slideChangeTransition${step}`);
        if (dir === "next") {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }
  
    // node_modules/swiper/core/transition/transitionStart.js
    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      const {
        params
      } = swiper;
      if (params.cssMode)
        return;
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: "Start"
      });
    }
  
    // node_modules/swiper/core/transition/transitionEnd.js
    function transitionEnd2(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      const {
        params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode)
        return;
      swiper.setTransition(0);
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: "End"
      });
    }
  
    // node_modules/swiper/core/transition/index.js
    var transition_default = {
      setTransition,
      transitionStart,
      transitionEnd: transitionEnd2
    };
  
    // node_modules/swiper/core/slide/slideTo.js
    function slideTo(index2, speed, runCallbacks, internal, initial) {
      if (index2 === void 0) {
        index2 = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (typeof index2 !== "number" && typeof index2 !== "string") {
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
      }
      if (typeof index2 === "string") {
        const indexAsNumber = parseInt(index2, 10);
        const isValidNumber = isFinite(indexAsNumber);
        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
        }
        index2 = indexAsNumber;
      }
      const swiper = this;
      let slideIndex = index2;
      if (slideIndex < 0)
        slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper;
      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }
      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length)
        snapIndex = snapGrid.length - 1;
      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit("beforeSlideChangeStart");
      }
      const translate2 = -snapGrid[snapIndex];
      swiper.updateProgress(translate2);
      if (params.normalizeSlideIndex) {
        for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
          const normalizedTranslate = -Math.floor(translate2 * 100);
          const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
          if (typeof slidesGrid[i2 + 1] !== "undefined") {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i2;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i2 + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i2;
          }
        }
      }
      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {
          return false;
        }
        if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex)
            return false;
        }
      }
      let direction;
      if (slideIndex > activeIndex)
        direction = "next";
      else if (slideIndex < activeIndex)
        direction = "prev";
      else
        direction = "reset";
      if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
        swiper.updateActiveIndex(slideIndex);
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== "slide") {
          swiper.setTranslate(translate2);
        }
        if (direction !== "reset") {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
      }
      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate2 : -translate2;
        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = "none";
            swiper._immediateVirtual = true;
          }
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = "";
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: t,
              side: isH ? "left" : "top"
            });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? "left" : "top"]: t,
            behavior: "smooth"
          });
        }
        return true;
      }
      swiper.setTransition(speed);
      swiper.setTranslate(translate2);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
      } else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd3(e) {
            if (!swiper || swiper.destroyed)
              return;
            if (e.target !== this)
              return;
            swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }
        swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
      }
      return true;
    }
  
    // node_modules/swiper/core/slide/slideToLoop.js
    function slideToLoop(index2, speed, runCallbacks, internal) {
      if (index2 === void 0) {
        index2 = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      let newIndex = index2;
      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }
      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
  
    // node_modules/swiper/core/slide/slideNext.js
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      const {
        animating,
        enabled,
        params
      } = swiper;
      if (!enabled)
        return swiper;
      let perGroup = params.slidesPerGroup;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
      }
      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
      if (params.loop) {
        if (animating && params.loopPreventsSlide)
          return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
      }
      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
  
    // node_modules/swiper/core/slide/slidePrev.js
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      const {
        params,
        animating,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled)
        return swiper;
      if (params.loop) {
        if (animating && params.loopPreventsSlide)
          return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
      function normalize3(val) {
        if (val < 0)
          return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }
      const normalizedTranslate = normalize3(translate2);
      const normalizedSnapGrid = snapGrid.map((val) => normalize3(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === "undefined" && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap3, snapIndex) => {
          if (normalizedTranslate >= snap3) {
            prevSnapIndex = snapIndex;
          }
        });
        if (typeof prevSnapIndex !== "undefined") {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }
      let prevIndex = 0;
      if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0)
          prevIndex = swiper.activeIndex - 1;
        if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }
      if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
      }
      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
  
    // node_modules/swiper/core/slide/slideReset.js
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
  
    // node_modules/swiper/core/slide/slideToClosest.js
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (threshold === void 0) {
        threshold = 0.5;
      }
      const swiper = this;
      let index2 = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
      const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
      const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      if (translate2 >= swiper.snapGrid[snapIndex]) {
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
          index2 += swiper.params.slidesPerGroup;
        }
      } else {
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index2 -= swiper.params.slidesPerGroup;
        }
      }
      index2 = Math.max(index2, 0);
      index2 = Math.min(index2, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index2, speed, runCallbacks, internal);
    }
  
    // node_modules/swiper/core/slide/slideToClickedSlide.js
    function slideToClickedSlide() {
      const swiper = this;
      const {
        params,
        $wrapperEl
      } = swiper;
      const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;
      if (params.loop) {
        if (swiper.animating)
          return;
        realIndex = parseInt(dom_default(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }
  
    // node_modules/swiper/core/slide/index.js
    var slide_default = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };
  
    // node_modules/swiper/core/loop/loopCreate.js
    function loopCreate() {
      const swiper = this;
      const document2 = getDocument();
      const {
        params,
        $wrapperEl
      } = swiper;
      const $selector = $wrapperEl.children().length > 0 ? dom_default($wrapperEl.children()[0].parentNode) : $wrapperEl;
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
      let slides = $selector.children(`.${params.slideClass}`);
      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i2 = 0; i2 < blankSlidesNum; i2 += 1) {
            const blankNode = dom_default(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $selector.append(blankNode);
          }
          slides = $selector.children(`.${params.slideClass}`);
        }
      }
      if (params.slidesPerView === "auto" && !params.loopedSlides)
        params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;
      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }
      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index2) => {
        const slide = dom_default(el);
        if (index2 < swiper.loopedSlides) {
          appendSlides.push(el);
        }
        if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }
        slide.attr("data-swiper-slide-index", index2);
      });
      for (let i2 = 0; i2 < appendSlides.length; i2 += 1) {
        $selector.append(dom_default(appendSlides[i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
      for (let i2 = prependSlides.length - 1; i2 >= 0; i2 -= 1) {
        $selector.prepend(dom_default(prependSlides[i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }
  
    // node_modules/swiper/core/loop/loopFix.js
    function loopFix() {
      const swiper = this;
      swiper.emit("beforeLoopFix");
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate();
      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit("loopFix");
    }
  
    // node_modules/swiper/core/loop/loopDestroy.js
    function loopDestroy() {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        slides
      } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr("data-swiper-slide-index");
    }
  
    // node_modules/swiper/core/loop/index.js
    var loop_default = {
      loopCreate,
      loopFix,
      loopDestroy
    };
  
    // node_modules/swiper/core/grab-cursor/setGrabCursor.js
    function setGrabCursor(moving) {
      const swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
        return;
      const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
      el.style.cursor = "move";
      el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
      el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
      el.style.cursor = moving ? "grabbing" : "grab";
    }
  
    // node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
    function unsetGrabCursor() {
      const swiper = this;
      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }
      swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    }
  
    // node_modules/swiper/core/grab-cursor/index.js
    var grab_cursor_default = {
      setGrabCursor,
      unsetGrabCursor
    };
  
    // node_modules/swiper/core/events/onTouchStart.js
    function closestElement(selector3, base) {
      if (base === void 0) {
        base = this;
      }
      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow())
          return null;
        if (el.assignedSlot)
          el = el.assignedSlot;
        const found = el.closest(selector3);
        return found || __closestFrom(el.getRootNode().host);
      }
      return __closestFrom(base);
    }
    function onTouchStart(event2) {
      const swiper = this;
      const document2 = getDocument();
      const window2 = getWindow();
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        enabled
      } = swiper;
      if (!enabled)
        return;
      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }
      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }
      let e = event2;
      if (e.originalEvent)
        e = e.originalEvent;
      let $targetEl = dom_default(e.target);
      if (params.touchEventsTarget === "wrapper") {
        if (!$targetEl.closest(swiper.wrapperEl).length)
          return;
      }
      data.isTouchEvent = e.type === "touchstart";
      if (!data.isTouchEvent && "which" in e && e.which === 3)
        return;
      if (!data.isTouchEvent && "button" in e && e.button > 0)
        return;
      if (data.isTouched && data.isMoved)
        return;
      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
      if (swipingClassHasValue && e.target && e.target.shadowRoot && event2.path && event2.path[0]) {
        $targetEl = dom_default(event2.path[0]);
      }
      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot);
      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }
      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0])
          return;
      }
      touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY;
      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
          event2.preventDefault();
        } else {
          return;
        }
      }
      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now2();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = void 0;
      if (params.threshold > 0)
        data.allowThresholdMove = false;
      if (e.type !== "touchstart") {
        let preventDefault = true;
        if ($targetEl.is(data.focusableElements)) {
          preventDefault = false;
          if ($targetEl[0].nodeName === "SELECT") {
            data.isTouched = false;
          }
        }
        if (document2.activeElement && dom_default(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
          document2.activeElement.blur();
        }
        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
        swiper.freeMode.onTouchStart();
      }
      swiper.emit("touchStart", e);
    }
  
    // node_modules/swiper/core/events/onTouchMove.js
    function onTouchMove(event2) {
      const document2 = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper;
      if (!enabled)
        return;
      let e = event2;
      if (e.originalEvent)
        e = e.originalEvent;
      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit("touchMoveOpposite", e);
        }
        return;
      }
      if (data.isTouchEvent && e.type !== "touchmove")
        return;
      const targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
      const pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }
      if (!swiper.allowTouchMove) {
        if (!dom_default(e.target).is(data.focusableElements)) {
          swiper.allowClick = false;
        }
        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now2();
        }
        return;
      }
      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }
      if (data.isTouchEvent && document2.activeElement) {
        if (e.target === document2.activeElement && dom_default(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }
      if (data.allowTouchCallbacks) {
        swiper.emit("touchMove", e);
      }
      if (e.targetTouches && e.targetTouches.length > 1)
        return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(__pow(diffX, 2) + __pow(diffY, 2)) < swiper.params.threshold)
        return;
      if (typeof data.isScrolling === "undefined") {
        let touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }
      if (data.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
      }
      if (typeof data.startMoving === "undefined") {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }
      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }
      if (!data.startMoving) {
        return;
      }
      swiper.allowClick = false;
      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }
      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }
      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
          swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }
        swiper.emit("sliderFirstMove", e);
      }
      swiper.emit("sliderMove", e);
      data.isMoved = true;
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl)
        diff = -diff;
      swiper.swipeDirection = diff > 0 ? "prev" : "next";
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }
      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance)
          data.currentTranslate = swiper.minTranslate() - 1 + __pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance)
          data.currentTranslate = swiper.maxTranslate() + 1 - __pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }
      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      }
      if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      }
      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }
      if (!params.followFinger || params.cssMode)
        return;
      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      }
      swiper.updateProgress(data.currentTranslate);
      swiper.setTranslate(data.currentTranslate);
    }
  
    // node_modules/swiper/core/events/onTouchEnd.js
    function onTouchEnd(event2) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper;
      if (!enabled)
        return;
      let e = event2;
      if (e.originalEvent)
        e = e.originalEvent;
      if (data.allowTouchCallbacks) {
        swiper.emit("touchEnd", e);
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      }
      const touchEndTime = now2();
      const timeDiff = touchEndTime - data.touchStartTime;
      if (swiper.allowClick) {
        const pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
        swiper.emit("tap click", e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit("doubleTap doubleClick", e);
        }
      }
      data.lastClickTime = now2();
      nextTick(() => {
        if (!swiper.destroyed)
          swiper.allowClick = true;
      });
      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;
      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }
      if (params.cssMode) {
        return;
      }
      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos
        });
        return;
      }
      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];
      for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + increment2] !== "undefined") {
          if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
            stopIndex = i2;
            groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
          }
        } else if (currentPos >= slidesGrid[i2]) {
          stopIndex = i2;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }
      let rewindFirstIndex = null;
      let rewindLastIndex = null;
      if (params.rewind) {
        if (swiper.isBeginning) {
          rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
          rewindFirstIndex = 0;
        }
      }
      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (swiper.swipeDirection === "next") {
          if (ratio >= params.longSwipesRatio)
            swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
          else
            swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === "prev") {
          if (ratio > 1 - params.longSwipesRatio) {
            swiper.slideTo(stopIndex + increment);
          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
            swiper.slideTo(rewindLastIndex);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      } else {
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === "next") {
            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
          }
          if (swiper.swipeDirection === "prev") {
            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }
  
    // node_modules/swiper/core/events/onResize.js
    function onResize() {
      const swiper = this;
      const {
        params,
        el
      } = swiper;
      if (el && el.offsetWidth === 0)
        return;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper;
      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }
  
    // node_modules/swiper/core/events/onClick.js
    function onClick(e) {
      const swiper = this;
      if (!swiper.enabled)
        return;
      if (!swiper.allowClick) {
        if (swiper.params.preventClicks)
          e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }
  
    // node_modules/swiper/core/events/onScroll.js
    function onScroll() {
      const swiper = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled)
        return;
      swiper.previousTranslate = swiper.translate;
      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      }
      if (swiper.translate === -0)
        swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }
      swiper.emit("setTranslate", swiper.translate, false);
    }
  
    // node_modules/swiper/core/events/index.js
    var dummyEventAttached = false;
    function dummyEventListener() {
    }
    var events = (swiper, method) => {
      const document2 = getDocument();
      const {
        params,
        touchEvents,
        el,
        wrapperEl,
        device,
        support: support3
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
      const swiperMethod = method;
      if (!support3.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document2[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document2[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener = touchEvents.start === "touchstart" && support3.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support3.passiveListener ? {
          passive: false,
          capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      }
      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]("click", swiper.onClick, true);
      }
      if (params.cssMode) {
        wrapperEl[domMethod]("scroll", swiper.onScroll);
      }
      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
      } else {
        swiper[swiperMethod]("observerUpdate", onResize, true);
      }
    };
    function attachEvents() {
      const swiper = this;
      const document2 = getDocument();
      const {
        params,
        support: support3
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }
      swiper.onClick = onClick.bind(swiper);
      if (support3.touch && !dummyEventAttached) {
        document2.addEventListener("touchstart", dummyEventListener);
        dummyEventAttached = true;
      }
      events(swiper, "on");
    }
    function detachEvents() {
      const swiper = this;
      events(swiper, "off");
    }
    var events_default = {
      attachEvents,
      detachEvents
    };
  
    // node_modules/swiper/core/breakpoints/setBreakpoint.js
    var isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
      const swiper = this;
      const {
        activeIndex,
        initialized,
        loopedSlides = 0,
        params,
        $el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0)
        return;
      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint)
        return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;
      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }
        swiper.emitContainerClasses();
      }
      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
      if (directionChanged && initialized) {
        swiper.changeDirection();
      }
      extend2(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });
      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }
      swiper.currentBreakpoint = breakpoint;
      swiper.emit("_beforeBreakpoint", breakpointParams);
      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }
      swiper.emit("breakpoint", breakpointParams);
    }
  
    // node_modules/swiper/core/breakpoints/getBreakpoint.js
    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = "window";
      }
      if (!breakpoints || base === "container" && !containerEl)
        return void 0;
      let breakpoint = false;
      const window2 = getWindow();
      const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map((point) => {
        if (typeof point === "string" && point.indexOf("@") === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }
        return {
          value: point,
          point
        };
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
      for (let i2 = 0; i2 < points.length; i2 += 1) {
        const {
          point,
          value
        } = points[i2];
        if (base === "window") {
          if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }
      return breakpoint || "max";
    }
  
    // node_modules/swiper/core/breakpoints/index.js
    var breakpoints_default = {
      setBreakpoint,
      getBreakpoint
    };
  
    // node_modules/swiper/core/classes/addClasses.js
    function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach((item) => {
        if (typeof item === "object") {
          Object.keys(item).forEach((classNames) => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === "string") {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }
    function addClasses() {
      const swiper = this;
      const {
        classNames,
        params,
        rtl,
        $el,
        device,
        support: support3
      } = swiper;
      const suffixes = prepareClasses(["initialized", params.direction, {
        "pointer-events": !support3.touch
      }, {
        "free-mode": swiper.params.freeMode && params.freeMode.enabled
      }, {
        "autoheight": params.autoHeight
      }, {
        "rtl": rtl
      }, {
        "grid": params.grid && params.grid.rows > 1
      }, {
        "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
      }, {
        "android": device.android
      }, {
        "ios": device.ios
      }, {
        "css-mode": params.cssMode
      }, {
        "centered": params.cssMode && params.centeredSlides
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(" "));
      swiper.emitContainerClasses();
    }
  
    // node_modules/swiper/core/classes/removeClasses.js
    function removeClasses() {
      const swiper = this;
      const {
        $el,
        classNames
      } = swiper;
      $el.removeClass(classNames.join(" "));
      swiper.emitContainerClasses();
    }
  
    // node_modules/swiper/core/classes/index.js
    var classes_default = {
      addClasses,
      removeClasses
    };
  
    // node_modules/swiper/core/images/loadImage.js
    function loadImage(imageEl, src2, srcset, sizes, checkForComplete, callback) {
      const window2 = getWindow();
      let image;
      function onReady() {
        if (callback)
          callback();
      }
      const isPicture = dom_default(imageEl).parent("picture")[0];
      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src2) {
          image = new window2.Image();
          image.onload = onReady;
          image.onerror = onReady;
          if (sizes) {
            image.sizes = sizes;
          }
          if (srcset) {
            image.srcset = srcset;
          }
          if (src2) {
            image.src = src2;
          }
        } else {
          onReady();
        }
      } else {
        onReady();
      }
    }
  
    // node_modules/swiper/core/images/preloadImages.js
    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find("img");
      function onReady() {
        if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed)
          return;
        if (swiper.imagesLoaded !== void 0)
          swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady)
            swiper.update();
          swiper.emit("imagesReady");
        }
      }
      for (let i2 = 0; i2 < swiper.imagesToLoad.length; i2 += 1) {
        const imageEl = swiper.imagesToLoad[i2];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
      }
    }
  
    // node_modules/swiper/core/images/index.js
    var images_default = {
      loadImage,
      preloadImages
    };
  
    // node_modules/swiper/core/check-overflow/index.js
    function checkOverflow() {
      const swiper = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper;
      const {
        slidesOffsetBefore
      } = params;
      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }
      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }
      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }
      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }
      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? "lock" : "unlock");
      }
    }
    var check_overflow_default = {
      checkOverflow
    };
  
    // node_modules/swiper/core/defaults.js
    var defaults_default = {
      init: true,
      direction: "horizontal",
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: "input, select, option, textarea, button, video, label",
      width: null,
      height: null,
      preventInteractionOnTransition: false,
      userAgent: null,
      url: null,
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      autoHeight: false,
      setWrapperSize: false,
      virtualTranslate: false,
      effect: "slide",
      breakpoints: void 0,
      breakpointsBase: "window",
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      watchOverflow: true,
      roundLengths: false,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      uniqueNavElements: true,
      resistance: true,
      resistanceRatio: 0.85,
      watchSlidesProgress: false,
      grabCursor: false,
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      preloadImages: true,
      updateOnImagesReady: true,
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      rewind: false,
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      noSwiping: true,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: true,
      maxBackfaceHiddenSlides: 10,
      containerModifierClass: "swiper-",
      slideClass: "swiper-slide",
      slideBlankClass: "swiper-slide-invisible-blank",
      slideActiveClass: "swiper-slide-active",
      slideDuplicateActiveClass: "swiper-slide-duplicate-active",
      slideVisibleClass: "swiper-slide-visible",
      slideDuplicateClass: "swiper-slide-duplicate",
      slideNextClass: "swiper-slide-next",
      slideDuplicateNextClass: "swiper-slide-duplicate-next",
      slidePrevClass: "swiper-slide-prev",
      slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
      wrapperClass: "swiper-wrapper",
      runCallbacksOnInit: true,
      _emitClasses: false
    };
  
    // node_modules/swiper/core/moduleExtendParams.js
    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj) {
        if (obj === void 0) {
          obj = {};
        }
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== "object" || moduleParams === null) {
          extend2(allModulesParams, obj);
          return;
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }
        if (!(moduleParamName in params && "enabled" in moduleParams)) {
          extend2(allModulesParams, obj);
          return;
        }
        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }
        if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName])
          params[moduleParamName] = {
            enabled: false
          };
        extend2(allModulesParams, obj);
      };
    }
  
    // node_modules/swiper/core/core.js
    var prototypes = {
      eventsEmitter: events_emitter_default,
      update: update_default,
      translate: translate_default,
      transition: transition_default,
      slide: slide_default,
      loop: loop_default,
      grabCursor: grab_cursor_default,
      events: events_default,
      breakpoints: breakpoints_default,
      checkOverflow: check_overflow_default,
      classes: classes_default,
      images: images_default
    };
    var extendedDefaults = {};
    var Swiper = class {
      constructor() {
        let el;
        let params;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
          params = args[0];
        } else {
          [el, params] = args;
        }
        if (!params)
          params = {};
        params = extend2({}, params);
        if (el && !params.el)
          params.el = el;
        if (params.el && dom_default(params.el).length > 1) {
          const swipers = [];
          dom_default(params.el).each((containerEl) => {
            const newParams = extend2({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        }
        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];
        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }
        const allModulesParams = {};
        swiper.modules.forEach((mod) => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        });
        const swiperParams = extend2({}, defaults_default, allModulesParams);
        swiper.params = extend2({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend2({}, swiper.params);
        swiper.passedParams = extend2({}, params);
        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach((eventName) => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }
        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        }
        swiper.$ = dom_default;
        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
          classNames: [],
          slides: dom_default(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          isHorizontal() {
            return swiper.params.direction === "horizontal";
          },
          isVertical() {
            return swiper.params.direction === "vertical";
          },
          activeIndex: 0,
          realIndex: 0,
          isBeginning: true,
          isEnd: false,
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          touchEvents: function touchEvents() {
            const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
            const desktop = ["pointerdown", "pointermove", "pointerup"];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: void 0,
            isMoved: void 0,
            allowTouchCallbacks: void 0,
            touchStartTime: void 0,
            isScrolling: void 0,
            currentTranslate: void 0,
            startTranslate: void 0,
            allowThresholdMove: void 0,
            focusableElements: swiper.params.focusableElements,
            lastClickTime: now2(),
            clickTimeout: void 0,
            velocities: [],
            allowMomentumBounce: void 0,
            isTouchEvent: void 0,
            startMoving: void 0
          },
          allowClick: true,
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit("_swiper");
        if (swiper.params.init) {
          swiper.init();
        }
        return swiper;
      }
      enable() {
        const swiper = this;
        if (swiper.enabled)
          return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }
        swiper.emit("enable");
      }
      disable() {
        const swiper = this;
        if (!swiper.enabled)
          return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }
        swiper.emit("disable");
      }
      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el)
          return;
        const cls = swiper.el.className.split(" ").filter((className) => {
          return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit("_containerClasses", cls.join(" "));
      }
      getSlideClasses(slideEl) {
        const swiper = this;
        return slideEl.className.split(" ").filter((className) => {
          return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(" ");
      }
      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el)
          return;
        const updates = [];
        swiper.slides.each((slideEl) => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper.emit("_slideClass", slideEl, classNames);
        });
        swiper.emit("_slideClasses", updates);
      }
      slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
          view = "current";
        }
        if (exact === void 0) {
          exact = false;
        }
        const swiper = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper;
        let spv = 1;
        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;
          for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
            if (slides[i2] && !breakLoop) {
              slideSize += slides[i2].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize)
                breakLoop = true;
            }
          }
          for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
            if (slides[i2] && !breakLoop) {
              slideSize += slides[i2].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize)
                breakLoop = true;
            }
          }
        } else {
          if (view === "current") {
            for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
              const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          }
        }
        return spv;
      }
      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed)
          return;
        const {
          snapGrid,
          params
        } = swiper;
        if (params.breakpoints) {
          swiper.setBreakpoint();
        }
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate2() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
        let translated;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate2();
          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }
          if (!translated) {
            setTranslate2();
          }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }
        swiper.emit("update");
      }
      changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) {
          newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        }
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
          return swiper;
        }
        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each((slideEl) => {
          if (newDirection === "vertical") {
            slideEl.style.width = "";
          } else {
            slideEl.style.height = "";
          }
        });
        swiper.emit("changeDirection");
        if (needUpdate)
          swiper.update();
        return swiper;
      }
      mount(el) {
        const swiper = this;
        if (swiper.mounted)
          return true;
        const $el = dom_default(el || swiper.params.el);
        el = $el[0];
        if (!el) {
          return false;
        }
        el.swiper = swiper;
        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
        };
        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
            res.children = (options) => $el.children(options);
            return res;
          }
          return $el.children(getWrapperSelector());
        };
        let $wrapperEl = getWrapper();
        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document2 = getDocument();
          const wrapper = document2.createElement("div");
          $wrapperEl = dom_default(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
            $wrapperEl.append(slideEl);
          });
        }
        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
          rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
          wrongRTL: $wrapperEl.css("display") === "-webkit-box"
        });
        return true;
      }
      init(el) {
        const swiper = this;
        if (swiper.initialized)
          return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false)
          return swiper;
        swiper.emit("beforeInit");
        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        }
        swiper.addClasses();
        if (swiper.params.loop) {
          swiper.loopCreate();
        }
        swiper.updateSize();
        swiper.updateSlides();
        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        }
        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }
        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        }
        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
        swiper.attachEvents();
        swiper.initialized = true;
        swiper.emit("init");
        swiper.emit("afterInit");
        return swiper;
      }
      destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }
        if (cleanStyles === void 0) {
          cleanStyles = true;
        }
        const swiper = this;
        const {
          params,
          $el,
          $wrapperEl,
          slides
        } = swiper;
        if (typeof swiper.params === "undefined" || swiper.destroyed) {
          return null;
        }
        swiper.emit("beforeDestroy");
        swiper.initialized = false;
        swiper.detachEvents();
        if (params.loop) {
          swiper.loopDestroy();
        }
        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr("style");
          $wrapperEl.removeAttr("style");
          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
          }
        }
        swiper.emit("destroy");
        Object.keys(swiper.eventsListeners).forEach((eventName) => {
          swiper.off(eventName);
        });
        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }
        swiper.destroyed = true;
        return null;
      }
      static extendDefaults(newDefaults) {
        extend2(extendedDefaults, newDefaults);
      }
      static get extendedDefaults() {
        return extendedDefaults;
      }
      static get defaults() {
        return defaults_default;
      }
      static installModule(mod) {
        if (!Swiper.prototype.__modules__)
          Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;
        if (typeof mod === "function" && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }
      static use(module2) {
        if (Array.isArray(module2)) {
          module2.forEach((m) => Swiper.installModule(m));
          return Swiper;
        }
        Swiper.installModule(module2);
        return Swiper;
      }
    };
    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);
    var core_default = Swiper;
  
    // node_modules/swiper/shared/create-element-if-not-defined.js
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document2 = getDocument();
      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach((key) => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];
            if (!element) {
              element = document2.createElement("div");
              element.className = checkProps[key];
              swiper.$el.append(element);
            }
            params[key] = element;
            originalParams[key] = element;
          }
        });
      }
      return params;
    }
  
    // node_modules/swiper/modules/navigation/navigation.js
    function Navigation(_ref) {
      let {
        swiper,
        extendParams,
        on: on2,
        emit
      } = _ref;
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: "swiper-button-disabled",
          hiddenClass: "swiper-button-hidden",
          lockClass: "swiper-button-lock"
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };
      function getEl(el) {
        let $el;
        if (el) {
          $el = dom_default(el);
          if (swiper.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }
        return $el;
      }
      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;
        if ($el && $el.length > 0) {
          $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
          if ($el[0] && $el[0].tagName === "BUTTON")
            $el[0].disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
          }
        }
      }
      function update() {
        if (swiper.params.loop)
          return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
      }
      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
          return;
        swiper.slidePrev();
      }
      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
          return;
        swiper.slideNext();
      }
      function init6() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: "swiper-button-next",
          prevEl: "swiper-button-prev"
        });
        if (!(params.nextEl || params.prevEl))
          return;
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);
        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on("click", onNextClick);
        }
        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on("click", onPrevClick);
        }
        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });
        if (!swiper.enabled) {
          if ($nextEl)
            $nextEl.addClass(params.lockClass);
          if ($prevEl)
            $prevEl.addClass(params.lockClass);
        }
      }
      function destroy() {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        if ($nextEl && $nextEl.length) {
          $nextEl.off("click", onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }
        if ($prevEl && $prevEl.length) {
          $prevEl.off("click", onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }
      on2("init", () => {
        init6();
        update();
      });
      on2("toEdge fromEdge lock unlock", () => {
        update();
      });
      on2("destroy", () => {
        destroy();
      });
      on2("enable disable", () => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        if ($nextEl) {
          $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
        }
        if ($prevEl) {
          $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
        }
      });
      on2("click", (_s, e) => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        const targetEl = e.target;
        if (swiper.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
            return;
          let isHidden3;
          if ($nextEl) {
            isHidden3 = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden3 = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }
          if (isHidden3 === true) {
            emit("navigationShow");
          } else {
            emit("navigationHide");
          }
          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });
      Object.assign(swiper.navigation, {
        update,
        init: init6,
        destroy
      });
    }
  
    // node_modules/swiper/modules/parallax/parallax.js
    function Parallax(_ref) {
      let {
        swiper,
        extendParams,
        on: on2
      } = _ref;
      extendParams({
        parallax: {
          enabled: false
        }
      });
      const setTransform = (el, progress) => {
        const {
          rtl
        } = swiper;
        const $el = dom_default(el);
        const rtlFactor = rtl ? -1 : 1;
        const p = $el.attr("data-swiper-parallax") || "0";
        let x = $el.attr("data-swiper-parallax-x");
        let y = $el.attr("data-swiper-parallax-y");
        const scale = $el.attr("data-swiper-parallax-scale");
        const opacity = $el.attr("data-swiper-parallax-opacity");
        if (x || y) {
          x = x || "0";
          y = y || "0";
        } else if (swiper.isHorizontal()) {
          x = p;
          y = "0";
        } else {
          y = p;
          x = "0";
        }
        if (x.indexOf("%") >= 0) {
          x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
          x = `${x * progress * rtlFactor}px`;
        }
        if (y.indexOf("%") >= 0) {
          y = `${parseInt(y, 10) * progress}%`;
        } else {
          y = `${y * progress}px`;
        }
        if (typeof opacity !== "undefined" && opacity !== null) {
          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }
        if (typeof scale === "undefined" || scale === null) {
          $el.transform(`translate3d(${x}, ${y}, 0px)`);
        } else {
          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
        }
      };
      const setTranslate2 = () => {
        const {
          $el,
          slides,
          progress,
          snapGrid
        } = swiper;
        $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
          setTransform(el, progress);
        });
        slides.each((slideEl, slideIndex) => {
          let slideProgress = slideEl.progress;
          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }
          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          dom_default(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
            setTransform(el, slideProgress);
          });
        });
      };
      const setTransition2 = function(duration) {
        if (duration === void 0) {
          duration = swiper.params.speed;
        }
        const {
          $el
        } = swiper;
        $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((parallaxEl) => {
          const $parallaxEl = dom_default(parallaxEl);
          let parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
          if (duration === 0)
            parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
      };
      on2("beforeInit", () => {
        if (!swiper.params.parallax.enabled)
          return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on2("init", () => {
        if (!swiper.params.parallax.enabled)
          return;
        setTranslate2();
      });
      on2("setTranslate", () => {
        if (!swiper.params.parallax.enabled)
          return;
        setTranslate2();
      });
      on2("setTransition", (_swiper, duration) => {
        if (!swiper.params.parallax.enabled)
          return;
        setTransition2(duration);
      });
    }
  
    // node_modules/swiper/modules/lazy/lazy.js
    function Lazy(_ref) {
      let {
        swiper,
        extendParams,
        on: on2,
        emit
      } = _ref;
      extendParams({
        lazy: {
          checkInView: false,
          enabled: false,
          loadPrevNext: false,
          loadPrevNextAmount: 1,
          loadOnTransitionStart: false,
          scrollingElement: "",
          elementClass: "swiper-lazy",
          loadingClass: "swiper-lazy-loading",
          loadedClass: "swiper-lazy-loaded",
          preloaderClass: "swiper-lazy-preloader"
        }
      });
      swiper.lazy = {};
      let scrollHandlerAttached = false;
      let initialImageLoaded = false;
      function loadInSlide(index2, loadInDuplicate) {
        if (loadInDuplicate === void 0) {
          loadInDuplicate = true;
        }
        const params = swiper.params.lazy;
        if (typeof index2 === "undefined")
          return;
        if (swiper.slides.length === 0)
          return;
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index2}"]`) : swiper.slides.eq(index2);
        const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
        if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
          $images.push($slideEl[0]);
        }
        if ($images.length === 0)
          return;
        $images.each((imageEl) => {
          const $imageEl = dom_default(imageEl);
          $imageEl.addClass(params.loadingClass);
          const background = $imageEl.attr("data-background");
          const src2 = $imageEl.attr("data-src");
          const srcset = $imageEl.attr("data-srcset");
          const sizes = $imageEl.attr("data-sizes");
          const $pictureEl = $imageEl.parent("picture");
          swiper.loadImage($imageEl[0], src2 || background, srcset, sizes, false, () => {
            if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed)
              return;
            if (background) {
              $imageEl.css("background-image", `url("${background}")`);
              $imageEl.removeAttr("data-background");
            } else {
              if (srcset) {
                $imageEl.attr("srcset", srcset);
                $imageEl.removeAttr("data-srcset");
              }
              if (sizes) {
                $imageEl.attr("sizes", sizes);
                $imageEl.removeAttr("data-sizes");
              }
              if ($pictureEl.length) {
                $pictureEl.children("source").each((sourceEl) => {
                  const $source = dom_default(sourceEl);
                  if ($source.attr("data-srcset")) {
                    $source.attr("srcset", $source.attr("data-srcset"));
                    $source.removeAttr("data-srcset");
                  }
                });
              }
              if (src2) {
                $imageEl.attr("src", src2);
                $imageEl.removeAttr("data-src");
              }
            }
            $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
            $slideEl.find(`.${params.preloaderClass}`).remove();
            if (swiper.params.loop && loadInDuplicate) {
              const slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
              if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                loadInSlide(originalSlide.index(), false);
              } else {
                const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                loadInSlide(duplicatedSlide.index(), false);
              }
            }
            emit("lazyImageReady", $slideEl[0], $imageEl[0]);
            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          });
          emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
        });
      }
      function load() {
        const {
          $wrapperEl,
          params: swiperParams,
          slides,
          activeIndex
        } = swiper;
        const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        const params = swiperParams.lazy;
        let slidesPerView = swiperParams.slidesPerView;
        if (slidesPerView === "auto") {
          slidesPerView = 0;
        }
        function slideExist(index2) {
          if (isVirtual) {
            if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index2}"]`).length) {
              return true;
            }
          } else if (slides[index2])
            return true;
          return false;
        }
        function slideIndex(slideEl) {
          if (isVirtual) {
            return dom_default(slideEl).attr("data-swiper-slide-index");
          }
          return dom_default(slideEl).index();
        }
        if (!initialImageLoaded)
          initialImageLoaded = true;
        if (swiper.params.watchSlidesProgress) {
          $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {
            const index2 = isVirtual ? dom_default(slideEl).attr("data-swiper-slide-index") : dom_default(slideEl).index();
            loadInSlide(index2);
          });
        } else if (slidesPerView > 1) {
          for (let i2 = activeIndex; i2 < activeIndex + slidesPerView; i2 += 1) {
            if (slideExist(i2))
              loadInSlide(i2);
          }
        } else {
          loadInSlide(activeIndex);
        }
        if (params.loadPrevNext) {
          if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
            const amount = params.loadPrevNextAmount;
            const spv = slidesPerView;
            const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
            const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
            for (let i2 = activeIndex + slidesPerView; i2 < maxIndex; i2 += 1) {
              if (slideExist(i2))
                loadInSlide(i2);
            }
            for (let i2 = minIndex; i2 < activeIndex; i2 += 1) {
              if (slideExist(i2))
                loadInSlide(i2);
            }
          } else {
            const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
            if (nextSlide.length > 0)
              loadInSlide(slideIndex(nextSlide));
            const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
            if (prevSlide.length > 0)
              loadInSlide(slideIndex(prevSlide));
          }
        }
      }
      function checkInViewOnLoad() {
        const window2 = getWindow();
        if (!swiper || swiper.destroyed)
          return;
        const $scrollElement = swiper.params.lazy.scrollingElement ? dom_default(swiper.params.lazy.scrollingElement) : dom_default(window2);
        const isWindow = $scrollElement[0] === window2;
        const scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
        const scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
        const swiperOffset = swiper.$el.offset();
        const {
          rtlTranslate: rtl
        } = swiper;
        let inView = false;
        if (rtl)
          swiperOffset.left -= swiper.$el[0].scrollLeft;
        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
        for (let i2 = 0; i2 < swiperCoord.length; i2 += 1) {
          const point = swiperCoord[i2];
          if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
            if (point[0] === 0 && point[1] === 0)
              continue;
            inView = true;
          }
        }
        const passiveListener = swiper.touchEvents.start === "touchstart" && swiper.support.passiveListener && swiper.params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (inView) {
          load();
          $scrollElement.off("scroll", checkInViewOnLoad, passiveListener);
        } else if (!scrollHandlerAttached) {
          scrollHandlerAttached = true;
          $scrollElement.on("scroll", checkInViewOnLoad, passiveListener);
        }
      }
      on2("beforeInit", () => {
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      });
      on2("init", () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on2("scroll", () => {
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
          load();
        }
      });
      on2("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on2("transitionStart", () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
            if (swiper.params.lazy.checkInView) {
              checkInViewOnLoad();
            } else {
              load();
            }
          }
        }
      });
      on2("transitionEnd", () => {
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on2("slideChange", () => {
        const {
          lazy,
          cssMode,
          watchSlidesProgress,
          touchReleaseOnEdges,
          resistanceRatio
        } = swiper.params;
        if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
          load();
        }
      });
      Object.assign(swiper.lazy, {
        load,
        loadInSlide
      });
    }
  
    // assets/scripts/modules/Gallery.js
    var Gallery_default = class extends _default {
      constructor(m) {
        super(m);
        this.$container = this.$("container")[0];
      }
      init() {
        core_default.use([Lazy, Navigation, Parallax]);
        this.carousel = new core_default(this.$container, {
          spaceBetween: 20,
          grabCursor: true,
          parallax: true,
          speed: 750,
          threshold: 10,
          navigation: {
            prevEl: this.$("prev")[0],
            nextEl: this.$("next")[0]
          },
          lazy: {
            loadPrevNext: true,
            loadPrevNextAmount: 2
          },
          on: {
            lazyImageReady: (swiper, slideEl, imageEl) => {
              imageEl.classList.add("is-loaded");
              imageEl.parentNode.classList.add("is-loaded");
            },
            click: (swiper, event2) => {
              if (swiper.clickedIndex > swiper.activeIndex)
                swiper.slideNext();
              else if (swiper.clickedIndex < swiper.activeIndex)
                swiper.slidePrev();
            }
          },
          breakpoints: {
            700: {
              slidesPerView: 1
            },
            1e3: {
              slidesPerView: 1.6
            },
            1200: {
              slidesPerView: 2
            }
          }
        });
      }
      destroy() {
        super.destroy();
        if (this.carousel && this.carousel.destroy) {
          this.carousel.detachEvents();
          this.carousel.destroy();
        }
      }
    };
  
    // assets/scripts/modules/GridHelper.js
    var GridHelper_default = class extends _default {
      constructor(m) {
        super(m);
        this.onKeyupBind = (e) => {
          if (e.key === "g")
            this.toggle();
        };
        this.$el = this.el;
      }
      init() {
        this.bindEvents();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        document.addEventListener("keyup", this.onKeyupBind);
      }
      unbindEvents() {
        document.removeEventListener("keyup", this.onKeyupBind);
      }
      toggle() {
        if (html.classList.contains("has-grid-opened")) {
          this.close();
        } else {
          this.open();
        }
      }
      open() {
        html.classList.add("has-grid-opened");
      }
      close() {
        html.classList.remove("has-grid-opened");
      }
    };
  
    // assets/scripts/modules/Hovered.js
    var Hovered_default = class extends _default {
      constructor(m) {
        super(m);
        this.onEnterBind = this.onEnter.bind(this);
        this.onLeaveBind = this.onLeave.bind(this);
        this.$el = this.el;
        this.$parent = queryClosestParent(this.$el, "[data-hovered]");
      }
      init() {
        this.bindEvents();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        this.$el.addEventListener("mouseenter", this.onEnterBind);
        this.$el.addEventListener("mouseleave", this.onLeaveBind);
      }
      unbindEvents() {
        this.$el.removeEventListener("mouseenter", this.onEnterBind);
        this.$el.removeEventListener("mouseleave", this.onLeaveBind);
      }
      onEnter() {
        this.$parent.classList.add("is-hovered");
      }
      onLeave() {
        this.$parent.classList.remove("is-hovered");
      }
    };
  
    // assets/scripts/modules/Introduction.js
    var import_lottie_light = __toModule(require_lottie_light());
    var LOTTIE_FOLDER = "/assets/data/lottie";
    var Introduction_default = class extends _default {
      constructor(m) {
        super(m);
        this.onAnimationLoadedBind = this.onAnimationLoaded.bind(this);
        this.onAnimationCompleteBind = this.onAnimationComplete.bind(this);
        this.onAnimationProgressBind = this.onAnimationProgress.bind(this);
        this.onUpdateBind = this.onUpdate.bind(this);
        this.animationPath = `${LOTTIE_FOLDER}/introduction.json`;
        this.$container = this.$("container")[0];
        this.el.style.visibility = "hidden";
        this.isLoaded = false;
        this.hasRevealPortal = false;
      }
      init() {
        if (!window.isNotFirstLoading) {
          this.loadAnimations();
        } else {
          this.el.style.visibility = "hidden";
        }
      }
      loadAnimations() {
        this.animation = import_lottie_light.default.loadAnimation({
          container: this.$container,
          autoplay: false,
          loop: false,
          path: this.animationPath,
          rendererSettings: {
            preserveAspectRatio: "xMidYMid slice"
          }
        });
        this.animation.addEventListener("data_ready", this.onAnimationLoadedBind);
        this.animation.addEventListener("enterFrame", this.onAnimationProgressBind);
        this.animation.addEventListener("complete", this.onAnimationCompleteBind);
      }
      onAnimationLoaded() {
        this.el.style.visibility = "visible";
        this.isLoaded = true;
      }
      onAnimationComplete() {
        this.el.style.visibility = "hidden";
      }
      onAnimationProgress(e) {
        if (!this.hasRevealPortal && e.currentTime >= 146) {
          this.hasRevealPortal = true;
          this.call("revealExperience", null, "Experiences");
        }
      }
      play() {
        if (this.isPlaying)
          return;
        this.isPlaying = true;
        gsapWithCSS2.ticker.add(this.onUpdateBind);
      }
      onUpdate() {
        if (!this.isLoaded)
          return;
        this.isPlaying = false;
        gsapWithCSS2.ticker.remove(this.onUpdateBind);
        this.animation.play();
      }
    };
  
    // node_modules/modularload/dist/main.esm.js
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var _default2 = /* @__PURE__ */ function() {
      function _default4(options) {
        _classCallCheck2(this, _default4);
        this.defaults = {
          name: "load",
          loadingClass: "is-loading",
          loadedClass: "is-loaded",
          readyClass: "is-ready",
          transitionsPrefix: "is-",
          transitionsHistory: true,
          enterDelay: 0,
          exitDelay: 0,
          loadedDelay: 0,
          isLoaded: false,
          isEntered: false,
          isUrl: false,
          transitionContainer: null,
          popstateIgnore: false
        };
        Object.assign(this, this.defaults, options);
        this.options = options;
        this.namespace = "modular";
        this.html = document.documentElement;
        this.href = window.location.href;
        this.container = "data-" + this.name + "-container";
        this.subContainer = false;
        this.prevTransition = null;
        this.loadAttributes = ["src", "srcset", "style", "href"];
        this.isInserted = false;
        this.isLoading = false;
        this.enterTimeout = false;
        this.controller = new AbortController();
        this.classContainer = this.html;
        this.isChrome = navigator.userAgent.indexOf("Chrome") != -1 ? true : false;
        this.init();
      }
      _createClass2(_default4, [{
        key: "init",
        value: function init6() {
          var _this = this;
          window.addEventListener("popstate", function(e) {
            return _this.checkState(e);
          }, false);
          this.html.addEventListener("click", function(e) {
            return _this.checkClick(e);
          }, false);
          this.loadEls(document);
        }
      }, {
        key: "checkClick",
        value: function checkClick(e) {
          if (!e.ctrlKey && !e.metaKey) {
            var target = e.target;
            while (target && target !== document) {
              if (target.matches("a") && target.getAttribute("download") == null) {
                var href = target.getAttribute("href");
                if (!href.startsWith("#") && !href.startsWith("mailto:") && !href.startsWith("tel:")) {
                  e.preventDefault();
                  this.reset();
                  this.getClickOptions(target);
                }
                break;
              }
              target = target.parentNode;
            }
          }
        }
      }, {
        key: "checkState",
        value: function checkState() {
          if (typeof this.popstateIgnore === "string" && window.location.href.indexOf(this.popstateIgnore) > -1) {
            return;
          }
          this.reset();
          this.getStateOptions();
        }
      }, {
        key: "reset",
        value: function reset() {
          if (this.isLoading) {
            this.controller.abort();
            this.isLoading = false;
            this.controller = new AbortController();
          }
          window.clearTimeout(this.enterTimeout);
          if (this.isInserted) {
            this.removeContainer();
          }
          this.classContainer = this.html;
          Object.assign(this, this.defaults, this.options);
        }
      }, {
        key: "getClickOptions",
        value: function getClickOptions(link) {
          this.transition = link.getAttribute("data-" + this.name);
          this.isUrl = link.getAttribute("data-" + this.name + "-url");
          var href = link.getAttribute("href");
          var target = link.getAttribute("target");
          if (target == "_blank") {
            window.open(href, "_blank");
            return;
          }
          if (this.transition == "false") {
            window.location = href;
            return;
          }
          this.setOptions(href, true);
        }
      }, {
        key: "getStateOptions",
        value: function getStateOptions() {
          if (this.transitionsHistory) {
            this.transition = history.state;
          } else {
            this.transition = false;
          }
          var href = window.location.href;
          this.setOptions(href);
        }
      }, {
        key: "goTo",
        value: function goTo(href, transition2, isUrl) {
          this.reset();
          this.transition = transition2;
          this.isUrl = isUrl;
          this.setOptions(href, true);
        }
      }, {
        key: "setOptions",
        value: function setOptions(href, push) {
          var container = "[" + this.container + "]";
          var oldContainer;
          if (this.transition && this.transition != "true") {
            this.transitionContainer = "[" + this.container + '="' + this.transition + '"]';
            this.loadingClass = this.transitions[this.transition].loadingClass || this.loadingClass;
            this.loadedClass = this.transitions[this.transition].loadedClass || this.loadedClass;
            this.readyClass = this.transitions[this.transition].readyClass || this.readyClass;
            this.transitionsPrefix = this.transitions[this.transition].transitionsPrefix || this.transitionsPrefix;
            this.enterDelay = this.transitions[this.transition].enterDelay || this.enterDelay;
            this.exitDelay = this.transitions[this.transition].exitDelay || this.exitDelay;
            this.loadedDelay = this.transitions[this.transition].loadedDelay || this.loadedDelay;
            oldContainer = document.querySelector(this.transitionContainer);
          }
          if (oldContainer) {
            container = this.transitionContainer;
            this.oldContainer = oldContainer;
            this.classContainer = this.oldContainer.parentNode;
            if (!this.subContainer) {
              history.replaceState(this.transition, null, this.href);
            }
            this.subContainer = true;
          } else {
            this.oldContainer = document.querySelector(container);
            if (this.subContainer) {
              history.replaceState(this.prevTransition, null, this.href);
            }
            this.subContainer = false;
          }
          this.href = href;
          this.parentContainer = this.oldContainer.parentNode;
          if (this.isUrl === "" || this.isUrl != null && this.isUrl != "false" && this.isUrl != false) {
            history.pushState(this.transition, null, href);
          } else {
            this.oldContainer.classList.add("is-old");
            this.setLoading();
            this.startEnterDelay();
            this.loadHref(href, container, push);
          }
        }
      }, {
        key: "setLoading",
        value: function setLoading() {
          this.classContainer.classList.remove(this.loadedClass, this.readyClass);
          this.classContainer.classList.add(this.loadingClass);
          this.classContainer.classList.remove(this.transitionsPrefix + this.prevTransition);
          if (this.transition) {
            this.classContainer.classList.add(this.transitionsPrefix + this.transition);
          }
          if (!this.subContainer) {
            this.prevTransition = this.transition;
          }
          var loadingEvent = new Event(this.namespace + "loading");
          window.dispatchEvent(loadingEvent);
        }
      }, {
        key: "startEnterDelay",
        value: function startEnterDelay() {
          var _this2 = this;
          this.enterTimeout = window.setTimeout(function() {
            _this2.isEntered = true;
            if (_this2.isLoaded) {
              _this2.transitionContainers();
            }
          }, this.enterDelay);
        }
      }, {
        key: "loadHref",
        value: function loadHref(href, container, push) {
          var _this3 = this;
          this.isLoading = true;
          var signal = this.controller.signal;
          fetch(href, {
            signal
          }).then(function(response) {
            return response.text();
          }).then(function(data) {
            if (push) {
              history.pushState(_this3.transition, null, href);
            }
            var parser = new DOMParser();
            _this3.data = parser.parseFromString(data, "text/html");
            _this3.newContainer = _this3.data.querySelector(container);
            _this3.newContainer.classList.add("is-new");
            _this3.parentNewContainer = _this3.newContainer.parentNode;
            _this3.hideContainer();
            _this3.parentContainer.insertBefore(_this3.newContainer, _this3.oldContainer);
            _this3.isInserted = true;
            _this3.setSvgs();
            _this3.isLoaded = true;
            if (_this3.isEntered) {
              _this3.transitionContainers();
            }
            _this3.loadEls(_this3.newContainer);
            _this3.isLoading = false;
          })["catch"](function(err) {
            window.location = href;
          });
        }
      }, {
        key: "transitionContainers",
        value: function transitionContainers() {
          var _this4 = this;
          this.setAttributes();
          this.showContainer();
          this.setLoaded();
          setTimeout(function() {
            _this4.removeContainer();
            _this4.setReady();
          }, this.exitDelay);
        }
      }, {
        key: "setSvgs",
        value: function setSvgs() {
          if (this.isChrome) {
            var svgs = this.newContainer.querySelectorAll("use");
            if (svgs.length) {
              svgs.forEach(function(svg) {
                var xhref = svg.getAttribute("xlink:href");
                if (xhref) {
                  svg.parentNode.innerHTML = '<use xlink:href="' + xhref + '"></use>';
                } else {
                  var href = svg.getAttribute("href");
                  if (href)
                    svg.parentNode.innerHTML = '<use href="' + href + '"></use>';
                }
              });
            }
          }
        }
      }, {
        key: "setAttributes",
        value: function setAttributes() {
          var _this5 = this;
          var title = this.data.getElementsByTagName("title")[0];
          var newDesc = this.data.head.querySelector('meta[name="description"]');
          var oldDesc = document.head.querySelector('meta[name="description"]');
          var container;
          var newContainer;
          if (this.subContainer) {
            newContainer = this.parentNewContainer;
            container = document.querySelector(this.transitionContainer).parentNode;
          } else {
            newContainer = this.data.querySelector("html");
            container = document.querySelector("html");
          }
          var datas = Object.assign({}, newContainer.dataset);
          if (title)
            document.title = title.innerText;
          if (oldDesc && newDesc)
            oldDesc.setAttribute("content", newDesc.getAttribute("content"));
          if (datas) {
            Object.entries(datas).forEach(function(_ref) {
              var _ref2 = _slicedToArray2(_ref, 2), key = _ref2[0], val = _ref2[1];
              container.setAttribute("data-" + _this5.toDash(key), val);
            });
          }
        }
      }, {
        key: "toDash",
        value: function toDash(str) {
          return str.split(/(?=[A-Z])/).join("-").toLowerCase();
        }
      }, {
        key: "hideContainer",
        value: function hideContainer() {
          this.newContainer.style.visibility = "hidden";
          this.newContainer.style.height = 0;
          this.newContainer.style.overflow = "hidden";
        }
      }, {
        key: "showContainer",
        value: function showContainer() {
          this.newContainer.style.visibility = "";
          this.newContainer.style.height = "";
          this.newContainer.style.overflow = "";
        }
      }, {
        key: "loadEls",
        value: function loadEls(container) {
          var _this6 = this;
          var promises = [];
          this.loadAttributes.forEach(function(attr2) {
            var data = "data-" + _this6.name + "-" + attr2;
            var els = container.querySelectorAll("[" + data + "]");
            if (els.length) {
              els.forEach(function(el) {
                var elData = el.getAttribute(data);
                el.setAttribute(attr2, elData);
                if (attr2 == "src" || attr2 == "srcset") {
                  var promise = new Promise(function(resolve) {
                    el.onload = function() {
                      return resolve(el);
                    };
                  });
                  promises.push(promise);
                }
              });
            }
          });
          Promise.all(promises).then(function(val) {
            var imagesEvent = new Event(_this6.namespace + "images");
            window.dispatchEvent(imagesEvent);
          });
        }
      }, {
        key: "setLoaded",
        value: function setLoaded() {
          var _this7 = this;
          this.classContainer.classList.remove(this.loadingClass);
          setTimeout(function() {
            _this7.classContainer.classList.add(_this7.loadedClass);
          }, this.loadedDelay);
          var loadedEvent = new Event(this.namespace + "loaded");
          window.dispatchEvent(loadedEvent);
        }
      }, {
        key: "removeContainer",
        value: function removeContainer() {
          this.parentContainer.removeChild(this.oldContainer);
          this.newContainer.classList.remove("is-new");
          this.isInserted = false;
        }
      }, {
        key: "setReady",
        value: function setReady() {
          this.classContainer.classList.add(this.readyClass);
          var readyEvent = new Event(this.namespace + "ready");
          window.dispatchEvent(readyEvent);
        }
      }, {
        key: "on",
        value: function on2(event2, func) {
          var _this8 = this;
          window.addEventListener(this.namespace + event2, function() {
            switch (event2) {
              case "loading":
                return func(_this8.transition, _this8.oldContainer);
              case "loaded":
                return func(_this8.transition, _this8.oldContainer, _this8.newContainer);
              case "ready":
                return func(_this8.transition, _this8.newContainer);
              default:
                return func();
            }
          }, false);
        }
      }]);
      return _default4;
    }();
    var main_esm_default2 = _default2;
  
    // assets/scripts/modules/Load.js
    var Load_default = class extends _default {
      constructor(m) {
        super(m);
      }
      init() {
        const load = new main_esm_default2({
          enterDelay: 500,
          transitions: {
            customTransition: {}
          }
        });
        load.on("loading", (transition2, oldContainer) => {
          this.call("destroyCursor", null, "Cursor");
          requestAnimationFrame(() => {
            this.call("close", null, "MenuModal");
            this.call("close", null, "TrombinoscopeModal");
            this.call("close", null, "VideoModal");
          });
          if (!CookieManager.checkCookie(COOKIES_TYPE.SKIP_INTRO_COOKIE)) {
            CookieManager.registerCookie(COOKIES_TYPE.SKIP_INTRO_COOKIE, true, COOKIES_TYPE_DURATION.SKIP_INTRO_COOKIE_DURATION);
          }
        });
        load.on("loaded", (transition2, oldContainer, newContainer) => {
          var _a;
          this.call("destroy", oldContainer, "app");
          this.call("update", newContainer, "app");
          this.call("initCursor", null, "Cursor");
          if (window.currentTemplate === "home") {
            html.classList.remove("has-intro-revealed");
            html.classList.remove("has-experience-revealed");
          }
          html.classList.add("has-changed-page");
          html.setAttribute("data-scroll-theme", html.getAttribute("data-scroll-theme-main"));
          window.currentTemplate = (_a = html.dataset) == null ? void 0 : _a.template;
          window.isNotFirstLoading = true;
        });
      }
    };
  
    // assets/scripts/modules/Logo.js
    var DEFAULT_SCALE = 4.676;
    var Logo_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.$el = this.el;
        this.$parts = this.$("part");
        this.$letters = Array.from(this.$("letter"));
        this.translateY = 0;
        this.isAnimated = false;
      }
      init() {
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onResize() {
        this.computePosition();
        this.computeScale();
        this.applyStyle();
      }
      onFontsLoaded() {
        this.computePosition();
        this.computeScale();
        this.applyStyle();
      }
      updateScale(scale) {
        if (this.isAnimated)
          return;
        this.computeScale(scale);
        this.applyStyle();
      }
      computePosition() {
        const defaultOffsetTop = this.$el.offsetTop;
        const defaultOffsetHeight = this.$el.offsetHeight;
        const halfH = window.innerHeight * 0.5;
        this.translateY = halfH - defaultOffsetTop - defaultOffsetHeight * 0.5;
      }
      computeScale(scale = 1) {
        this.scale = DEFAULT_SCALE * scale;
      }
      applyStyle() {
        this.$el.style.transform = `translate3d(-50%, ${this.translateY}px, 0)`;
        for (let $letter of this.$letters) {
          $letter.style.transform = `scale(${this.scale})`;
        }
      }
      animateLogo({ timeline: timeline2, delay: delay3, callback }) {
        this.isAnimated = true;
        this.unbindEvents();
        const $logo = document.querySelector(".js-logo");
        const logoTop = $logo.offsetTop;
        const targetTop = (this.$el.offsetTop - logoTop) * -1;
        timeline2.to(this.$parts, {
          duration: 0.8,
          y: 0,
          autoAlpha: 1,
          ease: "power2.out",
          stagger: {
            each: 0.05,
            from: "center"
          },
          onComplete: () => {
            setTimeout(callback, 300);
          }
        }, delay3);
        timeline2.addLabel("staggerEnd");
        timeline2.to(this.$letters, {
          duration: 0.8,
          scale: 1,
          force3D: false,
          ease: "power3.inOut"
        }, "staggerEnd+=.3");
        timeline2.to(this.$el, {
          duration: 0.8,
          y: targetTop,
          scale: 1,
          force3D: true,
          ease: "power3.inOut"
        }, "staggerEnd+=.3");
      }
    };
  
    // assets/scripts/modules/LightTheme.js
    var LightTheme_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.$el = this.el;
      }
      init() {
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onResize() {
        this.call("update", null, "Scroll");
      }
      onFontsLoaded() {
        this.call("update", null, "Scroll");
      }
      onEnterInView() {
        requestAnimationFrame(() => {
          html.setAttribute("data-scroll-theme", "light");
        });
      }
      onExitInView() {
        requestAnimationFrame(() => {
          html.setAttribute("data-scroll-theme", "");
        });
      }
    };
  
    // node_modules/tabbable/dist/index.esm.js
    var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
    var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    var matches = typeof Element === "undefined" ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getCandidates = function getCandidates2(el, includeContainer, filter2) {
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter2);
      return candidates;
    };
    var isContentEditable = function isContentEditable2(node) {
      return node.contentEditable === "true";
    };
    var getTabindex = function getTabindex2(node) {
      var tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
      if (!isNaN(tabindexAttr)) {
        return tabindexAttr;
      }
      if (isContentEditable(node)) {
        return 0;
      }
      if ((node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
        return 0;
      }
      return node.tabIndex;
    };
    var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
      return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
    };
    var isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    var isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    var isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r;
    };
    var getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2].checked && nodes[i2].form === form) {
          return nodes[i2];
        }
      }
    };
    var isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || node.ownerDocument;
      var queryRadios = function queryRadios2(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    var isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    var isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    var isHidden = function isHidden2(node, displayCheck) {
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full") {
        while (node) {
          if (getComputedStyle(node).display === "none") {
            return true;
          }
          node = node.parentElement;
        }
      } else if (displayCheck === "non-zero-area") {
        var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
        return width === 0 && height === 0;
      }
      return false;
    };
    var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (isInput(node) || node.tagName === "SELECT" || node.tagName === "TEXTAREA" || node.tagName === "BUTTON") {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i2 = 0; i2 < parentNode.children.length; i2++) {
              var child = parentNode.children.item(i2);
              if (child.tagName === "LEGEND") {
                if (child.contains(node)) {
                  return false;
                }
                return true;
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
        return false;
      }
      return true;
    };
    var tabbable = function tabbable2(el, options) {
      options = options || {};
      var regularTabbables = [];
      var orderedTabbables = [];
      var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
      candidates.forEach(function(candidate, i2) {
        var candidateTabindex = getTabindex(candidate);
        if (candidateTabindex === 0) {
          regularTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            documentOrder: i2,
            tabIndex: candidateTabindex,
            node: candidate
          });
        }
      });
      var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function(a) {
        return a.node;
      }).concat(regularTabbables);
      return tabbableNodes;
    };
    var isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    var isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
  
    // node_modules/focus-trap/dist/focus-trap.esm.js
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var activeFocusTraps = function() {
      var trapQueue = [];
      return {
        activateTrap: function activateTrap(trap) {
          if (trapQueue.length > 0) {
            var activeTrap = trapQueue[trapQueue.length - 1];
            if (activeTrap !== trap) {
              activeTrap.pause();
            }
          }
          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex === -1) {
            trapQueue.push(trap);
          } else {
            trapQueue.splice(trapIndex, 1);
            trapQueue.push(trap);
          }
        },
        deactivateTrap: function deactivateTrap(trap) {
          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex !== -1) {
            trapQueue.splice(trapIndex, 1);
          }
          if (trapQueue.length > 0) {
            trapQueue[trapQueue.length - 1].unpause();
          }
        }
      };
    }();
    var isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    var isEscapeEvent = function isEscapeEvent2(e) {
      return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
    };
    var isTabEvent = function isTabEvent2(e) {
      return e.key === "Tab" || e.keyCode === 9;
    };
    var delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    var findIndex = function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value, i2) {
        if (fn(value)) {
          idx = i2;
          return false;
        }
        return true;
      });
      return idx;
    };
    var valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    var getActualTarget = function getActualTarget2(event2) {
      return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
    };
    var createFocusTrap = function createFocusTrap2(elements, userOptions) {
      var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var config3 = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true
      }, userOptions);
      var state = {
        containers: [],
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        delayInitialFocusTimer: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config3[configOptionName || optionName];
      };
      var containersContain = function containersContain2(element) {
        return !!(element && state.containers.some(function(container) {
          return container.contains(element);
        }));
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config3[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0) {
          if (containersContain(doc.activeElement)) {
            node = doc.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.tabbableGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container);
          if (tabbableNodes.length > 0) {
            return {
              container,
              firstTabbableNode: tabbableNodes[0],
              lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]
            };
          }
          return void 0;
        }).filter(function(group) {
          return !!group;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === doc.activeElement) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config3.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var checkPointerDown = function checkPointerDown2(e) {
        var target = getActualTarget(e);
        if (containersContain(target)) {
          return;
        }
        if (valueOrHandler(config3.clickOutsideDeactivates, e)) {
          trap.deactivate({
            returnFocus: config3.returnFocusOnDeactivate && !isFocusable(target)
          });
          return;
        }
        if (valueOrHandler(config3.allowOutsideClick, e)) {
          return;
        }
        e.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(e) {
        var target = getActualTarget(e);
        var targetContained = containersContain(target);
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          e.stopImmediatePropagation();
          tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
      };
      var checkTab = function checkTab2(e) {
        var target = getActualTarget(e);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findIndex(state.tabbableGroups, function(_ref) {
            var container = _ref.container;
            return container.contains(target);
          });
          if (containerIndex < 0) {
            if (e.shiftKey) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (e.shiftKey) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
              var firstTabbableNode = _ref2.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (state.tabbableGroups[containerIndex].container === target || isFocusable(target) && !isTabbable(target))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = destinationGroup.lastTabbableNode;
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var lastTabbableNode = _ref3.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (state.tabbableGroups[containerIndex].container === target || isFocusable(target) && !isTabbable(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = _destinationGroup.firstTabbableNode;
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        if (destinationNode) {
          e.preventDefault();
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(e) {
        if (isEscapeEvent(e) && valueOrHandler(config3.escapeDeactivates, e) !== false) {
          e.preventDefault();
          trap.deactivate();
          return;
        }
        if (isTabEvent(e)) {
          checkTab(e);
          return;
        }
      };
      var checkClick = function checkClick2(e) {
        if (valueOrHandler(config3.clickOutsideDeactivates, e)) {
          return;
        }
        var target = getActualTarget(e);
        if (containersContain(target)) {
          return;
        }
        if (valueOrHandler(config3.allowOutsideClick, e)) {
          return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trap);
        state.delayInitialFocusTimer = config3.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener("focusin", checkFocusIn, true);
        doc.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc.removeEventListener("focusin", checkFocusIn, true);
        doc.removeEventListener("mousedown", checkPointerDown, true);
        doc.removeEventListener("touchstart", checkPointerDown, true);
        doc.removeEventListener("click", checkClick, true);
        doc.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      trap = {
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc.activeElement;
          if (onActivate) {
            onActivate();
          }
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            if (onPostActivate) {
              onPostActivate();
            }
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          activeFocusTraps.deactivateTrap(trap);
          var onDeactivate = getOption(deactivateOptions, "onDeactivate");
          var onPostDeactivate = getOption(deactivateOptions, "onPostDeactivate");
          var checkCanReturnFocus = getOption(deactivateOptions, "checkCanReturnFocus");
          if (onDeactivate) {
            onDeactivate();
          }
          var returnFocus = getOption(deactivateOptions, "returnFocus", "returnFocusOnDeactivate");
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              if (onPostDeactivate) {
                onPostDeactivate();
              }
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause() {
          if (state.paused || !state.active) {
            return this;
          }
          state.paused = true;
          removeListeners();
          return this;
        },
        unpause: function unpause() {
          if (!state.paused || !state.active) {
            return this;
          }
          state.paused = false;
          updateTabbableNodes();
          addListeners();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
  
    // assets/scripts/modules/AbstractModal.js
    var AbstractModal_default = class extends _default {
      constructor(options) {
        super(options);
        this.moduleName = options.name;
        this.events = {
          click: {
            close: "close"
          }
        };
        this.closeBind = (e) => {
          if (e.key === "Escape") {
            this.close();
          }
        };
        this.toggler = null;
        this.focusTrapOptions = {
          checkCanFocusTrap: (trapContainers) => {
            const results = trapContainers.map((trapContainer) => {
              return new Promise((resolve) => {
                const interval = setInterval(() => {
                  if (getComputedStyle(trapContainer).visibility !== "hidden") {
                    resolve();
                    clearInterval(interval);
                  }
                }, 5);
              });
            });
            return Promise.all(results);
          },
          onActivate: () => {
            html.classList.add(this.activeClass);
            this.el.setAttribute("aria-hidden", false);
          },
          onPostActivate: () => {
            if (this.toggler) {
              this.toggler.setAttribute("aria-expanded", true);
            }
          },
          onDeactivate: () => {
            html.classList.remove(this.activeClass);
            this.el.setAttribute("aria-hidden", true);
          },
          onPostDeactivate: () => {
            if (this.toggler) {
              this.toggler.setAttribute("aria-expanded", false);
              this.toggler = null;
            }
          }
        };
        this.prevScrollTheme = "";
      }
      init() {
        var _a;
        if (typeof this.activeClass !== "string" || !this.activeClass) {
          throw new TypeError(`${this.moduleName} expects a CSS class name for the 'activeClass' property`);
        }
        this.focusTrap = createFocusTrap(this.el, this.focusTrapOptions);
        document.addEventListener("keyup", this.closeBind);
        (_a = this.onInit) == null ? void 0 : _a.call(this);
      }
      toggle(toggler) {
        if (toggler) {
          this.toggler = toggler;
        }
        if (html.classList.contains(this.activeClass)) {
          this.close();
        } else {
          this.open();
        }
      }
      open(args) {
        var _a, _b, _c;
        (_b = (_a = this.focusTrap) == null ? void 0 : _a.activate) == null ? void 0 : _b.call(_a);
        (_c = this.onOpen) == null ? void 0 : _c.call(this, args);
        this.prevScrollTheme = html.getAttribute("data-scroll-theme");
        html.setAttribute("data-scroll-theme", "light");
      }
      close() {
        var _a, _b, _c;
        (_b = (_a = this.focusTrap) == null ? void 0 : _a.deactivate) == null ? void 0 : _b.call(_a);
        (_c = this.onClose) == null ? void 0 : _c.call(this);
        if (html.getAttribute("data-scroll-theme-main") != "light") {
          html.setAttribute("data-scroll-theme", this.prevScrollTheme);
        }
      }
      destroy() {
        var _a, _b, _c;
        (_b = (_a = this.focusTrap) == null ? void 0 : _a.deactivate) == null ? void 0 : _b.call(_a, {
          returnFocus: false
        });
        document.removeEventListener("keyup", this.closeBind);
        (_c = this.onDestroy) == null ? void 0 : _c.call(this);
        super.destroy();
      }
    };
  
    // assets/scripts/modules/MenuModal.js
    var MenuModal_default = class extends AbstractModal_default {
      constructor(m) {
        super(m);
        __publicField(this, "activeClass", "has-menu-open");
        this.$anim = this.$("anim")[0];
        this.inner = this.$("inner")[0];
      }
      bindEvents() {
      }
      unbindEvents() {
      }
      onInit() {
      }
      onDestroy() {
      }
      onClose() {
        this.el.classList.remove("is-show");
        this.$anim.classList.remove("is-active");
      }
      onOpen(args) {
        requestAnimationFrame(() => {
          this.el.classList.add("is-show");
          this.$anim.classList.add("is-active");
        });
      }
    };
  
    // assets/scripts/modules/MenuToggler.js
    var MenuToggler_default = class extends _default {
      constructor(m) {
        super(m);
        this.events = {
          click: "openMenu"
        };
      }
      openMenu() {
        this.call("open", null, "MenuModal");
      }
    };
  
    // assets/scripts/modules/Positions.js
    var MAX_ITEMS_TO_SHOW = 6;
    var Positions_default = class extends _default {
      constructor(m) {
        super(m);
        this.$el = this.el;
        this.$buttons = this.$("button");
        this.$items = this.$("item");
        this.$loadmore = this.$("loadmore")[0];
        this.$loadmoreContainer = this.$("loadmoreContainer")[0];
        this.filterActive = "all";
        this.selectedItems = [];
        this.ignoredItems = [];
        this.foldItems = [];
        this.moreItems = [];
        this.isLoading = false;
        this.onClickBind = this.onClick.bind(this);
        this.onResizeBind = this.onResize.bind(this);
        this.onLoadBind = this.onLoad.bind(this);
      }
      init() {
        this.bindEvents();
        const $activeButton = this.$("button")[0];
        $activeButton == null ? void 0 : $activeButton.classList.add("is-active");
        this.filterJob();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        var _a;
        for (let index2 = 0; index2 < this.$buttons.length; index2++) {
          const $button = this.$buttons[index2];
          $button.addEventListener("click", this.onClickBind);
        }
        (_a = this.$loadmore) == null ? void 0 : _a.addEventListener("click", this.onLoadBind);
        window.addEventListener("resize", this.onResizeBind);
      }
      unbindEvents() {
        var _a;
        for (let index2 = 0; index2 < this.$buttons.length; index2++) {
          const $button = this.$buttons[index2];
          $button.removeEventListener("click", this.onClickBind);
        }
        (_a = this.$loadmore) == null ? void 0 : _a.removeEventListener("click", this.onLoadBind);
        window.removeEventListener("resize", this.onResizeBind);
      }
      onClick(e) {
        if (this.isLoading)
          return;
        const $target = e.target;
        this.filterActive = e.target.dataset.id;
        for (let index2 = 0; index2 < this.$buttons.length; index2++) {
          const $button = this.$buttons[index2];
          if ($button === $target) {
            $button.classList.add("is-active");
          } else {
            $button.classList.remove("is-active");
          }
        }
        this.filterJob();
      }
      onResize() {
      }
      onLoad() {
        if (this.$loadmoreContainer) {
          gsapWithCSS2.to(this.$loadmoreContainer, {
            duration: 0.6,
            autoAlpha: 0,
            onComplete: () => {
              this.$loadmoreContainer.style.display = "none";
              this.$moreItems.forEach(($item) => {
                $item.classList.remove("is-hidden");
                $item.setAttribute("aria-hidden", true);
              });
              this.call("resetItems", this.$selectedItems, "FollowingHover");
              this.call("update", null, "Scroll");
            }
          });
        }
      }
      filterJob() {
        this.$selectedItems = [];
        this.$ignoredItems = [];
        for (let index2 = 0; index2 < this.$items.length; index2++) {
          const $item = this.$items[index2];
          const itemFilters = $item.dataset.ids;
          const filters = itemFilters.split(",");
          if (this.filterActive === "all") {
            this.$selectedItems.push($item);
          } else if (filters.indexOf(this.filterActive) > -1) {
            this.$selectedItems.push($item);
          } else {
            this.$ignoredItems.push($item);
          }
        }
        this.updateList();
        if (this.$selectedItems.length > MAX_ITEMS_TO_SHOW) {
          if (this.$loadmoreContainer) {
            this.$loadmoreContainer.style.display = "";
            gsapWithCSS2.to(this.$loadmoreContainer, {
              duration: 0.6,
              autoAlpha: 1,
              delay: 1
            });
          }
        } else {
          if (this.$loadmoreContainer) {
            gsapWithCSS2.to(this.$loadmoreContainer, {
              duration: 0.6,
              autoAlpha: 0,
              onComplete: () => {
                this.$loadmoreContainer.style.display = "none";
              }
            });
          }
        }
      }
      updateList() {
        this.isLoading = true;
        this.$el.classList.add("is-loading");
        gsapWithCSS2.delayedCall(1, () => {
          this.$foldItems = this.$selectedItems.slice(0, MAX_ITEMS_TO_SHOW);
          this.$moreItems = this.$selectedItems.slice(MAX_ITEMS_TO_SHOW, this.$selectedItems.length);
          this.$ignoredItems.forEach(($item) => {
            $item.classList.add("is-hidden");
            $item.setAttribute("aria-hidden", true);
          });
          this.$foldItems.forEach(($item, index2) => {
            $item.classList.remove("is-hidden");
            $item.style.setProperty("--nth-child", index2);
            $item.setAttribute("aria-hidden", false);
          });
          this.$moreItems.forEach(($item, index2) => {
            $item.style.setProperty("--nth-child", index2);
            $item.setAttribute("aria-hidden", false);
            requestAnimationFrame(() => {
              $item.classList.add("is-hidden");
            });
          });
          this.call("resetItems", this.$selectedItems, "FollowingHover");
          this.$el.classList.remove("is-loading");
          this.isLoading = false;
          requestAnimationFrame(() => {
            this.call("update", null, "Scroll");
          });
        });
      }
    };
  
    // assets/scripts/modules/PushVideo.js
    var PushVideo_default = class extends _default {
      constructor(m) {
        super(m);
        this.data = {
          startProgressThreshold: 0 / 2,
          endProgressThreshold: 2 / 2,
          startScale: 1,
          endScale: 1.3
        };
        this.$el = this.el;
        this.$fading = this.$("fading")[0];
        this.$scaling = this.$("scaling")[0];
        this.$video = this.$("video")[0];
      }
      init() {
      }
      destroy() {
        super.destroy();
      }
      onProgress(scrollProgress) {
        if (!this.$fading && !this.$scaling)
          return;
        const progress = Math.round((this.computeProgressData(scrollProgress) + Number.EPSILON) * 100) / 100;
        this.fade(progress);
        if (this.$scaling)
          this.scale(progress);
      }
      onEnter() {
        this.$video.play();
        this.fadeIn();
      }
      onLeave() {
        this.$video.pause();
        this.fadeOut();
      }
      computeProgressData(scrollProgress) {
        return clamp3(map(scrollProgress, this.data.startProgressThreshold, this.data.endProgressThreshold, 0, 1), 0, 1);
      }
      fade(progress) {
        const opacity = 1 - progress;
        this.$fading.style.opacity = opacity;
      }
      fadeIn() {
        gsapWithCSS2.to(this.$fading, { opacity: 1, duration: 0.2, ease: "linear" });
      }
      fadeOut() {
        gsapWithCSS2.to(this.$fading, { opacity: 0, duration: 0.2, ease: "linear" });
      }
      scale(progress) {
        const scale = progress * (this.data.endScale - this.data.startScale) + this.data.startScale;
        this.$scaling.style.transform = "scale3d(" + scale + ", " + scale + ", 1)";
      }
    };
  
    // assets/scripts/utils/image.js
    var LAZY_LOADED_IMAGES = [];
    function loadImage2(url, options = {}) {
      return new Promise((resolve, reject) => {
        const $img = new Image();
        if (options.crossOrigin) {
          $img.crossOrigin = options.crossOrigin;
        }
        const loadCallback = () => {
          resolve(__spreadValues({
            element: $img
          }, getImageMetadata($img)));
        };
        if ($img.decode) {
          $img.src = url;
          $img.decode().then(loadCallback).catch((e) => {
            reject(e);
          });
        } else {
          $img.onload = loadCallback;
          $img.onerror = (e) => {
            reject(e);
          };
          $img.src = url;
        }
      });
    }
    function getImageMetadata($img) {
      return {
        url: $img.src,
        width: $img.naturalWidth,
        height: $img.naturalHeight,
        ratio: $img.naturalWidth / $img.naturalHeight
      };
    }
    function lazyLoadImage($el, url, callback) {
      return __async(this, null, function* () {
        let src2 = url ? url : $el.dataset.src;
        let loadedImage = LAZY_LOADED_IMAGES.find((image) => image.url === src2);
        if (!loadedImage) {
          loadedImage = yield loadImage2(src2);
          if (!loadedImage.url) {
            return;
          }
          LAZY_LOADED_IMAGES.push(loadedImage);
        }
        if ($el.src === src2) {
          return;
        }
        if ($el.tagName === "IMG") {
          $el.src = loadedImage.url;
        } else {
          $el.style.backgroundImage = `url(${loadedImage.url})`;
        }
        requestAnimationFrame(() => {
          let lazyParent = $el.closest(".c-lazy");
          if (lazyParent) {
            lazyParent.classList.add("-lazy-loaded");
            lazyParent.style.backgroundImage = "";
          }
          $el.classList.add("-lazy-loaded");
          callback == null ? void 0 : callback();
        });
      });
    }
    function preloadImages2(callback) {
      const $imagesToLoad = document.querySelectorAll("img[data-preload]");
      if (!$imagesToLoad.length) {
        callback == null ? void 0 : callback();
        return;
      }
      const promises = [];
      $imagesToLoad.forEach(($image) => {
        const url = $image.dataset.src;
        const promise = lazyLoadImage($image, url);
        promises.push(promise);
      });
      Promise.all(promises).then(() => {
        callback == null ? void 0 : callback();
      });
    }
  
    // node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js
    function _classCallCheck3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties3(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass3(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties3(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties3(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread22(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys2(Object(source), true).forEach(function(key) {
            _defineProperty3(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized2(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized2(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _get3(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get3 = Reflect.get;
      } else {
        _get3 = function _get4(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get3(target, property, receiver || target);
    }
    function _slicedToArray3(arr, i2) {
      return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i2) || _unsupportedIterableToArray3(arr, i2) || _nonIterableRest3();
    }
    function _toConsumableArray2(arr) {
      return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread2();
    }
    function _arrayWithoutHoles2(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray3(arr);
    }
    function _arrayWithHoles3(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArray2(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _iterableToArrayLimit3(arr, i2) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray3(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray3(o, minLen);
    }
    function _arrayLikeToArray3(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableSpread2() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest3() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var defaults2 = {
      el: document,
      name: "scroll",
      offset: [0, 0],
      repeat: false,
      smooth: false,
      initPosition: {
        x: 0,
        y: 0
      },
      direction: "vertical",
      gestureDirection: "vertical",
      reloadOnContextChange: false,
      lerp: 0.1,
      "class": "is-inview",
      scrollbarContainer: false,
      scrollbarClass: "c-scrollbar",
      scrollingClass: "has-scroll-scrolling",
      draggingClass: "has-scroll-dragging",
      smoothClass: "has-scroll-smooth",
      initClass: "has-scroll-init",
      getSpeed: false,
      getDirection: false,
      scrollFromAnywhere: false,
      multiplier: 1,
      firefoxMultiplier: 50,
      touchMultiplier: 2,
      resetNativeScroll: true,
      tablet: {
        smooth: false,
        direction: "vertical",
        gestureDirection: "vertical",
        breakpoint: 1024
      },
      smartphone: {
        smooth: false,
        direction: "vertical",
        gestureDirection: "vertical"
      }
    };
    var _default3 = /* @__PURE__ */ function() {
      function _default4() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck3(this, _default4);
        Object.assign(this, defaults2, options);
        this.smartphone = defaults2.smartphone;
        if (options.smartphone)
          Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults2.tablet;
        if (options.tablet)
          Object.assign(this.tablet, options.tablet);
        this.namespace = "locomotive";
        this.html = document.documentElement;
        this.windowHeight = window.innerHeight;
        this.windowWidth = window.innerWidth;
        this.windowMiddle = {
          x: this.windowWidth / 2,
          y: this.windowHeight / 2
        };
        this.els = {};
        this.currentElements = {};
        this.listeners = {};
        this.hasScrollTicking = false;
        this.hasCallEventSet = false;
        this.checkScroll = this.checkScroll.bind(this);
        this.checkResize = this.checkResize.bind(this);
        this.checkEvent = this.checkEvent.bind(this);
        this.instance = {
          scroll: {
            x: 0,
            y: 0
          },
          limit: {
            x: this.html.offsetWidth,
            y: this.html.offsetHeight
          },
          currentElements: this.currentElements
        };
        if (this.isMobile) {
          if (this.isTablet) {
            this.context = "tablet";
          } else {
            this.context = "smartphone";
          }
        } else {
          this.context = "desktop";
        }
        if (this.isMobile)
          this.direction = this[this.context].direction;
        if (this.direction === "horizontal") {
          this.directionAxis = "x";
        } else {
          this.directionAxis = "y";
        }
        if (this.getDirection) {
          this.instance.direction = null;
        }
        if (this.getDirection) {
          this.instance.speed = 0;
        }
        this.html.classList.add(this.initClass);
        window.addEventListener("resize", this.checkResize, false);
      }
      _createClass3(_default4, [{
        key: "init",
        value: function init6() {
          this.initEvents();
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          this.dispatchScroll();
        }
      }, {
        key: "checkResize",
        value: function checkResize() {
          var _this = this;
          if (!this.resizeTick) {
            this.resizeTick = true;
            requestAnimationFrame(function() {
              _this.resize();
              _this.resizeTick = false;
            });
          }
        }
      }, {
        key: "resize",
        value: function resize2() {
        }
      }, {
        key: "checkContext",
        value: function checkContext() {
          if (!this.reloadOnContextChange)
            return;
          this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint;
          this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
          var oldContext = this.context;
          if (this.isMobile) {
            if (this.isTablet) {
              this.context = "tablet";
            } else {
              this.context = "smartphone";
            }
          } else {
            this.context = "desktop";
          }
          if (oldContext != this.context) {
            var oldSmooth = oldContext == "desktop" ? this.smooth : this[oldContext].smooth;
            var newSmooth = this.context == "desktop" ? this.smooth : this[this.context].smooth;
            if (oldSmooth != newSmooth)
              window.location.reload();
          }
        }
      }, {
        key: "initEvents",
        value: function initEvents() {
          var _this2 = this;
          this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]"));
          this.setScrollTo = this.setScrollTo.bind(this);
          this.scrollToEls.forEach(function(el) {
            el.addEventListener("click", _this2.setScrollTo, false);
          });
        }
      }, {
        key: "setScrollTo",
        value: function setScrollTo(event2) {
          event2.preventDefault();
          this.scrollTo(event2.currentTarget.getAttribute("data-".concat(this.name, "-href")) || event2.currentTarget.getAttribute("href"), {
            offset: event2.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
          });
        }
      }, {
        key: "addElements",
        value: function addElements() {
        }
      }, {
        key: "detectElements",
        value: function detectElements(hasCallEventSet) {
          var _this3 = this;
          var scrollTop = this.instance.scroll.y;
          var scrollBottom = scrollTop + this.windowHeight;
          var scrollLeft = this.instance.scroll.x;
          var scrollRight = scrollLeft + this.windowWidth;
          Object.entries(this.els).forEach(function(_ref) {
            var _ref2 = _slicedToArray3(_ref, 2), i2 = _ref2[0], el = _ref2[1];
            if (el && (!el.inView || hasCallEventSet)) {
              if (_this3.direction === "horizontal") {
                if (scrollRight >= el.left && scrollLeft < el.right) {
                  _this3.setInView(el, i2);
                }
              } else {
                if (scrollBottom >= el.top && scrollTop < el.bottom) {
                  _this3.setInView(el, i2);
                }
              }
            }
            if (el && el.inView) {
              if (_this3.direction === "horizontal") {
                var width = el.right - el.left;
                el.progress = (_this3.instance.scroll.x - (el.left - _this3.windowWidth)) / (width + _this3.windowWidth);
                if (scrollRight < el.left || scrollLeft > el.right) {
                  _this3.setOutOfView(el, i2);
                }
              } else {
                var height = el.bottom - el.top;
                el.progress = (_this3.instance.scroll.y - (el.top - _this3.windowHeight)) / (height + _this3.windowHeight);
                if (scrollBottom < el.top || scrollTop > el.bottom) {
                  _this3.setOutOfView(el, i2);
                }
              }
            }
          });
          this.hasScrollTicking = false;
        }
      }, {
        key: "setInView",
        value: function setInView(current, i2) {
          this.els[i2].inView = true;
          current.el.classList.add(current["class"]);
          this.currentElements[i2] = current;
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, "enter");
            if (!current.repeat) {
              this.els[i2].call = false;
            }
          }
        }
      }, {
        key: "setOutOfView",
        value: function setOutOfView(current, i2) {
          var _this4 = this;
          this.els[i2].inView = false;
          Object.keys(this.currentElements).forEach(function(el) {
            el === i2 && delete _this4.currentElements[el];
          });
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, "exit");
          }
          if (current.repeat) {
            current.el.classList.remove(current["class"]);
          }
        }
      }, {
        key: "dispatchCall",
        value: function dispatchCall(current, way) {
          this.callWay = way;
          this.callValue = current.call.split(",").map(function(item) {
            return item.trim();
          });
          this.callObj = current;
          if (this.callValue.length == 1)
            this.callValue = this.callValue[0];
          var callEvent = new Event(this.namespace + "call");
          this.el.dispatchEvent(callEvent);
        }
      }, {
        key: "dispatchScroll",
        value: function dispatchScroll() {
          var scrollEvent = new Event(this.namespace + "scroll");
          this.el.dispatchEvent(scrollEvent);
        }
      }, {
        key: "setEvents",
        value: function setEvents(event2, func) {
          if (!this.listeners[event2]) {
            this.listeners[event2] = [];
          }
          var list = this.listeners[event2];
          list.push(func);
          if (list.length === 1) {
            this.el.addEventListener(this.namespace + event2, this.checkEvent, false);
          }
          if (event2 === "call") {
            this.hasCallEventSet = true;
            this.detectElements(true);
          }
        }
      }, {
        key: "unsetEvents",
        value: function unsetEvents(event2, func) {
          if (!this.listeners[event2])
            return;
          var list = this.listeners[event2];
          var index2 = list.indexOf(func);
          if (index2 < 0)
            return;
          list.splice(index2, 1);
          if (list.index === 0) {
            this.el.removeEventListener(this.namespace + event2, this.checkEvent, false);
          }
        }
      }, {
        key: "checkEvent",
        value: function checkEvent(event2) {
          var _this5 = this;
          var name = event2.type.replace(this.namespace, "");
          var list = this.listeners[name];
          if (!list || list.length === 0)
            return;
          list.forEach(function(func) {
            switch (name) {
              case "scroll":
                return func(_this5.instance);
              case "call":
                return func(_this5.callValue, _this5.callWay, _this5.callObj);
              default:
                return func();
            }
          });
        }
      }, {
        key: "startScroll",
        value: function startScroll() {
        }
      }, {
        key: "stopScroll",
        value: function stopScroll() {
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance.scroll = {
            x: 0,
            y: 0
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this6 = this;
          window.removeEventListener("resize", this.checkResize, false);
          Object.keys(this.listeners).forEach(function(event2) {
            _this6.el.removeEventListener(_this6.namespace + event2, _this6.checkEvent, false);
          });
          this.listeners = {};
          this.scrollToEls.forEach(function(el) {
            el.removeEventListener("click", _this6.setScrollTo, false);
          });
          this.html.classList.remove(this.initClass);
        }
      }]);
      return _default4;
    }();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function createCommonjsModule(fn, module2) {
      return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
    }
    var smoothscroll = createCommonjsModule(function(module2, exports2) {
      (function() {
        function polyfill() {
          var w = window;
          var d = document;
          if ("scrollBehavior" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {
            return;
          }
          var Element2 = w.HTMLElement || w.Element;
          var SCROLL_TIME = 468;
          var original = {
            scroll: w.scroll || w.scrollTo,
            scrollBy: w.scrollBy,
            elementScroll: Element2.prototype.scroll || scrollElement,
            scrollIntoView: Element2.prototype.scrollIntoView
          };
          var now3 = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;
          function isMicrosoftBrowser(userAgent) {
            var userAgentPatterns = ["MSIE ", "Trident/", "Edge/"];
            return new RegExp(userAgentPatterns.join("|")).test(userAgent);
          }
          var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;
          function scrollElement(x, y) {
            this.scrollLeft = x;
            this.scrollTop = y;
          }
          function ease(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
          }
          function shouldBailOut(firstArg) {
            if (firstArg === null || typeof firstArg !== "object" || firstArg.behavior === void 0 || firstArg.behavior === "auto" || firstArg.behavior === "instant") {
              return true;
            }
            if (typeof firstArg === "object" && firstArg.behavior === "smooth") {
              return false;
            }
            throw new TypeError("behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior.");
          }
          function hasScrollableSpace(el, axis) {
            if (axis === "Y") {
              return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
            }
            if (axis === "X") {
              return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
            }
          }
          function canOverflow(el, axis) {
            var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];
            return overflowValue === "auto" || overflowValue === "scroll";
          }
          function isScrollable(el) {
            var isScrollableY = hasScrollableSpace(el, "Y") && canOverflow(el, "Y");
            var isScrollableX = hasScrollableSpace(el, "X") && canOverflow(el, "X");
            return isScrollableY || isScrollableX;
          }
          function findScrollableParent(el) {
            while (el !== d.body && isScrollable(el) === false) {
              el = el.parentNode || el.host;
            }
            return el;
          }
          function step(context3) {
            var time = now3();
            var value;
            var currentX;
            var currentY;
            var elapsed = (time - context3.startTime) / SCROLL_TIME;
            elapsed = elapsed > 1 ? 1 : elapsed;
            value = ease(elapsed);
            currentX = context3.startX + (context3.x - context3.startX) * value;
            currentY = context3.startY + (context3.y - context3.startY) * value;
            context3.method.call(context3.scrollable, currentX, currentY);
            if (currentX !== context3.x || currentY !== context3.y) {
              w.requestAnimationFrame(step.bind(w, context3));
            }
          }
          function smoothScroll(el, x, y) {
            var scrollable;
            var startX;
            var startY;
            var method;
            var startTime = now3();
            if (el === d.body) {
              scrollable = w;
              startX = w.scrollX || w.pageXOffset;
              startY = w.scrollY || w.pageYOffset;
              method = original.scroll;
            } else {
              scrollable = el;
              startX = el.scrollLeft;
              startY = el.scrollTop;
              method = scrollElement;
            }
            step({
              scrollable,
              method,
              startTime,
              startX,
              startY,
              x,
              y
            });
          }
          w.scroll = w.scrollTo = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              original.scroll.call(w, arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : w.scrollX || w.pageXOffset, arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset);
              return;
            }
            smoothScroll.call(w, d.body, arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset);
          };
          w.scrollBy = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0])) {
              original.scrollBy.call(w, arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : 0, arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0);
              return;
            }
            smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));
          };
          Element2.prototype.scroll = Element2.prototype.scrollTo = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              if (typeof arguments[0] === "number" && arguments[1] === void 0) {
                throw new SyntaxError("Value could not be converted");
              }
              original.elementScroll.call(this, arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== "object" ? ~~arguments[0] : this.scrollLeft, arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop);
              return;
            }
            var left = arguments[0].left;
            var top = arguments[0].top;
            smoothScroll.call(this, this, typeof left === "undefined" ? this.scrollLeft : ~~left, typeof top === "undefined" ? this.scrollTop : ~~top);
          };
          Element2.prototype.scrollBy = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              original.elementScroll.call(this, arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);
              return;
            }
            this.scroll({
              left: ~~arguments[0].left + this.scrollLeft,
              top: ~~arguments[0].top + this.scrollTop,
              behavior: arguments[0].behavior
            });
          };
          Element2.prototype.scrollIntoView = function() {
            if (shouldBailOut(arguments[0]) === true) {
              original.scrollIntoView.call(this, arguments[0] === void 0 ? true : arguments[0]);
              return;
            }
            var scrollableParent = findScrollableParent(this);
            var parentRects = scrollableParent.getBoundingClientRect();
            var clientRects = this.getBoundingClientRect();
            if (scrollableParent !== d.body) {
              smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);
              if (w.getComputedStyle(scrollableParent).position !== "fixed") {
                w.scrollBy({
                  left: parentRects.left,
                  top: parentRects.top,
                  behavior: "smooth"
                });
              }
            } else {
              w.scrollBy({
                left: clientRects.left,
                top: clientRects.top,
                behavior: "smooth"
              });
            }
          };
        }
        {
          module2.exports = { polyfill };
        }
      })();
    });
    var smoothscroll_1 = smoothscroll.polyfill;
    var _default$12 = /* @__PURE__ */ function(_Core) {
      _inherits(_default4, _Core);
      var _super = _createSuper(_default4);
      function _default4() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck3(this, _default4);
        _this = _super.call(this, options);
        if (_this.resetNativeScroll) {
          if (history.scrollRestoration) {
            history.scrollRestoration = "manual";
          }
          window.scrollTo(0, 0);
        }
        window.addEventListener("scroll", _this.checkScroll, false);
        if (window.smoothscrollPolyfill === void 0) {
          window.smoothscrollPolyfill = smoothscroll;
          window.smoothscrollPolyfill.polyfill();
        }
        return _this;
      }
      _createClass3(_default4, [{
        key: "init",
        value: function init6() {
          this.instance.scroll.y = window.pageYOffset;
          this.addElements();
          this.detectElements();
          _get3(_getPrototypeOf(_default4.prototype), "init", this).call(this);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this2 = this;
          _get3(_getPrototypeOf(_default4.prototype), "checkScroll", this).call(this);
          if (this.getDirection) {
            this.addDirection();
          }
          if (this.getSpeed) {
            this.addSpeed();
            this.speedTs = Date.now();
          }
          this.instance.scroll.y = window.pageYOffset;
          if (Object.entries(this.els).length) {
            if (!this.hasScrollTicking) {
              requestAnimationFrame(function() {
                _this2.detectElements();
              });
              this.hasScrollTicking = true;
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (window.pageYOffset > this.instance.scroll.y) {
            if (this.instance.direction !== "down") {
              this.instance.direction = "down";
            }
          } else if (window.pageYOffset < this.instance.scroll.y) {
            if (this.instance.direction !== "up") {
              this.instance.direction = "up";
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (window.pageYOffset != this.instance.scroll.y) {
            this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "resize",
        value: function resize2() {
          if (Object.entries(this.els).length) {
            this.windowHeight = window.innerHeight;
            this.updateElements();
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this3 = this;
          this.els = {};
          var els = this.el.querySelectorAll("[data-" + this.name + "]");
          els.forEach(function(el, index2) {
            var BCR = el.getBoundingClientRect();
            var cl = el.dataset[_this3.name + "Class"] || _this3["class"];
            var id2 = typeof el.dataset[_this3.name + "Id"] === "string" ? el.dataset[_this3.name + "Id"] : index2;
            var top;
            var left;
            var offset2 = typeof el.dataset[_this3.name + "Offset"] === "string" ? el.dataset[_this3.name + "Offset"].split(",") : _this3.offset;
            var repeat = el.dataset[_this3.name + "Repeat"];
            var call = el.dataset[_this3.name + "Call"];
            var target = el.dataset[_this3.name + "Target"];
            var targetEl;
            if (target !== void 0) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            top = targetElBCR.top + _this3.instance.scroll.y;
            left = targetElBCR.left + _this3.instance.scroll.x;
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            if (repeat == "false") {
              repeat = false;
            } else if (repeat != void 0) {
              repeat = true;
            } else {
              repeat = _this3.repeat;
            }
            var relativeOffset = _this3.getRelativeOffset(offset2);
            top = top + relativeOffset[0];
            bottom = bottom - relativeOffset[1];
            var mappedEl = {
              el,
              targetEl,
              id: id2,
              "class": cl,
              top,
              bottom,
              left,
              right,
              offset: offset2,
              progress: 0,
              repeat,
              inView: false,
              call
            };
            _this3.els[id2] = mappedEl;
            if (el.classList.contains(cl)) {
              _this3.setInView(_this3.els[id2], id2);
            }
          });
        }
      }, {
        key: "updateElements",
        value: function updateElements() {
          var _this4 = this;
          Object.entries(this.els).forEach(function(_ref) {
            var _ref2 = _slicedToArray3(_ref, 2), i2 = _ref2[0], el = _ref2[1];
            var top = el.targetEl.getBoundingClientRect().top + _this4.instance.scroll.y;
            var bottom = top + el.targetEl.offsetHeight;
            var relativeOffset = _this4.getRelativeOffset(el.offset);
            _this4.els[i2].top = top + relativeOffset[0];
            _this4.els[i2].bottom = bottom - relativeOffset[1];
          });
          this.hasScrollTicking = false;
        }
      }, {
        key: "getRelativeOffset",
        value: function getRelativeOffset(offset2) {
          var relativeOffset = [0, 0];
          if (offset2) {
            for (var i2 = 0; i2 < offset2.length; i2++) {
              if (typeof offset2[i2] == "string") {
                if (offset2[i2].includes("%")) {
                  relativeOffset[i2] = parseInt(offset2[i2].replace("%", "") * this.windowHeight / 100);
                } else {
                  relativeOffset[i2] = parseInt(offset2[i2]);
                }
              } else {
                relativeOffset[i2] = offset2[i2];
              }
            }
          }
          return relativeOffset;
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var offset2 = parseInt(options.offset) || 0;
          var callback = options.callback ? options.callback : false;
          if (typeof target === "string") {
            if (target === "top") {
              target = this.html;
            } else if (target === "bottom") {
              target = this.html.offsetHeight - window.innerHeight;
            } else {
              target = document.querySelector(target);
              if (!target) {
                return;
              }
            }
          } else if (typeof target === "number") {
            target = parseInt(target);
          } else if (target && target.tagName)
            ;
          else {
            console.warn("`target` parameter is not valid");
            return;
          }
          if (typeof target !== "number") {
            offset2 = target.getBoundingClientRect().top + offset2 + this.instance.scroll.y;
          } else {
            offset2 = target + offset2;
          }
          var isTargetReached = function isTargetReached2() {
            return parseInt(window.pageYOffset) === parseInt(offset2);
          };
          if (callback) {
            if (isTargetReached()) {
              callback();
              return;
            } else {
              var onScroll2 = function onScroll3() {
                if (isTargetReached()) {
                  window.removeEventListener("scroll", onScroll3);
                  callback();
                }
              };
              window.addEventListener("scroll", onScroll2);
            }
          }
          window.scrollTo({
            top: offset2,
            behavior: options.duration === 0 ? "auto" : "smooth"
          });
        }
      }, {
        key: "update",
        value: function update() {
          this.addElements();
          this.detectElements();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get3(_getPrototypeOf(_default4.prototype), "destroy", this).call(this);
          window.removeEventListener("scroll", this.checkScroll, false);
        }
      }]);
      return _default4;
    }(_default3);
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
    function E() {
    }
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self2 = this;
        function listener() {
          self2.off(name, listener);
          callback.apply(ctx, arguments);
        }
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i2 = 0;
        var len = evtArr.length;
        for (i2; i2 < len; i2++) {
          evtArr[i2].fn.apply(evtArr[i2].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i2 = 0, len = evts.length; i2 < len; i2++) {
            if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
              liveEvents.push(evts[i2]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    var tinyEmitter = E;
    var lethargy = createCommonjsModule(function(module2, exports2) {
      (function() {
        var root;
        root = exports2 !== null ? exports2 : this;
        root.Lethargy = function() {
          function Lethargy2(stability, sensitivity, tolerance, delay3) {
            this.stability = stability != null ? Math.abs(stability) : 8;
            this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
            this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
            this.delay = delay3 != null ? delay3 : 150;
            this.lastUpDeltas = function() {
              var i2, ref, results;
              results = [];
              for (i2 = 1, ref = this.stability * 2; 1 <= ref ? i2 <= ref : i2 >= ref; 1 <= ref ? i2++ : i2--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.lastDownDeltas = function() {
              var i2, ref, results;
              results = [];
              for (i2 = 1, ref = this.stability * 2; 1 <= ref ? i2 <= ref : i2 >= ref; 1 <= ref ? i2++ : i2--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.deltasTimestamp = function() {
              var i2, ref, results;
              results = [];
              for (i2 = 1, ref = this.stability * 2; 1 <= ref ? i2 <= ref : i2 >= ref; 1 <= ref ? i2++ : i2--) {
                results.push(null);
              }
              return results;
            }.call(this);
          }
          Lethargy2.prototype.check = function(e) {
            var lastDelta;
            e = e.originalEvent || e;
            if (e.wheelDelta != null) {
              lastDelta = e.wheelDelta;
            } else if (e.deltaY != null) {
              lastDelta = e.deltaY * -40;
            } else if (e.detail != null || e.detail === 0) {
              lastDelta = e.detail * -40;
            }
            this.deltasTimestamp.push(Date.now());
            this.deltasTimestamp.shift();
            if (lastDelta > 0) {
              this.lastUpDeltas.push(lastDelta);
              this.lastUpDeltas.shift();
              return this.isInertia(1);
            } else {
              this.lastDownDeltas.push(lastDelta);
              this.lastDownDeltas.shift();
              return this.isInertia(-1);
            }
          };
          Lethargy2.prototype.isInertia = function(direction) {
            var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
            lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
            if (lastDeltas[0] === null) {
              return direction;
            }
            if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) {
              return false;
            }
            lastDeltasOld = lastDeltas.slice(0, this.stability);
            lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
            oldSum = lastDeltasOld.reduce(function(t, s) {
              return t + s;
            });
            newSum = lastDeltasNew.reduce(function(t, s) {
              return t + s;
            });
            oldAverage = oldSum / lastDeltasOld.length;
            newAverage = newSum / lastDeltasNew.length;
            if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage)) {
              return direction;
            } else {
              return false;
            }
          };
          Lethargy2.prototype.showLastUpDeltas = function() {
            return this.lastUpDeltas;
          };
          Lethargy2.prototype.showLastDownDeltas = function() {
            return this.lastDownDeltas;
          };
          return Lethargy2;
        }();
      }).call(commonjsGlobal);
    });
    var support2 = function getSupport2() {
      return {
        hasWheelEvent: "onwheel" in document,
        hasMouseWheelEvent: "onmousewheel" in document,
        hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        hasPointer: !!window.navigator.msPointerEnabled,
        hasKeyDown: "onkeydown" in document,
        isFirefox: navigator.userAgent.indexOf("Firefox") > -1
      };
    }();
    var toString = Object.prototype.toString;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var bindallStandalone = function(object) {
      if (!object)
        return console.warn("bindAll requires at least one argument.");
      var functions = Array.prototype.slice.call(arguments, 1);
      if (functions.length === 0) {
        for (var method in object) {
          if (hasOwnProperty$1.call(object, method)) {
            if (typeof object[method] == "function" && toString.call(object[method]) == "[object Function]") {
              functions.push(method);
            }
          }
        }
      }
      for (var i2 = 0; i2 < functions.length; i2++) {
        var f = functions[i2];
        object[f] = bind(object[f], object);
      }
    };
    function bind(func, context3) {
      return function() {
        return func.apply(context3, arguments);
      };
    }
    var Lethargy = lethargy.Lethargy;
    var EVT_ID = "virtualscroll";
    var src = VirtualScroll;
    var keyCodes = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32
    };
    function VirtualScroll(options) {
      bindallStandalone(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown");
      this.el = window;
      if (options && options.el) {
        this.el = options.el;
        delete options.el;
      }
      this.options = objectAssign({
        mouseMultiplier: 1,
        touchMultiplier: 2,
        firefoxMultiplier: 15,
        keyStep: 120,
        preventTouch: false,
        unpreventTouchClass: "vs-touchmove-allowed",
        limitInertia: false,
        useKeyboard: true,
        useTouch: true
      }, options);
      if (this.options.limitInertia)
        this._lethargy = new Lethargy();
      this._emitter = new tinyEmitter();
      this._event = {
        y: 0,
        x: 0,
        deltaX: 0,
        deltaY: 0
      };
      this.touchStartX = null;
      this.touchStartY = null;
      this.bodyTouchAction = null;
      if (this.options.passive !== void 0) {
        this.listenerOptions = { passive: this.options.passive };
      }
    }
    VirtualScroll.prototype._notify = function(e) {
      var evt = this._event;
      evt.x += evt.deltaX;
      evt.y += evt.deltaY;
      this._emitter.emit(EVT_ID, {
        x: evt.x,
        y: evt.y,
        deltaX: evt.deltaX,
        deltaY: evt.deltaY,
        originalEvent: e
      });
    };
    VirtualScroll.prototype._onWheel = function(e) {
      var options = this.options;
      if (this._lethargy && this._lethargy.check(e) === false)
        return;
      var evt = this._event;
      evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
      evt.deltaY = e.wheelDeltaY || e.deltaY * -1;
      if (support2.isFirefox && e.deltaMode == 1) {
        evt.deltaX *= options.firefoxMultiplier;
        evt.deltaY *= options.firefoxMultiplier;
      }
      evt.deltaX *= options.mouseMultiplier;
      evt.deltaY *= options.mouseMultiplier;
      this._notify(e);
    };
    VirtualScroll.prototype._onMouseWheel = function(e) {
      if (this.options.limitInertia && this._lethargy.check(e) === false)
        return;
      var evt = this._event;
      evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0;
      evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta;
      this._notify(e);
    };
    VirtualScroll.prototype._onTouchStart = function(e) {
      var t = e.targetTouches ? e.targetTouches[0] : e;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
    };
    VirtualScroll.prototype._onTouchMove = function(e) {
      var options = this.options;
      if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) {
        e.preventDefault();
      }
      var evt = this._event;
      var t = e.targetTouches ? e.targetTouches[0] : e;
      evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
      evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
      this._notify(e);
    };
    VirtualScroll.prototype._onKeyDown = function(e) {
      var evt = this._event;
      evt.deltaX = evt.deltaY = 0;
      var windowHeight = window.innerHeight - 40;
      switch (e.keyCode) {
        case keyCodes.LEFT:
        case keyCodes.UP:
          evt.deltaY = this.options.keyStep;
          break;
        case keyCodes.RIGHT:
        case keyCodes.DOWN:
          evt.deltaY = -this.options.keyStep;
          break;
        case e.shiftKey:
          evt.deltaY = windowHeight;
          break;
        case keyCodes.SPACE:
          evt.deltaY = -windowHeight;
          break;
        default:
          return;
      }
      this._notify(e);
    };
    VirtualScroll.prototype._bind = function() {
      if (support2.hasWheelEvent)
        this.el.addEventListener("wheel", this._onWheel, this.listenerOptions);
      if (support2.hasMouseWheelEvent)
        this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions);
      if (support2.hasTouch && this.options.useTouch) {
        this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions);
        this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions);
      }
      if (support2.hasPointer && support2.hasTouchWin) {
        this.bodyTouchAction = document.body.style.msTouchAction;
        document.body.style.msTouchAction = "none";
        this.el.addEventListener("MSPointerDown", this._onTouchStart, true);
        this.el.addEventListener("MSPointerMove", this._onTouchMove, true);
      }
      if (support2.hasKeyDown && this.options.useKeyboard)
        document.addEventListener("keydown", this._onKeyDown);
    };
    VirtualScroll.prototype._unbind = function() {
      if (support2.hasWheelEvent)
        this.el.removeEventListener("wheel", this._onWheel);
      if (support2.hasMouseWheelEvent)
        this.el.removeEventListener("mousewheel", this._onMouseWheel);
      if (support2.hasTouch) {
        this.el.removeEventListener("touchstart", this._onTouchStart);
        this.el.removeEventListener("touchmove", this._onTouchMove);
      }
      if (support2.hasPointer && support2.hasTouchWin) {
        document.body.style.msTouchAction = this.bodyTouchAction;
        this.el.removeEventListener("MSPointerDown", this._onTouchStart, true);
        this.el.removeEventListener("MSPointerMove", this._onTouchMove, true);
      }
      if (support2.hasKeyDown && this.options.useKeyboard)
        document.removeEventListener("keydown", this._onKeyDown);
    };
    VirtualScroll.prototype.on = function(cb, ctx) {
      this._emitter.on(EVT_ID, cb, ctx);
      var events2 = this._emitter.e;
      if (events2 && events2[EVT_ID] && events2[EVT_ID].length === 1)
        this._bind();
    };
    VirtualScroll.prototype.off = function(cb, ctx) {
      this._emitter.off(EVT_ID, cb, ctx);
      var events2 = this._emitter.e;
      if (!events2[EVT_ID] || events2[EVT_ID].length <= 0)
        this._unbind();
    };
    VirtualScroll.prototype.reset = function() {
      var evt = this._event;
      evt.x = 0;
      evt.y = 0;
    };
    VirtualScroll.prototype.destroy = function() {
      this._emitter.off();
      this._unbind();
    };
    function lerp3(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }
    function getTranslate2(el) {
      var translate2 = {};
      if (!window.getComputedStyle)
        return;
      var style = getComputedStyle(el);
      var transform3 = style.transform || style.webkitTransform || style.mozTransform;
      var mat = transform3.match(/^matrix3d\((.+)\)$/);
      if (mat) {
        translate2.x = mat ? parseFloat(mat[1].split(", ")[12]) : 0;
        translate2.y = mat ? parseFloat(mat[1].split(", ")[13]) : 0;
      } else {
        mat = transform3.match(/^matrix\((.+)\)$/);
        translate2.x = mat ? parseFloat(mat[1].split(", ")[4]) : 0;
        translate2.y = mat ? parseFloat(mat[1].split(", ")[5]) : 0;
      }
      return translate2;
    }
    function getParents(elem) {
      var parents2 = [];
      for (; elem && elem !== document; elem = elem.parentNode) {
        parents2.push(elem);
      }
      return parents2;
    }
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 1e-3;
    var SUBDIVISION_PRECISION = 1e-7;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1 / (kSplineTableSize - 1);
    var float32ArraySupported = typeof Float32Array === "function";
    function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C(aA1) {
      return 3 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
      return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i2 = 0;
      do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0) {
          return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }
    function LinearEasing(x) {
      return x;
    }
    var src$1 = function bezier2(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
        sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing(x) {
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };
    var keyCodes$1 = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32,
      TAB: 9,
      PAGEUP: 33,
      PAGEDOWN: 34,
      HOME: 36,
      END: 35
    };
    var _default$2 = /* @__PURE__ */ function(_Core) {
      _inherits(_default4, _Core);
      var _super = _createSuper(_default4);
      function _default4() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck3(this, _default4);
        if (history.scrollRestoration) {
          history.scrollRestoration = "manual";
        }
        window.scrollTo(0, 0);
        _this = _super.call(this, options);
        if (_this.inertia)
          _this.lerp = _this.inertia * 0.1;
        _this.isScrolling = false;
        _this.isDraggingScrollbar = false;
        _this.isTicking = false;
        _this.hasScrollTicking = false;
        _this.parallaxElements = {};
        _this.stop = false;
        _this.scrollbarContainer = options.scrollbarContainer;
        _this.checkKey = _this.checkKey.bind(_assertThisInitialized2(_this));
        window.addEventListener("keydown", _this.checkKey, false);
        return _this;
      }
      _createClass3(_default4, [{
        key: "init",
        value: function init6() {
          var _this2 = this;
          this.html.classList.add(this.smoothClass);
          this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction);
          this.instance = _objectSpread22({
            delta: {
              x: this.initPosition.x,
              y: this.initPosition.y
            },
            scroll: {
              x: this.initPosition.x,
              y: this.initPosition.y
            }
          }, this.instance);
          this.vs = new src({
            el: this.scrollFromAnywhere ? document : this.el,
            mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : 0.4,
            firefoxMultiplier: this.firefoxMultiplier,
            touchMultiplier: this.touchMultiplier,
            useKeyboard: false,
            passive: true
          });
          this.vs.on(function(e) {
            if (_this2.stop) {
              return;
            }
            if (!_this2.isDraggingScrollbar) {
              requestAnimationFrame(function() {
                _this2.updateDelta(e);
                if (!_this2.isScrolling)
                  _this2.startScrolling();
              });
            }
          });
          this.setScrollLimit();
          this.initScrollBar();
          this.addSections();
          this.addElements();
          this.checkScroll(true);
          this.transformElements(true, true);
          _get3(_getPrototypeOf(_default4.prototype), "init", this).call(this);
        }
      }, {
        key: "setScrollLimit",
        value: function setScrollLimit() {
          this.instance.limit.y = this.el.offsetHeight - this.windowHeight;
          if (this.direction === "horizontal") {
            var totalWidth = 0;
            var nodes = this.el.children;
            for (var i2 = 0; i2 < nodes.length; i2++) {
              totalWidth += nodes[i2].offsetWidth;
            }
            this.instance.limit.x = totalWidth - this.windowWidth;
          }
        }
      }, {
        key: "startScrolling",
        value: function startScrolling() {
          this.startScrollTs = Date.now();
          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "stopScrolling",
        value: function stopScrolling() {
          cancelAnimationFrame(this.checkScrollRaf);
          this.startScrollTs = void 0;
          if (this.scrollToRaf) {
            cancelAnimationFrame(this.scrollToRaf);
            this.scrollToRaf = null;
          }
          this.isScrolling = false;
          this.instance.scroll.y = Math.round(this.instance.scroll.y);
          this.html.classList.remove(this.scrollingClass);
        }
      }, {
        key: "checkKey",
        value: function checkKey(e) {
          var _this3 = this;
          if (this.stop) {
            if (e.keyCode == keyCodes$1.TAB) {
              requestAnimationFrame(function() {
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0;
              });
            }
            return;
          }
          switch (e.keyCode) {
            case keyCodes$1.TAB:
              requestAnimationFrame(function() {
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0;
                _this3.scrollTo(document.activeElement, {
                  offset: -window.innerHeight / 2
                });
              });
              break;
            case keyCodes$1.UP:
              this.instance.delta[this.directionAxis] -= 240;
              break;
            case keyCodes$1.DOWN:
              this.instance.delta[this.directionAxis] += 240;
              break;
            case keyCodes$1.PAGEUP:
              this.instance.delta[this.directionAxis] -= window.innerHeight;
              break;
            case keyCodes$1.PAGEDOWN:
              this.instance.delta[this.directionAxis] += window.innerHeight;
              break;
            case keyCodes$1.HOME:
              this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.END:
              this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.SPACE:
              if (!(document.activeElement instanceof HTMLInputElement) && !(document.activeElement instanceof HTMLTextAreaElement)) {
                if (e.shiftKey) {
                  this.instance.delta[this.directionAxis] -= window.innerHeight;
                } else {
                  this.instance.delta[this.directionAxis] += window.innerHeight;
                }
              }
              break;
            default:
              return;
          }
          if (this.instance.delta[this.directionAxis] < 0)
            this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis])
            this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
          this.stopScrolling();
          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this4 = this;
          var forced = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          if (forced || this.isScrolling || this.isDraggingScrollbar) {
            if (!this.hasScrollTicking) {
              this.checkScrollRaf = requestAnimationFrame(function() {
                return _this4.checkScroll();
              });
              this.hasScrollTicking = true;
            }
            this.updateScroll();
            var distance = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]);
            var timeSinceStart = Date.now() - this.startScrollTs;
            if (!this.animatingScroll && timeSinceStart > 100 && (distance < 0.5 && this.instance.delta[this.directionAxis] != 0 || distance < 0.5 && this.instance.delta[this.directionAxis] == 0)) {
              this.stopScrolling();
            }
            Object.entries(this.sections).forEach(function(_ref) {
              var _ref2 = _slicedToArray3(_ref, 2), i2 = _ref2[0], section = _ref2[1];
              if (section.persistent || _this4.instance.scroll[_this4.directionAxis] > section.offset[_this4.directionAxis] && _this4.instance.scroll[_this4.directionAxis] < section.limit[_this4.directionAxis]) {
                if (_this4.direction === "horizontal") {
                  _this4.transform(section.el, -_this4.instance.scroll[_this4.directionAxis], 0);
                } else {
                  _this4.transform(section.el, 0, -_this4.instance.scroll[_this4.directionAxis]);
                }
                if (!section.inView) {
                  section.inView = true;
                  section.el.style.opacity = 1;
                  section.el.style.pointerEvents = "all";
                  section.el.setAttribute("data-".concat(_this4.name, "-section-inview"), "");
                }
              } else {
                if (section.inView || forced) {
                  section.inView = false;
                  section.el.style.opacity = 0;
                  section.el.style.pointerEvents = "none";
                  section.el.removeAttribute("data-".concat(_this4.name, "-section-inview"));
                }
                _this4.transform(section.el, 0, 0);
              }
            });
            if (this.getDirection) {
              this.addDirection();
            }
            if (this.getSpeed) {
              this.addSpeed();
              this.speedTs = Date.now();
            }
            this.detectElements();
            this.transformElements();
            if (this.hasScrollbar) {
              var scrollBarTranslation = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
              if (this.direction === "horizontal") {
                this.transform(this.scrollbarThumb, scrollBarTranslation, 0);
              } else {
                this.transform(this.scrollbarThumb, 0, scrollBarTranslation);
              }
            }
            _get3(_getPrototypeOf(_default4.prototype), "checkScroll", this).call(this);
            this.hasScrollTicking = false;
          }
        }
      }, {
        key: "resize",
        value: function resize2() {
          this.windowHeight = window.innerHeight;
          this.windowWidth = window.innerWidth;
          this.checkContext();
          this.windowMiddle = {
            x: this.windowWidth / 2,
            y: this.windowHeight / 2
          };
          this.update();
        }
      }, {
        key: "updateDelta",
        value: function updateDelta(e) {
          var delta;
          var gestureDirection = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
          if (gestureDirection === "both") {
            delta = e.deltaX + e.deltaY;
          } else if (gestureDirection === "vertical") {
            delta = e.deltaY;
          } else if (gestureDirection === "horizontal") {
            delta = e.deltaX;
          } else {
            delta = e.deltaY;
          }
          this.instance.delta[this.directionAxis] -= delta * this.multiplier;
          if (this.instance.delta[this.directionAxis] < 0)
            this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis])
            this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
        }
      }, {
        key: "updateScroll",
        value: function updateScroll(e) {
          if (this.isScrolling || this.isDraggingScrollbar) {
            this.instance.scroll[this.directionAxis] = lerp3(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp);
          } else {
            if (this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis]) {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]);
            } else if (this.instance.scroll.y < 0) {
              this.setScroll(this.instance.scroll[this.directionAxis], 0);
            } else {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (this.instance.delta.y > this.instance.scroll.y) {
            if (this.instance.direction !== "down") {
              this.instance.direction = "down";
            }
          } else if (this.instance.delta.y < this.instance.scroll.y) {
            if (this.instance.direction !== "up") {
              this.instance.direction = "up";
            }
          }
          if (this.instance.delta.x > this.instance.scroll.x) {
            if (this.instance.direction !== "right") {
              this.instance.direction = "right";
            }
          } else if (this.instance.delta.x < this.instance.scroll.x) {
            if (this.instance.direction !== "left") {
              this.instance.direction = "left";
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis]) {
            this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "initScrollBar",
        value: function initScrollBar() {
          this.scrollbar = document.createElement("span");
          this.scrollbarThumb = document.createElement("span");
          this.scrollbar.classList.add("".concat(this.scrollbarClass));
          this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb"));
          this.scrollbar.append(this.scrollbarThumb);
          if (this.scrollbarContainer) {
            this.scrollbarContainer.append(this.scrollbar);
          } else {
            document.body.append(this.scrollbar);
          }
          this.getScrollBar = this.getScrollBar.bind(this);
          this.releaseScrollBar = this.releaseScrollBar.bind(this);
          this.moveScrollBar = this.moveScrollBar.bind(this);
          this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar);
          window.addEventListener("mouseup", this.releaseScrollBar);
          window.addEventListener("mousemove", this.moveScrollBar);
          this.hasScrollbar = false;
          if (this.direction == "horizontal") {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === "horizontal") {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "reinitScrollBar",
        value: function reinitScrollBar() {
          this.hasScrollbar = false;
          if (this.direction == "horizontal") {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === "horizontal") {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "destroyScrollBar",
        value: function destroyScrollBar() {
          this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar);
          window.removeEventListener("mouseup", this.releaseScrollBar);
          window.removeEventListener("mousemove", this.moveScrollBar);
          this.scrollbar.remove();
        }
      }, {
        key: "getScrollBar",
        value: function getScrollBar(e) {
          this.isDraggingScrollbar = true;
          this.checkScroll();
          this.html.classList.remove(this.scrollingClass);
          this.html.classList.add(this.draggingClass);
        }
      }, {
        key: "releaseScrollBar",
        value: function releaseScrollBar(e) {
          this.isDraggingScrollbar = false;
          if (this.isScrolling) {
            this.html.classList.add(this.scrollingClass);
          }
          this.html.classList.remove(this.draggingClass);
        }
      }, {
        key: "moveScrollBar",
        value: function moveScrollBar(e) {
          var _this5 = this;
          if (this.isDraggingScrollbar) {
            requestAnimationFrame(function() {
              var x = (e.clientX - _this5.scrollbarBCR.left) * 100 / _this5.scrollbarWidth * _this5.instance.limit.x / 100;
              var y = (e.clientY - _this5.scrollbarBCR.top) * 100 / _this5.scrollbarHeight * _this5.instance.limit.y / 100;
              if (y > 0 && y < _this5.instance.limit.y) {
                _this5.instance.delta.y = y;
              }
              if (x > 0 && x < _this5.instance.limit.x) {
                _this5.instance.delta.x = x;
              }
            });
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this6 = this;
          this.els = {};
          this.parallaxElements = {};
          var els = this.el.querySelectorAll("[data-".concat(this.name, "]"));
          els.forEach(function(el, index2) {
            var targetParents = getParents(el);
            var section = Object.entries(_this6.sections).map(function(_ref3) {
              var _ref4 = _slicedToArray3(_ref3, 2), key = _ref4[0], section2 = _ref4[1];
              return section2;
            }).find(function(section2) {
              return targetParents.includes(section2.el);
            });
            var cl = el.dataset[_this6.name + "Class"] || _this6["class"];
            var id2 = typeof el.dataset[_this6.name + "Id"] === "string" ? el.dataset[_this6.name + "Id"] : "el" + index2;
            var top;
            var left;
            var repeat = el.dataset[_this6.name + "Repeat"];
            var call = el.dataset[_this6.name + "Call"];
            var position = el.dataset[_this6.name + "Position"];
            var delay3 = el.dataset[_this6.name + "Delay"];
            var direction = el.dataset[_this6.name + "Direction"];
            var sticky = typeof el.dataset[_this6.name + "Sticky"] === "string";
            var speed = el.dataset[_this6.name + "Speed"] ? parseFloat(el.dataset[_this6.name + "Speed"]) / 10 : false;
            var offset2 = typeof el.dataset[_this6.name + "Offset"] === "string" ? el.dataset[_this6.name + "Offset"].split(",") : _this6.offset;
            var target = el.dataset[_this6.name + "Target"];
            var targetEl;
            if (target !== void 0) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            if (section === null) {
              top = targetElBCR.top + _this6.instance.scroll.y - getTranslate2(targetEl).y;
              left = targetElBCR.left + _this6.instance.scroll.x - getTranslate2(targetEl).x;
            } else {
              if (!section.inView) {
                top = targetElBCR.top - getTranslate2(section.el).y - getTranslate2(targetEl).y;
                left = targetElBCR.left - getTranslate2(section.el).x - getTranslate2(targetEl).x;
              } else {
                top = targetElBCR.top + _this6.instance.scroll.y - getTranslate2(targetEl).y;
                left = targetElBCR.left + _this6.instance.scroll.x - getTranslate2(targetEl).x;
              }
            }
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            var middle = {
              x: (right - left) / 2 + left,
              y: (bottom - top) / 2 + top
            };
            if (sticky) {
              var elBCR = el.getBoundingClientRect();
              var elTop = elBCR.top;
              var elLeft = elBCR.left;
              var elDistance = {
                x: elLeft - left,
                y: elTop - top
              };
              top += window.innerHeight;
              left += window.innerWidth;
              bottom = elTop + targetEl.offsetHeight - el.offsetHeight - elDistance[_this6.directionAxis];
              right = elLeft + targetEl.offsetWidth - el.offsetWidth - elDistance[_this6.directionAxis];
              middle = {
                x: (right - left) / 2 + left,
                y: (bottom - top) / 2 + top
              };
            }
            if (repeat == "false") {
              repeat = false;
            } else if (repeat != void 0) {
              repeat = true;
            } else {
              repeat = _this6.repeat;
            }
            var relativeOffset = [0, 0];
            if (offset2) {
              if (_this6.direction === "horizontal") {
                for (var i2 = 0; i2 < offset2.length; i2++) {
                  if (typeof offset2[i2] == "string") {
                    if (offset2[i2].includes("%")) {
                      relativeOffset[i2] = parseInt(offset2[i2].replace("%", "") * _this6.windowWidth / 100);
                    } else {
                      relativeOffset[i2] = parseInt(offset2[i2]);
                    }
                  } else {
                    relativeOffset[i2] = offset2[i2];
                  }
                }
                left = left + relativeOffset[0];
                right = right - relativeOffset[1];
              } else {
                for (var i2 = 0; i2 < offset2.length; i2++) {
                  if (typeof offset2[i2] == "string") {
                    if (offset2[i2].includes("%")) {
                      relativeOffset[i2] = parseInt(offset2[i2].replace("%", "") * _this6.windowHeight / 100);
                    } else {
                      relativeOffset[i2] = parseInt(offset2[i2]);
                    }
                  } else {
                    relativeOffset[i2] = offset2[i2];
                  }
                }
                top = top + relativeOffset[0];
                bottom = bottom - relativeOffset[1];
              }
            }
            var mappedEl = {
              el,
              id: id2,
              "class": cl,
              section,
              top,
              middle,
              bottom,
              left,
              right,
              offset: offset2,
              progress: 0,
              repeat,
              inView: false,
              call,
              speed,
              delay: delay3,
              position,
              target: targetEl,
              direction,
              sticky
            };
            _this6.els[id2] = mappedEl;
            if (el.classList.contains(cl)) {
              _this6.setInView(_this6.els[id2], id2);
            }
            if (speed !== false || sticky) {
              _this6.parallaxElements[id2] = mappedEl;
            }
          });
        }
      }, {
        key: "addSections",
        value: function addSections() {
          var _this7 = this;
          this.sections = {};
          var sections = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
          if (sections.length === 0) {
            sections = [this.el];
          }
          sections.forEach(function(section, index2) {
            var id2 = typeof section.dataset[_this7.name + "Id"] === "string" ? section.dataset[_this7.name + "Id"] : "section" + index2;
            var sectionBCR = section.getBoundingClientRect();
            var offset2 = {
              x: sectionBCR.left - window.innerWidth * 1.5 - getTranslate2(section).x,
              y: sectionBCR.top - window.innerHeight * 1.5 - getTranslate2(section).y
            };
            var limit = {
              x: offset2.x + sectionBCR.width + window.innerWidth * 2,
              y: offset2.y + sectionBCR.height + window.innerHeight * 2
            };
            var persistent = typeof section.dataset[_this7.name + "Persistent"] === "string";
            section.setAttribute("data-scroll-section-id", id2);
            var mappedSection = {
              el: section,
              offset: offset2,
              limit,
              inView: false,
              persistent,
              id: id2
            };
            _this7.sections[id2] = mappedSection;
          });
        }
      }, {
        key: "transform",
        value: function transform3(element, x, y, delay3) {
          var transform4;
          if (!delay3) {
            transform4 = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(x, ",").concat(y, ",0,1)");
          } else {
            var start = getTranslate2(element);
            var lerpX = lerp3(start.x, x, delay3);
            var lerpY = lerp3(start.y, y, delay3);
            transform4 = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(lerpX, ",").concat(lerpY, ",0,1)");
          }
          element.style.webkitTransform = transform4;
          element.style.msTransform = transform4;
          element.style.transform = transform4;
        }
      }, {
        key: "transformElements",
        value: function transformElements(isForced) {
          var _this8 = this;
          var setAllElements = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var scrollRight = this.instance.scroll.x + this.windowWidth;
          var scrollBottom = this.instance.scroll.y + this.windowHeight;
          var scrollMiddle = {
            x: this.instance.scroll.x + this.windowMiddle.x,
            y: this.instance.scroll.y + this.windowMiddle.y
          };
          Object.entries(this.parallaxElements).forEach(function(_ref5) {
            var _ref6 = _slicedToArray3(_ref5, 2), i2 = _ref6[0], current = _ref6[1];
            var transformDistance = false;
            if (isForced) {
              transformDistance = 0;
            }
            if (current.inView || setAllElements) {
              switch (current.position) {
                case "top":
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case "elementTop":
                  transformDistance = (scrollBottom - current.top) * -current.speed;
                  break;
                case "bottom":
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollBottom + _this8.windowHeight) * current.speed;
                  break;
                case "left":
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case "elementLeft":
                  transformDistance = (scrollRight - current.left) * -current.speed;
                  break;
                case "right":
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollRight + _this8.windowHeight) * current.speed;
                  break;
                default:
                  transformDistance = (scrollMiddle[_this8.directionAxis] - current.middle[_this8.directionAxis]) * -current.speed;
                  break;
              }
            }
            if (current.sticky) {
              if (current.inView) {
                if (_this8.direction === "horizontal") {
                  transformDistance = _this8.instance.scroll.x - current.left + window.innerWidth;
                } else {
                  transformDistance = _this8.instance.scroll.y - current.top + window.innerHeight;
                }
              } else {
                if (_this8.direction === "horizontal") {
                  if (_this8.instance.scroll.x < current.left - window.innerWidth && _this8.instance.scroll.x < current.left - window.innerWidth / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.x > current.right && _this8.instance.scroll.x > current.right + 100) {
                    transformDistance = current.right - current.left + window.innerWidth;
                  } else {
                    transformDistance = false;
                  }
                } else {
                  if (_this8.instance.scroll.y < current.top - window.innerHeight && _this8.instance.scroll.y < current.top - window.innerHeight / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.y > current.bottom && _this8.instance.scroll.y > current.bottom + 100) {
                    transformDistance = current.bottom - current.top + window.innerHeight;
                  } else {
                    transformDistance = false;
                  }
                }
              }
            }
            if (transformDistance !== false) {
              if (current.direction === "horizontal" || _this8.direction === "horizontal" && current.direction !== "vertical") {
                _this8.transform(current.el, transformDistance, 0, isForced ? false : current.delay);
              } else {
                _this8.transform(current.el, 0, transformDistance, isForced ? false : current.delay);
              }
            }
          });
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var _this9 = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var offset2 = parseInt(options.offset) || 0;
          var duration = !isNaN(parseInt(options.duration)) ? parseInt(options.duration) : 1e3;
          var easing = options.easing || [0.25, 0, 0.35, 1];
          var disableLerp = options.disableLerp ? true : false;
          var callback = options.callback ? options.callback : false;
          easing = src$1.apply(void 0, _toConsumableArray2(easing));
          if (typeof target === "string") {
            if (target === "top") {
              target = 0;
            } else if (target === "bottom") {
              target = this.instance.limit.y;
            } else if (target === "left") {
              target = 0;
            } else if (target === "right") {
              target = this.instance.limit.x;
            } else {
              target = document.querySelector(target);
              if (!target) {
                return;
              }
            }
          } else if (typeof target === "number") {
            target = parseInt(target);
          } else if (target && target.tagName)
            ;
          else {
            console.warn("`target` parameter is not valid");
            return;
          }
          if (typeof target !== "number") {
            var targetInScope = getParents(target).includes(this.el);
            if (!targetInScope) {
              return;
            }
            var targetBCR = target.getBoundingClientRect();
            var offsetTop = targetBCR.top;
            var offsetLeft = targetBCR.left;
            var targetParents = getParents(target);
            var parentSection = targetParents.find(function(candidate) {
              return Object.entries(_this9.sections).map(function(_ref7) {
                var _ref8 = _slicedToArray3(_ref7, 2), key = _ref8[0], section = _ref8[1];
                return section;
              }).find(function(section) {
                return section.el == candidate;
              });
            });
            var parentSectionOffset = 0;
            if (parentSection) {
              parentSectionOffset = getTranslate2(parentSection)[this.directionAxis];
            } else {
              parentSectionOffset = -this.instance.scroll[this.directionAxis];
            }
            if (this.direction === "horizontal") {
              offset2 = offsetLeft + offset2 - parentSectionOffset;
            } else {
              offset2 = offsetTop + offset2 - parentSectionOffset;
            }
          } else {
            offset2 = target + offset2;
          }
          var scrollStart = parseFloat(this.instance.delta[this.directionAxis]);
          var scrollTarget = Math.max(0, Math.min(offset2, this.instance.limit[this.directionAxis]));
          var scrollDiff = scrollTarget - scrollStart;
          var render4 = function render5(p) {
            if (disableLerp) {
              if (_this9.direction === "horizontal") {
                _this9.setScroll(scrollStart + scrollDiff * p, _this9.instance.delta.y);
              } else {
                _this9.setScroll(_this9.instance.delta.x, scrollStart + scrollDiff * p);
              }
            } else {
              _this9.instance.delta[_this9.directionAxis] = scrollStart + scrollDiff * p;
            }
          };
          this.animatingScroll = true;
          this.stopScrolling();
          this.startScrolling();
          var start = Date.now();
          var loop = function loop2() {
            var p = (Date.now() - start) / duration;
            if (p > 1) {
              render4(1);
              _this9.animatingScroll = false;
              if (duration == 0)
                _this9.update();
              if (callback)
                callback();
            } else {
              _this9.scrollToRaf = requestAnimationFrame(loop2);
              render4(easing(p));
            }
          };
          loop();
        }
      }, {
        key: "update",
        value: function update() {
          this.setScrollLimit();
          this.addSections();
          this.addElements();
          this.detectElements();
          this.updateScroll();
          this.transformElements(true);
          this.reinitScrollBar();
          this.checkScroll(true);
        }
      }, {
        key: "startScroll",
        value: function startScroll() {
          this.stop = false;
        }
      }, {
        key: "stopScroll",
        value: function stopScroll() {
          this.stop = true;
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance = _objectSpread22(_objectSpread22({}, this.instance), {}, {
            scroll: {
              x,
              y
            },
            delta: {
              x,
              y
            },
            speed: 0
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get3(_getPrototypeOf(_default4.prototype), "destroy", this).call(this);
          this.stopScrolling();
          this.html.classList.remove(this.smoothClass);
          this.vs.destroy();
          this.destroyScrollBar();
          window.removeEventListener("keydown", this.checkKey, false);
        }
      }]);
      return _default4;
    }(_default3);
    var Smooth = /* @__PURE__ */ function() {
      function Smooth2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck3(this, Smooth2);
        this.options = options;
        Object.assign(this, defaults2, options);
        this.smartphone = defaults2.smartphone;
        if (options.smartphone)
          Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults2.tablet;
        if (options.tablet)
          Object.assign(this.tablet, options.tablet);
        if (!this.smooth && this.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible");
        if (!this.tablet.smooth && this.tablet.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible (tablet)");
        if (!this.smartphone.smooth && this.smartphone.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible (smartphone)");
        this.init();
      }
      _createClass3(Smooth2, [{
        key: "init",
        value: function init6() {
          this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint;
          this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint;
          if (this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet) {
            this.scroll = new _default$2(this.options);
          } else {
            this.scroll = new _default$12(this.options);
          }
          this.scroll.init();
          if (window.location.hash) {
            var id2 = window.location.hash.slice(1, window.location.hash.length);
            var target = document.getElementById(id2);
            if (target)
              this.scroll.scrollTo(target);
          }
        }
      }, {
        key: "update",
        value: function update() {
          this.scroll.update();
        }
      }, {
        key: "start",
        value: function start() {
          this.scroll.startScroll();
        }
      }, {
        key: "stop",
        value: function stop() {
          this.scroll.stopScroll();
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target, options) {
          this.scroll.scrollTo(target, options);
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.scroll.setScroll(x, y);
        }
      }, {
        key: "on",
        value: function on2(event2, func) {
          this.scroll.setEvents(event2, func);
        }
      }, {
        key: "off",
        value: function off2(event2, func) {
          this.scroll.unsetEvents(event2, func);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.scroll.destroy();
        }
      }]);
      return Smooth2;
    }();
    var locomotive_scroll_esm_default = Smooth;
  
    // assets/scripts/modules/Scroll.js
    var Scroll_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.currentTemplate = html.getAttribute("data-template");
      }
      init() {
        this.initScroll();
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.scroll.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onFontsLoaded() {
        this.update();
      }
      onResize() {
        this.update();
      }
      initScroll() {
        this.scroll = new locomotive_scroll_esm_default({
          el: this.el,
          offset: [0, 0],
          smooth: true,
          tablet: {
            breakpoint: 1080
          }
        });
        this.scroll.on("call", (func, way, obj, id2) => {
          this.call(func[0], { way, obj }, func[1], func[2]);
        });
        this.scroll.on("scroll", (args) => {
          if (this.currentTemplate === "home") {
            if (args.scroll.y > window.innerHeight) {
              html.classList.add("has-scrolled");
            } else {
              html.classList.remove("has-scrolled");
            }
          } else if (args.scroll.y > 80) {
            html.classList.add("has-scrolled");
          } else {
            html.classList.remove("has-scrolled");
          }
          if (typeof args.currentElements["experience"] === "object" && !this.scroll.options.isMobile && !this.scroll.options.isTablet) {
            let progress = args.currentElements["experience"].progress;
            this.call("onProgress", progress, "Experiences");
          }
          if (typeof args.currentElements["pushVideo"] === "object") {
            let progress = args.currentElements["pushVideo"].progress;
            this.call("onProgress", progress, "PushVideo");
          }
          if (typeof args.currentElements["scrollQuote"] === "object") {
            let progress = args.currentElements["scrollQuote"].progress;
            this.call("onProgress", progress, "ScrollQuote");
          }
          if (typeof args.currentElements["footer"] === "object" && !this.scroll.options.isMobile && !this.scroll.options.isTablet) {
            let progress = args.currentElements["footer"].progress;
            this.call("onProgress", progress, "FooterReveal");
          }
        });
        this.isSmooth();
      }
      lazyLoad(args) {
        lazyLoadImage(args.obj.el, null, () => {
        });
      }
      toggleExperiences(args) {
        let $target;
        if (args.obj.target) {
          $target = args.obj.target;
        } else if (args.obj.targetEl) {
          $target = args.obj.targetEl;
        } else {
          return;
        }
        const moduleID = $target.dataset.moduleExperiences;
        if (args.way === "enter") {
          this.call("play", null, "Experiences", moduleID);
        } else if (args.way === "exit") {
          this.call("pause", null, "Experiences", moduleID);
        }
      }
      togglePushVideo(args) {
        let $target;
        if (args.obj.target) {
          $target = args.obj.target;
        } else if (args.obj.targetEl) {
          $target = args.obj.targetEl;
        } else {
          return;
        }
        const moduleID = $target.dataset.modulePushVideo;
        if (args.way === "enter") {
          this.call("onEnter", null, "PushVideo", moduleID);
        } else if (args.way === "exit") {
          this.call("onLeave", null, "PushVideo", moduleID);
        }
      }
      toggleTrombinoscope(args) {
        let $target;
        if (args.obj.target) {
          $target = args.obj.target;
        } else if (args.obj.targetEl) {
          $target = args.obj.targetEl;
        } else {
          return;
        }
        const moduleID = $target.dataset.moduleTrombinoscope;
        if (args.way === "enter") {
          this.call("play", null, "Trombinoscope", moduleID);
        } else if (args.way === "exit") {
          this.call("pause", null, "Trombinoscope", moduleID);
        }
      }
      toggleCarouselQuote(args) {
        let $target;
        if (args.obj.target) {
          $target = args.obj.target;
        } else if (args.obj.targetEl) {
          $target = args.obj.targetEl;
        } else {
          return;
        }
        const moduleID = $target.dataset.moduleCarouselQuote;
        if (args.way === "enter") {
          this.call("onEnterInView", null, "CarouselQuote", moduleID);
        } else if (args.way === "exit") {
          this.call("onExitInView", null, "CarouselQuote", moduleID);
        }
      }
      toggleLightTheme(args) {
        let $target;
        if (args.obj.target) {
          $target = args.obj.target;
        } else if (args.obj.targetEl) {
          $target = args.obj.targetEl;
        } else {
          return;
        }
        const moduleID = $target.dataset.moduleLightTheme;
        if (args.way === "enter") {
          this.call("onEnterInView", null, "LightTheme", moduleID);
        } else if (args.way === "exit") {
          this.call("onExitInView", null, "LightTheme", moduleID);
        }
      }
      isSmooth() {
        if (this.scroll.options.isMobile || this.scroll.options.isTablet) {
          window.isSmooth = false;
        } else {
          window.isSmooth = true;
        }
      }
      start() {
        var _a, _b;
        (_b = (_a = this.scroll) == null ? void 0 : _a.start) == null ? void 0 : _b.call(_a);
      }
      stop() {
        var _a, _b;
        (_b = (_a = this.scroll) == null ? void 0 : _a.stop) == null ? void 0 : _b.call(_a);
      }
      update() {
        var _a, _b;
        (_b = (_a = this.scroll) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      }
      scrollTo(params) {
        var _a, _b;
        (_b = (_a = this.scroll) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, params.target, params.options);
      }
    };
  
    // assets/scripts/modules/ScrollQuote.js
    var CLASS = {
      ACTIVE: "is-active",
      WORD: "c-scroll-quote_word"
    };
    var ScrollQuote_default = class extends _default {
      constructor(m) {
        super(m);
        this.$el = this.el;
        this.$text = this.$("text")[0];
      }
      init() {
        this.split();
      }
      destroy() {
        super.destroy();
      }
      onProgress(scrollProgress) {
        const progress = Math.round((this.computeProgressData(scrollProgress) + Number.EPSILON) * 10) / 10;
        this.computeActiveWord(progress);
      }
      computeProgressData(scrollProgress) {
        return clamp3(map(scrollProgress, 0, 1, 0, this.$words.length + 1), 0, this.$words.length + 1);
      }
      split() {
        const regex = /(^|<\/?[^>]+>|\s+)([^\s<]+)/g;
        this.$text.innerHTML = this.$text.innerHTML.replace(regex, '$1<span class="' + CLASS.WORD + '">$2</span>');
        this.$words = this.$text.querySelectorAll("." + CLASS.WORD);
      }
      computeActiveWord(progress) {
        for (let i2 = 0; i2 < this.$words.length; i2++) {
          if (progress > i2 + 1 && !this.$words[i2].classList.contains(CLASS.ACTIVE)) {
            this.$words[i2].classList.add(CLASS.ACTIVE);
          } else if (progress <= i2 + 1 && this.$words[i2].classList.contains(CLASS.ACTIVE)) {
            this.$words[i2].classList.remove(CLASS.ACTIVE);
          }
        }
      }
    };
  
    // assets/scripts/modules/ScrollTo.js
    var ScrollTo_default = class extends _default {
      constructor(m) {
        super(m);
        this.$el = this.el;
      }
      init() {
        this.bindEvents();
      }
      bindEvents() {
        this.onClickBind = this.onClick.bind(this);
        this.el.addEventListener("click", this.onClickBind);
      }
      unbindEvents() {
        this.el.removeEventListener("click", this.onClickBind);
      }
      onClick(event2) {
        event2.preventDefault();
        const target = this.el.getAttribute("href");
        const offset2 = this.getData("offset") || -40;
        const next2 = this.getData("next");
        if (!target) {
          const $target2 = queryClosestParent(this.$el, next2);
          if ($target2) {
            const height = $target2.getBoundingClientRect().bottom;
            this.call("scrollTo", { target: height, offset: 0 }, "Scroll");
            return;
          }
        }
        const $targetAll = document.querySelectorAll(target);
        const $target = $targetAll[0];
        if (!$target)
          return;
        this.call("scrollTo", { target: $target, offset: offset2 }, "Scroll");
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
    };
  
    // assets/scripts/modules/SplitText.js
    gsapWithCSS2.registerPlugin(SplitText);
    var CLASS2 = "u-anim-text";
    var AnimText = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.$el = this.el;
        this.isHidden = true;
        this.splitType = "lines";
      }
      init() {
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
      }
      onResize() {
        this.initSplits();
      }
      onFontsLoaded() {
        this.initSplits();
      }
      initSplits() {
        if (this.split)
          this.revertSplits();
        requestAnimationFrame(() => {
          this.split = new SplitText(this.$el, {
            type: this.splitType,
            linesClass: `${CLASS2}_line`,
            wordsClass: `${CLASS2}_word`,
            charsClass: `${CLASS2}_char`
          });
          const totalLines = this.split.lines.length;
          this.$el.style.setProperty("--anim-text-total-lines", totalLines);
          this.split.lines.forEach(($line, i2) => {
            $line.style.setProperty("--anim-text-line-index", i2);
          });
          const totalChars = this.split.chars.length;
          if (totalChars > 0) {
            this.$el.style.setProperty("--anim-text-total-chars", totalChars);
            this.split.chars.forEach(($char, i2) => {
              $char.style.setProperty("--anim-text-char-index", i2);
            });
          }
        });
      }
      revertSplits() {
        this.split.revert();
      }
    };
  
    // assets/scripts/utils/transform.js
    function transform2(el, transformValue) {
      el.style.webkitTransform = transformValue;
      el.style.msTransform = transformValue;
      el.style.transform = transformValue;
    }
  
    // assets/scripts/modules/TileMouse.js
    var isMobileObj3 = isMobile();
    var IS_TOUCH_DEVICE3 = (isMobileObj3 == null ? void 0 : isMobileObj3.phone) || (isMobileObj3 == null ? void 0 : isMobileObj3.tablet);
    var TileMouse_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.onMouseMoveBind = this.onMouseMove.bind(this);
        this.$el = this.el;
        this.$follow = this.$("follow")[0];
      }
      init() {
        if (IS_TOUCH_DEVICE3)
          return;
        this.mouse = {
          x: 0,
          y: 0,
          lerpedX: 0,
          lerpedY: 0
        };
        this.lerp = 0.12;
        this.hasMoved = false;
        this.bcr = this.el.getBoundingClientRect();
        this.isAvailable = false;
        this.isHover = false;
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
        gsapWithCSS2.delayedCall(1, () => {
          this.resize();
          this.mouse.x = this.bcr.width - this.$follow.offsetWidth / 2;
          this.mouse.y = this.bcr.height - this.$follow.offsetHeight / 2;
          this.mouse.lerpedX = this.bcr.width - this.$follow.offsetWidth / 2;
          this.mouse.lerpedY = this.bcr.height - this.$follow.offsetHeight / 2;
          transform2(this.$follow, `translate3d(${this.bcr.width / 2}px,${this.bcr.height / 2}px,0) translate3d(-50%, -50%, 0)`);
        });
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
        this.raf && cancelAnimationFrame(this.raf);
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
        this.$el.addEventListener("mouseenter", this.onMouseEnterBind);
        this.$el.addEventListener("mouseleave", this.onMouseLeaveBind);
        this.$el.addEventListener("mousemove", this.onMouseMoveBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
        this.$el.removeEventListener("mouseenter", this.onMouseEnterBind);
        this.$el.removeEventListener("mouseleave", this.onMouseLeaveBind);
        this.$el.removeEventListener("mousemove", this.onMouseMoveBind);
      }
      onResize() {
        this.resize();
      }
      onFontsLoaded() {
        this.resize();
      }
      onMouseEnter(e) {
        if (IS_TOUCH_DEVICE3)
          return;
        this.raf && cancelAnimationFrame(this.raf);
        this.isHover = true;
        if (!this.hasMoved) {
          this.hasMoved = true;
          this.el.classList.add("has-moved");
        }
        if (this.isHover) {
          this.mouse.x = e.clientX - this.bcr.left;
          this.mouse.y = e.clientY - this.bcr.top;
        }
        this.resize();
        this.isAvailable = true;
        this.animate();
        this.lerp = 0;
        requestAnimationFrame(() => {
          this.lerp = 0.12;
          this.el.classList.add("is-hovered");
        });
      }
      onMouseLeave() {
        if (IS_TOUCH_DEVICE3)
          return;
        this.isHover = false;
        this.mouse.x = this.bcr.width - this.$follow.offsetWidth / 2;
        this.mouse.y = this.bcr.height - this.$follow.offsetHeight / 2;
        if (this.enterCallback !== void 0) {
          this.enterCallback.kill();
        }
        this.isAvailable = false;
        cancelAnimationFrame(this.raf);
        this.el.classList.remove("is-hovered");
      }
      onMouseMove(e) {
        if (this.isHover) {
          this.mouse.x = e.clientX - this.bcr.left;
          this.mouse.y = e.clientY - this.bcr.top;
        }
        this.resize();
      }
      resize() {
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;
        this.bcr = this.el.getBoundingClientRect();
      }
      animate() {
        this.raf = requestAnimationFrame(() => this.animate());
        if (this.isAvailable) {
          this.mouse.lerpedX = lerp(this.mouse.lerpedX, this.mouse.x, this.lerp);
          this.mouse.lerpedY = lerp(this.mouse.lerpedY, this.mouse.y, this.lerp);
          transform2(this.$follow, `translate3d(${this.mouse.lerpedX}px,${this.mouse.lerpedY}px,0) translate3d(-50%, -50%, 0)`);
        }
      }
    };
  
    // assets/scripts/modules/Trombinoscope.js
    var MAX_SLOT_COUNT = 7;
    var MAIN_CHARACTERS_COUNT = 2;
    var DEBUG_DATA = false;
    var SHAPES = ["-circle", "-square", "-portal"];
    var Trombinoscope_default = class extends _default {
      constructor(m) {
        super(m);
        this.onUpdateBind = this.onUpdate.bind(this);
        this.onClickBind = this.onClick.bind(this);
        this.$el = this.el;
        this.$slots = this.$("slot");
        this.$tiles = this.$("tile");
        this.$buttons = this.$("button");
        const data = this.getData("data");
        if (!data)
          return;
        this.formatedData = JSON.parse(data);
        this.charactersData = this.formatedData.filter((data2) => !data2.main);
        this.mainCharactersData = this.formatedData.filter((data2) => data2.main);
        this.countMain = this.mainCharactersData.length > MAIN_CHARACTERS_COUNT ? MAIN_CHARACTERS_COUNT : this.mainCharactersData.length;
        this.count = MAX_SLOT_COUNT - this.countMain;
        this.data = [];
        this.events = {
          click: {
            refresh: "onRefresh"
          }
        };
        this.shapesData = {
          isStarted: false,
          lastTileIndex: 0,
          baseTime: Date.now(),
          maxInterval: 1e3,
          maxDuration: 50,
          interval: 0
        };
        this.isRafPlaying = false;
      }
      init() {
        this.bindEvents();
        this.initShapes();
        if (!this.formatedData)
          return;
        this.initFirstData();
        this.loadData().then(() => {
          this.populate();
          requestAnimationFrame(() => {
            this.show();
          });
        });
        this.play();
      }
      destroy() {
        super.destroy();
        this.unbindEvents();
      }
      bindEvents() {
        for (let index2 = 0; index2 < this.$buttons.length; index2++) {
          const $button = this.$buttons[index2];
          $button.addEventListener("click", this.onClickBind);
        }
      }
      unbindEvents() {
        for (let index2 = 0; index2 < this.$buttons.length; index2++) {
          const $button = this.$buttons[index2];
          $button.removeEventListener("click", this.onClickBind);
        }
      }
      onClick(e) {
        const $buttons = [...this.$buttons];
        const index2 = $buttons.indexOf(e.target);
        this.call("open", this.data[index2], "TrombinoscopeModal");
      }
      onRefresh() {
        let isImagesHidden = false;
        let isNewDataLoaded = false;
        const refresh = () => {
          this.populate();
          requestAnimationFrame(() => {
            this.show();
          });
        };
        this.hide(() => {
          isImagesHidden = true;
          if (isImagesHidden && isNewDataLoaded) {
            refresh();
          }
        });
        this.refreshData();
        this.loadData().then(() => {
          isNewDataLoaded = true;
          if (isImagesHidden && isNewDataLoaded) {
            refresh();
          }
        });
      }
      play() {
        if (this.isRafPlaying)
          return;
        this.isRafPlaying = true;
        gsapWithCSS2.ticker.add(this.onUpdateBind);
      }
      pause() {
        if (!this.isRafPlaying)
          return;
        this.isRafPlaying = false;
        gsapWithCSS2.ticker.remove(this.onUpdateBind);
      }
      onUpdate(time, deltaTime, frame) {
        this.updateShapes();
      }
      initFirstData() {
        const shuffleData = shuffle(this.charactersData);
        this.dataLog("INIT: shuffle other", shuffleData);
        const shuffleMainCharData = shuffle(this.mainCharactersData);
        this.dataLog("INIT: shuffle main", shuffleMainCharData);
        const selectedData = [...shuffleData].slice(0, this.count);
        this.selectedData = [...selectedData];
        this.dataLog("INIT: selected other", selectedData);
        const selectedMainCharData = [...shuffleMainCharData].slice(0, this.countMain);
        this.selectedMainCharData = [...selectedMainCharData];
        this.dataLog("INIT: selected main", selectedMainCharData);
        do {
          this.data.push(...selectedData);
        } while (this.data.length < this.count);
        this.data = this.data.slice(0, this.count);
        do {
          this.data.push(...selectedMainCharData);
        } while (this.data.length < this.countMain);
        const data = this.data.slice(0, this.count + this.countMain);
        this.data = shuffle([...shuffle([...data])]);
        if (DEBUG_DATA) {
          const debugData = [...this.data];
          this.dataLog("INIT: data", debugData);
        }
      }
      refreshData() {
        this.data = [];
        const priorityData = this.charactersData.filter(({ name: name1 }) => !this.selectedData.some(({ name: name2 }) => name2 === name1));
        this.dataLog("REFRESH: priority other", priorityData);
        const priorityMainCharData = this.mainCharactersData.filter(({ name: name1 }) => !this.selectedMainCharData.some(({ name: name2 }) => name2 === name1));
        this.dataLog("REFRESH: priority main", priorityMainCharData);
        const shuffleData = shuffle([...this.selectedData]);
        this.dataLog("REFRESH: suffle", shuffleData);
        const shuffleMainCharData = shuffle([...this.selectedMainCharData]);
        this.dataLog("REFRESH: suffle", shuffleMainCharData);
        shuffleData.unshift(...shuffle([...priorityData]));
        this.dataLog("REFRESH: add prioriy", shuffleData);
        shuffleMainCharData.unshift(...shuffle([...priorityMainCharData]));
        this.dataLog("REFRESH: add prioriy", shuffleMainCharData);
        const selectedData = [...shuffleData].slice(0, this.count);
        this.selectedData = [...selectedData];
        this.dataLog("REFRESH: selected", selectedData);
        const selectedMainCharData = [...shuffleMainCharData].slice(0, this.countMain);
        this.selectedMainCharData = [...selectedMainCharData];
        this.dataLog("REFRESH: selected main", selectedMainCharData);
        do {
          this.data.push(...this.selectedData);
        } while (this.data.length < this.count);
        this.data = this.data.slice(0, this.count);
        do {
          this.data.push(...selectedMainCharData);
        } while (this.data.length < this.countMain);
        const data = this.data.slice(0, this.count + this.countMain);
        this.data = shuffle([...shuffle([...data])]);
        if (DEBUG_DATA) {
          const debugData = [...this.data];
          this.dataLog("REFRESH: data", debugData);
        }
      }
      loadData() {
        const promises = [];
        let index2 = 0;
        while (index2 < this.data.length) {
          const dataObj = this.data[index2];
          if (dataObj == null ? void 0 : dataObj.thumbnail) {
            const promise = loadImage2(dataObj.thumbnail).then((imageObj) => {
              dataObj.loadedImage = imageObj;
            });
            promises.push(promise);
          } else {
            dataObj.loadedImage = null;
          }
          index2++;
        }
        return Promise.all([...promises]);
      }
      populate() {
        var _a;
        const template = (src2 = "", caption = "") => `
              <figure class="c-figure">
                  <div class="c-figure_inner">
                      <img
                          class="c-figure_image || js-image"
                          style="opacity: 0; visibility: hidden; transform: scale(1.1)"
                          src="${src2}"
                          alt="${caption}"
                      >
                  </div>
                  <figcaption class="u-screen-reader-text">${caption}</figcaption>
              </figure>
          `;
        let slotIndex = 0;
        while (slotIndex < this.data.length) {
          const $slot = this.$slots[slotIndex];
          const data = this.data[slotIndex];
          if ($slot && ((_a = data == null ? void 0 : data.loadedImage) == null ? void 0 : _a.url)) {
            $slot.innerHTML = template(data.loadedImage.url, data == null ? void 0 : data.name);
          } else if ($slot) {
            $slot.innerHTML = "";
          }
          slotIndex++;
        }
      }
      initShapes() {
        let tileIndex = 0;
        while (tileIndex < this.$tiles.length) {
          const $tile = this.$tiles[tileIndex];
          const shapeClass = random(SHAPES);
          $tile.classList.add(shapeClass);
          tileIndex++;
        }
      }
      updateShapes() {
        if (!this.shapesData.isStarted) {
          this.shapesData.baseTime = Date.now();
          this.shapesData.isStarted = true;
          this.shapesData.interval = random(0, this.shapesData.maxInterval, 1);
        }
        const intervalDuration = this.shapesData.interval;
        const intervalDateNow = Date.now();
        const intervalElapsed = intervalDateNow - this.shapesData.baseTime;
        const intervalProgress = Math.min(intervalElapsed / intervalDuration, 1);
        if (intervalProgress >= 1) {
          this.shapesData.baseTime = Date.now();
          this.shapesData.interval = random(0, this.shapesData.maxInterval, 1);
          this.updateRandomShape();
        }
      }
      updateRandomShape() {
        let randomTileIndex = 0;
        do {
          randomTileIndex = Math.abs(random(0, this.$tiles.length - 1, 1));
        } while (randomTileIndex === this.shapesData.lastTileIndex);
        this.shapesData.lastTileIndex = randomTileIndex;
        const $randomTile = this.$tiles[randomTileIndex];
        const randomShapeIndex = Math.abs(random(0, SHAPES.length - 1, 1));
        const randomShape = SHAPES[randomShapeIndex];
        if (!$randomTile)
          return;
        let shapeClassIndex = 0;
        while (shapeClassIndex < SHAPES.length) {
          const shapeClass = SHAPES[shapeClassIndex];
          $randomTile.classList.remove(shapeClass);
          shapeClassIndex++;
        }
        $randomTile.classList.add(randomShape);
      }
      hide(onComplete = () => {
      }) {
        const $images = this.$el.querySelectorAll(".js-image");
        gsapWithCSS2.to($images, {
          autoAlpha: 0,
          duration: 0.3,
          ease: "power2.out",
          onComplete
        });
      }
      show() {
        const $images = this.$el.querySelectorAll(".js-image");
        gsapWithCSS2.to($images, {
          autoAlpha: 1,
          scale: 1,
          duration: 1,
          ease: "power2.out",
          stagger: 0.1
        });
      }
      dataLog(name, message) {
        if (DEBUG_DATA) {
          console.log(name, message);
        }
      }
    };
  
    // assets/scripts/modules/TrombinoscopeModal.js
    gsapWithCSS2.registerPlugin(SplitText);
    var CLASS3 = "u-anim-text";
    var TrombinoscopeModal_default = class extends AbstractModal_default {
      constructor(m) {
        super(m);
        __publicField(this, "activeClass", "has-trombinoscope-open");
        this.onResizeSplitBind = this.onResizeSplit.bind(this);
        this.onUpdateLoadingBind = this.onUpdateLoading.bind(this);
        this.$anim = this.$("anim")[0];
        this.$quote = this.$("quote")[0];
        this.$firstname = this.$("firstname")[0];
        this.$lastname = this.$("lastname")[0];
        this.$job = this.$("job")[0];
        this.$visual = this.$("visual")[0];
        this.loadingData = {
          elapsedTime: 0,
          loadingDuration: 600,
          isLoading: false,
          isReady: false
        };
        this.isHidden = true;
        this.splitType = "lines";
      }
      bindEvents() {
      }
      unbindEvents() {
      }
      bindSplitEvents() {
        window.addEventListener("resizeEnd", this.onResizeSplitBind);
      }
      unbindSplitEvents() {
        window.removeEventListener("resizeEnd", this.onResizeSplitBind);
      }
      onInit() {
      }
      onDestroy() {
      }
      onClose() {
        this.killLoading();
        this.hide();
      }
      onOpen(args) {
        this.loadData(args);
      }
      onUpdateLoading(time, deltaTime, frame) {
        this.loadingData.elapsedTime += deltaTime;
        if (this.loadingData.elapsedTime > this.loadingData.loadingDuration && this.loadingData.isReady) {
          this.stopLoading();
          this.onLoaded();
        }
      }
      onLoaded() {
        this.show();
      }
      onResizeSplit() {
        this.initSplits();
      }
      loadData(args) {
        this.playLoading();
        if (args == null ? void 0 : args.image) {
          loadImage2(args.image).then((imageObj) => {
            this.populate(args, imageObj);
          });
        } else {
          this.populate(args, null);
        }
      }
      populate(data, loadedImage) {
        if (loadedImage) {
          const imageTemplate = (src2 = "", caption = "") => `
                  <figure class="c-trombinoscope-modal_image || c-figure">
                      <div class="c-figure_inner">
                          <img
                              class="c-figure_image || js-image"
                              src="${src2}"
                              alt="${caption}"
                          >
                      </div>
                      <figcaption class="u-screen-reader-text">${caption}</figcaption>
                  </figure>
              `;
          if (loadedImage == null ? void 0 : loadedImage.url) {
            this.$visual.innerHTML = imageTemplate(loadedImage.url, data == null ? void 0 : data.name);
          } else {
            this.$visual.innerHTML = "";
          }
        } else {
          this.$visual.innerHTML = "";
        }
        if (data.quote) {
          this.$quote.innerHTML = `${data.quote}`;
        } else {
          this.$quote.innerHTML = "";
        }
        if (data.firstName) {
          this.$firstname.innerHTML = data.firstName;
        } else {
          this.$firstname.innerHTML = "";
        }
        if (data.lastName) {
          this.$lastname.innerHTML = data.lastName;
        } else {
          this.$lastname.innerHTML = "";
        }
        if (data.occupation) {
          this.$job.innerHTML = data.occupation;
        } else {
          this.$job.innerHTML = "";
        }
        requestAnimationFrame(() => {
          this.loadingData.isReady = true;
        });
      }
      playLoading() {
        if (this.loadingData.isLoading)
          return;
        this.loadingData.elapsedTime = 0;
        this.loadingData.isLoading = true;
        gsapWithCSS2.ticker.add(this.onUpdateLoadingBind);
        this.el.classList.add("is-loading");
      }
      stopLoading() {
        if (!this.loadingData.isLoading)
          return;
        this.loadingData.isLoading = false;
        gsapWithCSS2.ticker.remove(this.onUpdateLoadingBind);
        this.el.classList.remove("is-loading");
      }
      killLoading() {
        this.stopLoading();
        this.loadingData.isReady = false;
      }
      show() {
        this.split = "";
        requestAnimationFrame(() => {
          this.initSplits();
          this.bindSplitEvents();
          this.el.classList.add("is-show");
          gsapWithCSS2.delayedCall(0.6, () => {
            this.$anim.classList.add("is-active");
          });
        });
      }
      hide() {
        this.el.classList.remove("is-show");
        this.$anim.classList.remove("is-active");
        gsapWithCSS2.delayedCall(0.6, () => {
          this.unbindSplitEvents();
        });
      }
      initSplits() {
        this.split = new SplitText(this.$quote, {
          type: this.splitType,
          linesClass: `${CLASS3}_line`,
          wordsClass: `${CLASS3}_word`,
          charsClass: `${CLASS3}_char`
        });
        const totalLines = this.split.lines.length;
        this.$quote.style.setProperty("--anim-text-total-lines", totalLines);
        this.split.lines.forEach(($line, i2) => {
          $line.style.setProperty("--anim-text-line-index", i2);
        });
        const totalChars = this.split.chars.length;
        if (totalChars > 0) {
          this.$quote.style.setProperty("--anim-text-total-chars", totalChars);
          this.split.chars.forEach(($char, i2) => {
            $char.style.setProperty("--anim-text-char-index", i2);
          });
        }
      }
    };
  
    // assets/scripts/modules/VideoModal.js
    var VideoModal_default = class extends AbstractModal_default {
      constructor(m) {
        super(m);
        __publicField(this, "activeClass", "has-video-open");
        this.inner = this.$("inner")[0];
      }
      bindEvents() {
      }
      unbindEvents() {
      }
      onInit() {
      }
      onDestroy() {
      }
      onClose() {
        this.closeVideo();
      }
      onOpen(args) {
        this.openVideo(args);
      }
      openVideo(args) {
        if (this.emptyTimeout)
          clearTimeout(this.emptyTimeout);
        this.appendDelay = setTimeout(() => {
          switch (args.host) {
            case "youtube":
              this.inner.innerHTML = `<iframe src="https://www.youtube.com/embed/${args.id}?&autoplay=1" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
              break;
            case "vimeo":
              this.inner.innerHTML = `<iframe src="https://player.vimeo.com/video/${args.id}?autoplay=1&loop=1&autopause=0" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
              break;
            case "mp4":
              this.inner.innerHTML = `<video src="${args.id}" autoplay controls></video>`;
              break;
            default:
              break;
          }
        }, 500);
        this.el.classList.add("is-active");
      }
      closeVideo() {
        clearTimeout(this.appendDelay);
        this.el.classList.remove("is-active");
        this.emptyTimeout = setTimeout(() => {
          this.inner.innerHTML = "";
        }, 250);
      }
    };
  
    // assets/scripts/modules/VideoThumb.js
    var VideoThumb_default = class extends _default {
      constructor(m) {
        super(m);
        this.events = {
          click: "openPlayer"
        };
      }
      openPlayer(e) {
        const el = e.curTarget;
        const id2 = this.getData("id", el);
        const host = this.getData("host", el);
        this.call("open", { host, id: id2 }, "VideoModal");
      }
    };
  
    // assets/scripts/modules/Wysiwyg.js
    var Wysiwyg_default = class extends _default {
      constructor(m) {
        super(m);
        this.$el = this.el;
      }
      init() {
        this.removeMarginOfFirstItem();
      }
      destroy() {
        super.destroy();
      }
      removeMarginOfFirstItem() {
        const $wysiwygContainer = this.$("content")[0];
        if ($wysiwygContainer) {
          if ($wysiwygContainer.children.length) {
            const $firstElement = $wysiwygContainer.children[0];
            $firstElement.classList.add("c-wysiwyg-first-element");
            this.call("update", null, "Scroll");
          }
        }
      }
    };
  
    // assets/scripts/modules/AbstractPlayground.js
    var import_tweakpane = __toModule(require_tweakpane());
  
    // node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js
    var LuminosityHighPassShader = {
      shaderID: "luminosityHighPass",
      uniforms: {
        "tDiffuse": { value: null },
        "luminosityThreshold": { value: 1 },
        "smoothWidth": { value: 1 },
        "defaultColor": { value: new Color(0) },
        "defaultOpacity": { value: 0 }
      },
      vertexShader: `
  
          varying vec2 vUv;
  
          void main() {
  
              vUv = uv;
  
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
          }`,
      fragmentShader: `
  
          uniform sampler2D tDiffuse;
          uniform vec3 defaultColor;
          uniform float defaultOpacity;
          uniform float luminosityThreshold;
          uniform float smoothWidth;
  
          varying vec2 vUv;
  
          void main() {
  
              vec4 texel = texture2D( tDiffuse, vUv );
  
              vec3 luma = vec3( 0.299, 0.587, 0.114 );
  
              float v = dot( texel.xyz, luma );
  
              vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
  
              float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
  
              gl_FragColor = mix( outputColor, texel, alpha );
  
          }`
    };
  
    // node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js
    var UnrealBloomPass = class extends Pass {
      constructor(resolution, strength, radius, threshold) {
        super();
        this.strength = strength !== void 0 ? strength : 1;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
        this.clearColor = new Color(0, 0, 0);
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
        this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.renderTargetBright.texture.generateMipmaps = false;
        for (let i2 = 0; i2 < this.nMips; i2++) {
          const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
          renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i2;
          renderTargetHorizonal.texture.generateMipmaps = false;
          this.renderTargetsHorizontal.push(renderTargetHorizonal);
          const renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
          renderTargetVertical.texture.name = "UnrealBloomPass.v" + i2;
          renderTargetVertical.texture.generateMipmaps = false;
          this.renderTargetsVertical.push(renderTargetVertical);
          resx = Math.round(resx / 2);
          resy = Math.round(resy / 2);
        }
        if (LuminosityHighPassShader === void 0)
          console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
        const highPassShader = LuminosityHighPassShader;
        this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
        this.highPassUniforms["luminosityThreshold"].value = threshold;
        this.highPassUniforms["smoothWidth"].value = 0.01;
        this.materialHighPassFilter = new ShaderMaterial({
          uniforms: this.highPassUniforms,
          vertexShader: highPassShader.vertexShader,
          fragmentShader: highPassShader.fragmentShader,
          defines: {}
        });
        this.separableBlurMaterials = [];
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i2 = 0; i2 < this.nMips; i2++) {
          this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i2]));
          this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
          resx = Math.round(resx / 2);
          resy = Math.round(resy / 2);
        }
        this.compositeMaterial = this.getCompositeMaterial(this.nMips);
        this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
        this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
        this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
        this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
        this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
        this.compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.compositeMaterial.needsUpdate = true;
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
        this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
        this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
        if (CopyShader === void 0) {
          console.error("THREE.UnrealBloomPass relies on CopyShader");
        }
        const copyShader = CopyShader;
        this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
        this.copyUniforms["opacity"].value = 1;
        this.materialCopy = new ShaderMaterial({
          uniforms: this.copyUniforms,
          vertexShader: copyShader.vertexShader,
          fragmentShader: copyShader.fragmentShader,
          blending: AdditiveBlending,
          depthTest: false,
          depthWrite: false,
          transparent: true
        });
        this.enabled = true;
        this.needsSwap = false;
        this._oldClearColor = new Color();
        this.oldClearAlpha = 1;
        this.basic = new MeshBasicMaterial();
        this.fsQuad = new FullScreenQuad(null);
      }
      dispose() {
        for (let i2 = 0; i2 < this.renderTargetsHorizontal.length; i2++) {
          this.renderTargetsHorizontal[i2].dispose();
        }
        for (let i2 = 0; i2 < this.renderTargetsVertical.length; i2++) {
          this.renderTargetsVertical[i2].dispose();
        }
        this.renderTargetBright.dispose();
      }
      setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.renderTargetBright.setSize(resx, resy);
        for (let i2 = 0; i2 < this.nMips; i2++) {
          this.renderTargetsHorizontal[i2].setSize(resx, resy);
          this.renderTargetsVertical[i2].setSize(resx, resy);
          this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
          resx = Math.round(resx / 2);
          resy = Math.round(resy / 2);
        }
      }
      render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        renderer.getClearColor(this._oldClearColor);
        this.oldClearAlpha = renderer.getClearAlpha();
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setClearColor(this.clearColor, 0);
        if (maskActive)
          renderer.state.buffers.stencil.setTest(false);
        if (this.renderToScreen) {
          this.fsQuad.material = this.basic;
          this.basic.map = readBuffer.texture;
          renderer.setRenderTarget(null);
          renderer.clear();
          this.fsQuad.render(renderer);
        }
        this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.fsQuad.material = this.materialHighPassFilter;
        renderer.setRenderTarget(this.renderTargetBright);
        renderer.clear();
        this.fsQuad.render(renderer);
        let inputRenderTarget = this.renderTargetBright;
        for (let i2 = 0; i2 < this.nMips; i2++) {
          this.fsQuad.material = this.separableBlurMaterials[i2];
          this.separableBlurMaterials[i2].uniforms["colorTexture"].value = inputRenderTarget.texture;
          this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
          renderer.setRenderTarget(this.renderTargetsHorizontal[i2]);
          renderer.clear();
          this.fsQuad.render(renderer);
          this.separableBlurMaterials[i2].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i2].texture;
          this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
          renderer.setRenderTarget(this.renderTargetsVertical[i2]);
          renderer.clear();
          this.fsQuad.render(renderer);
          inputRenderTarget = this.renderTargetsVertical[i2];
        }
        this.fsQuad.material = this.compositeMaterial;
        this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
        renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
        renderer.clear();
        this.fsQuad.render(renderer);
        this.fsQuad.material = this.materialCopy;
        this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
        if (maskActive)
          renderer.state.buffers.stencil.setTest(true);
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(readBuffer);
          this.fsQuad.render(renderer);
        }
        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
      }
      getSeperableBlurMaterial(kernelRadius) {
        return new ShaderMaterial({
          defines: {
            "KERNEL_RADIUS": kernelRadius,
            "SIGMA": kernelRadius
          },
          uniforms: {
            "colorTexture": { value: null },
            "texSize": { value: new Vector2(0.5, 0.5) },
            "direction": { value: new Vector2(0.5, 0.5) }
          },
          vertexShader: `varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }`,
          fragmentShader: `#include <common>
                  varying vec2 vUv;
                  uniform sampler2D colorTexture;
                  uniform vec2 texSize;
                  uniform vec2 direction;
  
                  float gaussianPdf(in float x, in float sigma) {
                      return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
                  }
                  void main() {
                      vec2 invSize = 1.0 / texSize;
                      float fSigma = float(SIGMA);
                      float weightSum = gaussianPdf(0.0, fSigma);
                      vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                      for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                          float x = float(i);
                          float w = gaussianPdf(x, fSigma);
                          vec2 uvOffset = direction * invSize * x;
                          vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                          vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                          diffuseSum += (sample1 + sample2) * w;
                          weightSum += 2.0 * w;
                      }
                      gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
                  }`
        });
      }
      getCompositeMaterial(nMips) {
        return new ShaderMaterial({
          defines: {
            "NUM_MIPS": nMips
          },
          uniforms: {
            "blurTexture1": { value: null },
            "blurTexture2": { value: null },
            "blurTexture3": { value: null },
            "blurTexture4": { value: null },
            "blurTexture5": { value: null },
            "dirtTexture": { value: null },
            "bloomStrength": { value: 1 },
            "bloomFactors": { value: null },
            "bloomTintColors": { value: null },
            "bloomRadius": { value: 0 }
          },
          vertexShader: `varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }`,
          fragmentShader: `varying vec2 vUv;
                  uniform sampler2D blurTexture1;
                  uniform sampler2D blurTexture2;
                  uniform sampler2D blurTexture3;
                  uniform sampler2D blurTexture4;
                  uniform sampler2D blurTexture5;
                  uniform sampler2D dirtTexture;
                  uniform float bloomStrength;
                  uniform float bloomRadius;
                  uniform float bloomFactors[NUM_MIPS];
                  uniform vec3 bloomTintColors[NUM_MIPS];
  
                  float lerpBloomFactor(const in float factor) {
                      float mirrorFactor = 1.2 - factor;
                      return mix(factor, mirrorFactor, bloomRadius);
                  }
  
                  void main() {
                      gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
                          lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
                          lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
                          lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
                          lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                  }`
        });
      }
    };
    UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
    UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);
  
    // assets/scripts/classes/Canvas/Mask/shaders/fragment.glsl
    var fragment_default4 = "varying vec2 vUv;uniform float uTime;uniform vec2 uResolution;uniform float uMaskProgress;uniform float uMaskIdle;uniform float uMaxMaskScale;uniform float uNoiseProgress;uniform float uOpacityProgress;uniform sampler2D uStartTexture;uniform vec2 uStartTextureResolution;uniform sampler2D uEndTexture;uniform vec2 uEndTextureResolution;uniform sampler2D uNrmTexture;uniform vec2 uNrmTextureResolution;uniform sampler2D uMaskTexture;uniform vec2 uMaskTextureResolution;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec3 backgroundColor=vec3(0.322,0.29,0.541);void main(){float portalOpacity=uOpacityProgress;float noiseMultiplier=.025;float noiseOffsetY=0.1*uTime;vec2 texNoiseCoords=backgroundUV(vUv,uResolution,uNrmTextureResolution);texNoiseCoords.y+=noiseOffsetY;vec4 textureNoise=texture2D(uNrmTexture,texNoiseCoords);textureNoise-=0.5;textureNoise.xy*=noiseMultiplier;vec2 texStartCoords=backgroundUV(vUv,uResolution,uStartTextureResolution);vec4 textureStart=texture2D(uStartTexture,texStartCoords);vec2 texEndCoords=backgroundUV(vUv,uResolution,uEndTextureResolution);vec4 textureEnd=texture2D(uEndTexture,texEndCoords);vec4 textureEndNoisy=texture2D(uEndTexture,vec2(texEndCoords.x+(textureNoise.x*uNoiseProgress),texEndCoords.y+(textureNoise.y*uNoiseProgress)));textureEndNoisy.a=portalOpacity;if(textureEndNoisy.a<1.0){if(textureStart.a<1.){textureEndNoisy=mix(textureEndNoisy,vec4(backgroundColor,1),1.-portalOpacity);}else{textureEndNoisy=mix(textureEndNoisy,textureStart,1.-portalOpacity);}}else{textureEndNoisy=textureEndNoisy;}vec2 texMaskCoords=backgroundUV(vUv,uResolution,uMaskTextureResolution);float maskScaleEnter=clamp(map(uMaskProgress,0.,uMaskIdle,1.,0.),0.,1.);float maskScaleOut=clamp(map(uMaskProgress,uMaskIdle,1.,1.,uMaxMaskScale),1.,uMaxMaskScale);float maskScale=maskScaleOut-maskScaleEnter;texMaskCoords*=1./maskScale;texMaskCoords-=1./maskScale*.5-0.5;vec4 textureMask=texture2D(uMaskTexture,texMaskCoords);vec4 final=mix(textureStart,textureEnd,textureMask.r);vec4 finalNoisy=mix(textureStart,textureEndNoisy,textureMask.r);if(textureStart.a<1.){finalNoisy.rgb+=backgroundColor*(1.-textureMask.r);finalNoisy.a=1.;}gl_FragColor=finalNoisy;}";
  
    // assets/scripts/classes/Canvas/Mask/shaders/vertex.glsl
    var vertex_default2 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Mask/Mask.js
    var import_bezier_easing2 = __toModule(require_src());
    var DEFAULT_PORTAL_CIRCLE_WIDTH2 = 288;
    var DEFAULT_PORTAL_WIDTH3 = 259;
    var HOLD_DURATION2 = 1e3;
    var SMOOTH_EASING2 = (0, import_bezier_easing2.default)(0.38, 5e-3, 0.215, 1);
    var POWER1_OUT = (0, import_bezier_easing2.default)(0.25, 0.46, 0.45, 0.94);
    var POWER2_OUT2 = (0, import_bezier_easing2.default)(0.215, 0.61, 0.355, 1);
    var POWER3_OUT = (0, import_bezier_easing2.default)(0.165, 0.84, 0.44, 1);
    var POWER4_OUT = (0, import_bezier_easing2.default)(0.23, 1, 0.32, 1);
    var POWER1_IN = (0, import_bezier_easing2.default)(0.55, 0.085, 0.68, 0.53);
    var POWER2_IN = (0, import_bezier_easing2.default)(0.55, 0.055, 0.675, 0.19);
    var POWER3_IN = (0, import_bezier_easing2.default)(0.895, 0.03, 0.685, 0.22);
    var POWER4_IN = (0, import_bezier_easing2.default)(0.755, 0.05, 0.855, 0.06);
    var LINEAR = (0, import_bezier_easing2.default)(0, 0, 1, 1);
    var Mask = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.globalAnimationData = {
          progress: 0,
          target: 1,
          duration: 1.4
        };
        this.maskData = {
          idle: 0.5,
          maxScale: 1
        };
        this.maskAnimationData = {
          progress: 0,
          value: 0
        };
        this.noiseAnimationData = {
          value: 1
        };
        this.holdData = {
          baseTime: Date.now(),
          isHolding: false
        };
        this.holdAnimationData = {
          progress: 0,
          value: 0,
          targetIn: 0,
          targetOut: 0,
          durationIn: HOLD_DURATION2 / 1e3,
          durationOut: 0.3,
          scaleMultiplier: 0.8
        };
        this.opacityAnimationData = {
          progress: 0,
          value: 0,
          durationIn: 0.6,
          durationOut: 0.6
        };
        this.textures = [];
        this.startTextureIndex = null;
        this.endTextureIndex = -1;
        this.isInteractiveAreaHovered = false;
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          this.setupPane();
          this.setPlane();
          const startTexture = yield getTexture("/assets/images/temp/texture0.jpg").promise;
          this.textures.push(startTexture);
          const endTexture = yield getTexture("/assets/images/temp/texture1.jpg").promise;
          this.textures.push(endTexture);
          this.setTextures();
          this.nrmTexture = yield getTexture("/assets/images/temp/normalMap.jpg").promise;
          this.nrmTexture.wrapT = RepeatWrapping;
          this.nrmTexture.repeat.set(1, 1);
          this.setNrmTextureUniforms();
          this.maskTexture = yield getTexture("/assets/images/temp/mask.jpg").promise;
          this.setMaskTextureUniforms();
          this.setNoiseUniforms();
          this.setOpacityProgressUniforms();
          this.resetDefaultUniforms();
        });
      }
      destroy() {
        console.log("Mask: destroy");
      }
      resize() {
        this.setResolutionUniforms();
        this.resetDefaultUniforms();
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        this.setTimeUniforms();
        this.updateHold();
      }
      pointerDown() {
        this.holdDown();
      }
      pointerUp() {
        this.holdUp();
      }
      mouseEnter() {
        if (this.isInteractiveAreaHovered)
          return;
        this.isInteractiveAreaHovered = true;
        this.animateOpacityIn();
      }
      mouseLeave() {
        if (!this.isInteractiveAreaHovered || this.holdData.isHolding)
          return;
        this.isInteractiveAreaHovered = false;
        this.animateOpacityOut();
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          uniforms: {
            uTime: { value: 0 },
            uResolution: { value: [0, 0] },
            uMaskProgress: { value: 0 },
            uMaskIdle: { value: 0 },
            uMaxMaskScale: { value: 0 },
            uNoiseProgress: { value: 0 },
            uOpacityProgress: { value: 0 },
            uStartTexture: { value: null },
            uStartTextureResolution: { value: [0, 0] },
            uEndTexture: { value: null },
            uEndTextureResolution: { value: [0, 0] },
            uMaskTexture: { value: null },
            uMaskTextureResolution: { value: [0, 0] },
            uNrmTexture: { value: null },
            uNrmTextureResolution: { value: [0, 0] }
          },
          transparent: true,
          vertexShader: vertex_default2,
          fragmentShader: fragment_default4
        });
        this.geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
      }
      setTextures() {
        this.startTextureIndex = this.endTextureIndex;
        this.endTextureIndex = (this.endTextureIndex + 1) % this.textures.length;
        this.setStartTextureUniforms();
        this.setEndTextureUniforms();
      }
      setInteractiveAreaWidth(textureScale) {
        const portalWidth = Math.round(DEFAULT_PORTAL_WIDTH3 * textureScale);
        const portalRadius = portalWidth * 0.5;
        this.moduleInstance.$interactiveArea.style.width = `${portalWidth}px`;
        this.moduleInstance.$interactiveArea.style.borderRadius = `${portalRadius}px ${portalRadius}px 0 0`;
      }
      holdDown() {
        if (this.holdData.isHolding || !this.moduleInstance.hasHoldAvailable)
          return;
        this.holdData.baseTime = Date.now();
        this.holdData.isHolding = true;
        this.moduleInstance.call("holdDown", HOLD_DURATION2, "Cursor");
        if (!this.isInteractiveAreaHovered) {
          this.animateOpacityIn();
        }
        this.animateHoldDown();
      }
      holdUp(isComplete = false) {
        if (!this.holdData.isHolding || !this.moduleInstance.hasHoldAvailable)
          return;
        this.holdData.isHolding = false;
        this.moduleInstance.call("holdUp", HOLD_DURATION2, "Cursor");
        if (!isComplete) {
          if (!this.isInteractiveAreaHovered) {
            this.animateOpacityOut();
          }
          this.animateHoldUp();
        }
      }
      updateHold() {
        if (!this.holdData.isHolding)
          return;
        const dateNow = Date.now();
        const elapsedTime = dateNow - this.holdData.baseTime;
        if (elapsedTime > HOLD_DURATION2) {
          this.holdUp(true);
          this.animateGlobal();
        }
      }
      resetDefaultUniforms() {
        this.setMaxMaskScaleUniforms();
        this.setMaskIdleUniforms();
      }
      setMaskTextureUniforms() {
        const texWidth = this.maskTexture.image.width;
        const texHeight = this.maskTexture.image.height;
        this.material.uniforms.uMaskTexture.value = this.maskTexture;
        this.material.uniforms.uMaskTextureResolution.value = [texWidth, texHeight];
      }
      setNrmTextureUniforms() {
        const texWidth = this.nrmTexture.image.width;
        const texHeight = this.nrmTexture.image.height;
        this.material.uniforms.uNrmTexture.value = this.nrmTexture;
        this.material.uniforms.uNrmTextureResolution.value = [texWidth, texHeight];
      }
      setStartTextureUniforms() {
        const startTexture = this.textures[this.startTextureIndex];
        if (!startTexture)
          return;
        const texWidth = startTexture.image.width;
        const texHeight = startTexture.image.height;
        this.material.uniforms.uStartTexture.value = startTexture;
        this.material.uniforms.uStartTextureResolution.value = [texWidth, texHeight];
      }
      setEndTextureUniforms() {
        const endTexture = this.textures[this.endTextureIndex];
        if (!endTexture)
          return;
        const texWidth = endTexture.image.width;
        const texHeight = endTexture.image.height;
        this.material.uniforms.uEndTexture.value = endTexture;
        this.material.uniforms.uEndTextureResolution.value = [texWidth, texHeight];
      }
      setResolutionUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        this.material.uniforms.uResolution.value = [canvasWidth, canvasHeight];
      }
      setTimeUniforms() {
        this.material.uniforms.uTime.value = this.time;
      }
      setMaxMaskScaleUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        const originalTexWidth = this.maskTexture.image.width;
        const originalTexHeight = this.maskTexture.image.height;
        const tAspect = originalTexWidth / originalTexHeight;
        const pAspect = canvasWidth / canvasHeight;
        const pwidth = canvasWidth;
        const pheight = canvasHeight;
        let currentTexWidth = 0;
        if (tAspect > pAspect) {
          currentTexWidth = pheight * tAspect;
        } else {
          currentTexWidth = pwidth;
        }
        const textureScale = currentTexWidth / originalTexWidth;
        const circleWidth = DEFAULT_PORTAL_CIRCLE_WIDTH2 * textureScale;
        this.setInteractiveAreaWidth(textureScale);
        const pythA = canvasHeight / 2;
        const pythB = canvasWidth / 2;
        const hypot = Math.hypot(pythA, pythB);
        const originalScale = hypot / circleWidth * 2;
        const roundedScale = Math.round((originalScale + Number.EPSILON) * 100) / 100;
        this.maskData.maxScale = this.material.uniforms.uMaxMaskScale.value = roundedScale;
      }
      setMaskProgressUniforms() {
        this.material.uniforms.uMaskProgress.value = this.maskAnimationData.value;
      }
      setOpacityProgressUniforms() {
        this.material.uniforms.uOpacityProgress.value = this.opacityAnimationData.value;
      }
      setMaskIdleUniforms() {
        const idle = Math.round((1 / this.maskData.maxScale + Number.EPSILON) * 100) / 100;
        this.maskData.idle = this.material.uniforms.uMaskIdle.value = idle;
        this.maskAnimationData.value = this.maskData.idle;
        this.setMaskProgressUniforms();
        this.holdAnimationData.targetIn = this.maskData.idle * this.holdAnimationData.scaleMultiplier;
        this.holdAnimationData.targetOut = this.maskData.idle;
        this.holdAnimationData.value = this.maskData.idle;
      }
      setNoiseUniforms() {
        this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
      }
      setupPane() {
        if (!this.paneObj)
          return;
        const folder = this.paneObj.pane.addFolder({
          title: "Mask",
          expanded: true
        });
        this.paneObj.params.progress = 0;
        folder.addInput(this.paneObj.params, "progress", { min: 0, max: 1 }).on("change", (ev) => {
          const value = ev.value;
          this.material.uniforms.uMaskProgress.value = value;
        });
      }
      animateGlobal() {
        this.moduleInstance.hasHoldAvailable = false;
        this.setMaskAnimation();
        this.setNoiseAnimation();
        this.holdTween = gsapWithCSS2.to(this.globalAnimationData, {
          duration: this.globalAnimationData.duration,
          progress: this.globalAnimationData.target,
          ease: "linear",
          onUpdate: () => {
            this.animateMask(this.globalAnimationData.progress);
          },
          onComplete: this.resetGlobal.bind(this)
        });
      }
      resetGlobal() {
        this.globalAnimationData.progress = 0;
        this.holdAnimationData.value = this.maskData.idle;
        this.holdAnimationData.progress = 0;
        this.maskAnimationData.value = this.maskData.idle;
        this.maskAnimationData.progress = 0;
        this.noiseAnimationData.value = 0;
        this.moduleInstance.hasHoldAvailable = true;
      }
      setMaskAnimation() {
        let hasChangeTexture = false;
        this.portalTween = gsapWithCSS2.to(this.maskAnimationData, {
          progress: 1,
          ease: "linear",
          onUpdate: () => {
            const valueStart = this.holdAnimationData.targetIn;
            const valueEnd = 1 + this.maskData.idle;
            const easedValue = mapRange(0, 1, valueStart, valueEnd, POWER2_OUT2(this.maskAnimationData.progress));
            const computedValue = (easedValue + 1) % 1;
            this.material.uniforms.uMaskProgress.value = computedValue;
            const maskOutProgress = clamp(0, 1, mapRange(this.maskData.idle, 1, 0, 1, easedValue));
            if (maskOutProgress > 0 && maskOutProgress < 1) {
              this.animateMaskOut(maskOutProgress);
            }
            const maskInProgress = clamp(0, 1, mapRange(1, 1 + this.maskData.idle, 0, 1, easedValue));
            if (maskInProgress > 0 && maskInProgress < 1) {
              this.animateMaskIn(maskInProgress);
            }
            if (easedValue >= 1 && !hasChangeTexture) {
              hasChangeTexture = true;
              this.setTextures();
              if (!this.isInteractiveAreaHovered) {
                this.material.uniforms.uOpacityProgress.value = 0;
                this.opacityAnimationData.progress = 0;
                this.opacityAnimationData.value = 0;
              }
            }
          },
          paused: true,
          immediateRender: false
        });
      }
      animateMask(progress) {
        var _a;
        (_a = this.portalTween) == null ? void 0 : _a.progress(progress);
      }
      animateMaskIn(progress) {
        var _a;
        (_a = this.noiseAppearTween) == null ? void 0 : _a.progress(progress);
      }
      animateMaskOut(progress) {
        var _a;
        (_a = this.noiseDisappearTween) == null ? void 0 : _a.progress(progress);
      }
      setNoiseAnimation() {
        this.noiseDisappearTween = gsapWithCSS2.fromTo(this.noiseAnimationData, {
          value: 1
        }, {
          value: 0,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
        this.noiseAppearTween = gsapWithCSS2.fromTo(this.noiseAnimationData, {
          value: 0
        }, {
          value: 1,
          ease: "linear",
          onUpdate: () => {
            this.material.uniforms.uNoiseProgress.value = this.noiseAnimationData.value;
          },
          paused: true,
          immediateRender: false
        });
      }
      animateHoldDown() {
        var _a;
        (_a = this.holdTween) == null ? void 0 : _a.kill();
        const valueStart = this.holdAnimationData.value;
        this.holdTween = gsapWithCSS2.to(this.holdAnimationData, {
          duration: this.holdAnimationData.durationIn,
          progress: 1,
          ease: "linear",
          onUpdate: () => {
            const valueEnd = this.holdAnimationData.targetIn;
            const easedValue = mapRange(0, 1, valueStart, valueEnd, SMOOTH_EASING2(this.holdAnimationData.progress));
            this.material.uniforms.uMaskProgress.value = easedValue;
            this.holdAnimationData.value = easedValue;
          }
        });
      }
      animateHoldUp() {
        var _a;
        (_a = this.holdTween) == null ? void 0 : _a.kill();
        const valueStart = this.holdAnimationData.value;
        this.holdTween = gsapWithCSS2.to(this.holdAnimationData, {
          duration: this.holdAnimationData.durationOut,
          progress: 0,
          ease: "linear",
          onUpdate: () => {
            const valueEnd = this.holdAnimationData.targetOut;
            const easedValue = mapRange(1, 0, valueStart, valueEnd, POWER2_OUT2(this.holdAnimationData.progress));
            this.material.uniforms.uMaskProgress.value = easedValue;
            this.holdAnimationData.value = easedValue;
          }
        });
      }
      animateOpacityIn() {
        var _a;
        if (this.opacityAnimationData.isAnimatedIn)
          return;
        (_a = this.opacityTween) == null ? void 0 : _a.kill();
        this.opacityAnimationData.isAnimatedOut = false;
        this.opacityTween = gsapWithCSS2.to(this.opacityAnimationData, {
          duration: this.opacityAnimationData.durationIn,
          progress: 1,
          ease: "linear",
          onStart: () => {
            this.opacityAnimationData.isAnimatedIn = true;
          },
          onUpdate: () => {
            const easedValue = mapRange(0, 1, 0, 1, POWER1_OUT(this.opacityAnimationData.progress));
            this.material.uniforms.uOpacityProgress.value = easedValue;
            this.opacityAnimationData.value = easedValue;
          },
          onComplete: () => {
            this.opacityAnimationData.isAnimatedIn = false;
          }
        });
      }
      animateOpacityOut() {
        var _a;
        if (this.opacityAnimationData.isAnimatedOut)
          return;
        (_a = this.opacityTween) == null ? void 0 : _a.kill();
        this.opacityAnimationData.isAnimatedIn = false;
        this.opacityTween = gsapWithCSS2.to(this.opacityAnimationData, {
          duration: this.opacityAnimationData.durationOut,
          progress: 0,
          ease: "linear",
          onStart: () => {
            this.opacityAnimationData.isAnimatedOut = true;
          },
          onUpdate: () => {
            const easedValue = mapRange(0, 1, 0, 1, POWER1_IN(this.opacityAnimationData.progress));
            this.material.uniforms.uOpacityProgress.value = easedValue;
            this.opacityAnimationData.value = easedValue;
          },
          onComplete: () => {
            this.opacityAnimationData.isAnimatedOut = false;
          }
        });
      }
    };
  
    // assets/scripts/classes/Canvas/Depthmap/shaders/fragment.glsl
    var fragment_default5 = "#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec2 vUv;uniform float uTime;uniform float uProgress;uniform vec2 uMouse;uniform vec2 uThreshold;uniform vec2 uResolution;uniform float uPixelRatio;uniform sampler2D uOriginalTexture;uniform vec2 uOriginalTextureResolution;uniform sampler2D uDepthTexture;uniform vec2 uDepthTextureResolution;vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec2 mirrored(vec2 v){vec2 m=mod(v,2.);return mix(m,2.0-m,step(1.0,m));}void main(){vec2 bUv=backgroundUV(vUv,uResolution,uOriginalTextureResolution);vec4 texDepth=texture2D(uDepthTexture,mirrored(bUv));vec2 fake3d=vec2(bUv.x+(texDepth.r-0.5)*uMouse.x/uThreshold.x,bUv.y+(texDepth.r-0.5)*uMouse.y/uThreshold.y);gl_FragColor=texture2D(uOriginalTexture,mirrored(fake3d));}";
  
    // assets/scripts/classes/Canvas/Depthmap/shaders/vertex.glsl
    var vertex_default3 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Depthmap/Depthmap.js
    var TweakpaneImagePlugin = __toModule(require_tweakpane_image_plugin());
    var Depthmap2 = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.textures = [];
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: init`);
          this.setPlane();
          this.originalTextureSrc = "/assets/images/temp/texture1.jpg";
          this.depthTextureSrc = "/assets/images/temp/texture1-map.jpg";
          this.originalTexture = yield getTexture(this.originalTextureSrc).promise;
          this.depthTexture = yield getTexture(this.depthTextureSrc).promise;
          this.setResolutionUniforms();
          this.setOriginalTextureUniforms();
          this.setDepthTextureUniforms();
          this.setupPane();
        });
      }
      destroy() {
        console.log(`${this.moduleInstance.playgroundId}: destroy`);
      }
      resize() {
        console.log(`${this.moduleInstance.playgroundId}: resize`);
        this.setResolutionUniforms();
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        this.material.uniforms.uTime.value = this.time;
      }
      pointerDown() {
        console.log(`${this.moduleInstance.playgroundId}: pointerDown`);
      }
      pointerUp() {
        console.log(`${this.moduleInstance.playgroundId}: pointerUp`);
      }
      mouseMove(mouseCoords) {
        let { x, y, smoothX, smoothY } = mouseCoords;
        const halfX = this.material.uniforms.uResolution.value[0] / 2;
        const halfY = this.material.uniforms.uResolution.value[1] / 2;
        x = (halfX - x) / halfX;
        y = (halfY - y) / halfY;
        this.material.uniforms.uMouse.value = [x, y];
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
            uMouse: { value: [0, 0] },
            uThreshold: { value: [40, 60] },
            uResolution: { value: [0, 0] },
            uPixelRatio: this.dpr,
            uOriginalTexture: { value: null },
            uOriginalTextureResolution: { value: [0, 0] },
            uDepthTexture: { value: null },
            uDepthTextureResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default3,
          fragmentShader: fragment_default5
        });
        this.geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
      }
      setResolutionUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        this.material.uniforms.uResolution.value = [canvasWidth, canvasHeight];
      }
      setOriginalTextureUniforms() {
        this.material.uniforms.uOriginalTexture.value = this.originalTexture;
        this.material.uniforms.uOriginalTextureResolution.value = [this.originalTexture.image.width, this.originalTexture.image.height];
      }
      setDepthTextureUniforms() {
        this.material.uniforms.uDepthTexture.value = this.depthTexture;
        this.material.uniforms.uDepthTextureResolution.value = [this.depthTexture.image.width, this.depthTexture.image.height];
      }
      setupPane() {
        if (!this.paneObj)
          return;
        this.paneObj.pane.registerPlugin(TweakpaneImagePlugin);
        const folder = this.paneObj.pane.addFolder({
          title: "Depthmap",
          expanded: true
        });
        this.paneObj.params.image = new Image();
        this.paneObj.params.image.src = this.originalTextureSrc;
        folder.addInput(this.paneObj.params, "image", {
          view: "input-image"
        }).on("change", (ev) => __async(this, null, function* () {
          this.originalTextureSrc = ev.value.currentSrc;
          this.originalTexture = yield getTexture(this.originalTextureSrc).promise;
          this.setOriginalTextureUniforms();
        }));
        this.paneObj.params.depthMap = new Image();
        this.paneObj.params.depthMap.src = this.depthTextureSrc;
        folder.addInput(this.paneObj.params, "depthMap", {
          view: "input-image"
        }).on("change", (ev) => __async(this, null, function* () {
          this.depthTextureSrc = ev.value.currentSrc;
          this.depthTexture = yield getTexture(this.depthTextureSrc).promise;
          this.setDepthTextureUniforms();
        }));
        this.paneObj.params.threshold = { x: this.material.uniforms.uThreshold.value[0], y: this.material.uniforms.uThreshold.value[1] };
        folder.addInput(this.paneObj.params, "threshold", {
          x: { min: 0, max: 100 },
          y: { min: 0, max: 100, inverted: true }
        }).on("change", (ev) => {
          const value = ev.value;
          this.material.uniforms.uThreshold.value[0] = value.x;
          this.material.uniforms.uThreshold.value[1] = value.y;
        });
      }
    };
  
    // assets/scripts/classes/Canvas/Typo/shaders/vertex.glsl
    var vertex_default4 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Typo/Typo.js
    var HOLD_DURATION3 = 1e3;
    var CURVESEGMENTS2 = 4;
    var Typo2 = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: init`);
          yield this.loadFonts();
          this.setTextData();
          this.setScene();
          this.setTimeline();
          this.setupPane();
        });
      }
      destroy() {
        var _a, _b;
        console.log(`${this.moduleInstance.playgroundId}: destroy`);
        (_b = (_a = this.timeline) == null ? void 0 : _a.kill) == null ? void 0 : _b.call(_a);
      }
      resize() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: resize`);
          yield this.loadFonts();
          this.setTextData();
          this.setScene();
          this.setTimeline();
        });
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        this.updateHold();
      }
      pointerDown() {
        this.holdDown();
      }
      pointerUp() {
        this.holdUp();
      }
      loadFonts() {
        return __async(this, null, function* () {
          this.fonts = {};
          const fontLoader = new FontLoader();
          const fontPromises = [];
          const fonts2 = [
            {
              name: "Lexend",
              file: "/assets/fonts/Lexend-Regular_restricted.json"
            },
            {
              name: "LibreCaslonRegular",
              file: "/assets/fonts/LibreCaslonText_Regular.json"
            },
            {
              name: "LibreCaslonItalic",
              file: "/assets/fonts/LibreCaslonText_Italic.json"
            }
          ];
          for (let font of fonts2) {
            fontPromises.push(new Promise((resolve) => {
              fontLoader.load(font.file, (fontface) => {
                this.fonts[font.name] = fontface;
                resolve();
              });
            }));
          }
          yield Promise.all(fontPromises);
        });
      }
      setTextData() {
        if (window.innerWidth >= 1e3) {
          const FONT_SIZE = 0.1;
          this.textData = [
            {
              value: "We Create",
              align: "center",
              font: "Lexend",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: FONT_SIZE * 1.2
              }
            },
            {
              value: "Havens",
              align: "right",
              font: "Lexend",
              size: FONT_SIZE,
              position: {
                x: -0.025,
                y: FONT_SIZE * 0
              }
            },
            {
              value: "Endless",
              align: "left",
              font: "LibreCaslonItalic",
              size: FONT_SIZE,
              position: {
                x: 0.05,
                y: FONT_SIZE * -1.3
              }
            },
            {
              value: "for",
              align: "right",
              font: "Lexend",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: FONT_SIZE * -1.3
              }
            },
            {
              value: "Wonder.",
              align: "left",
              font: "LibreCaslonRegular",
              size: FONT_SIZE,
              position: {
                x: -0.15,
                y: FONT_SIZE * -2.5
              }
            }
          ];
        } else {
          const FONT_SIZE = 0.05;
          this.textData = [
            {
              value: "We Create",
              align: "center",
              font: "Lexend",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: FONT_SIZE * 1.2
              }
            },
            {
              value: "Havens",
              align: "center",
              font: "Lexend",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: 0
              }
            },
            {
              value: "for Endless",
              align: "center",
              font: "LibreCaslonItalic",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: FONT_SIZE * -1.3
              }
            },
            {
              value: "Wonder.",
              align: "center",
              font: "LibreCaslonRegular",
              size: FONT_SIZE,
              position: {
                x: 0,
                y: FONT_SIZE * -2.5
              }
            }
          ];
        }
      }
      clearScene() {
        this.scene.clear();
      }
      setScene() {
        this.clearScene();
        this.chars = [];
        for (let i2 = 0; i2 < this.textData.length; i2++) {
          const text2 = this.textData[i2];
          const textGeometry = new TextGeometry(text2.value, {
            font: this.fonts[text2.font],
            size: text2.size,
            height: 0,
            curveSegments: CURVESEGMENTS2
          });
          textGeometry.computeBoundingBox();
          let x;
          let y = text2.position.y;
          const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
          switch (text2.align) {
            case "left":
              x = text2.position.x;
              break;
            case "center":
              x = text2.position.x - textWidth / 2;
              break;
            case "right":
              x = text2.position.x - textWidth;
              break;
          }
          let offset2 = 0;
          const chars = text2.value.split("");
          const lineChars = [];
          for (let j = chars.length - 1; j >= 0; j--) {
            const charGeometry = new TextGeometry(chars[j], {
              font: this.fonts[text2.font],
              size: text2.size,
              height: 0,
              curveSegments: CURVESEGMENTS2
            });
            charGeometry.computeBoundingBox();
            charGeometry.translate(-charGeometry.boundingBox.max.x, 0, 0);
            const remainingGeometry = new TextGeometry(text2.value.slice(0, j), {
              font: this.fonts[text2.font],
              size: text2.size,
              height: 0,
              curveSegments: CURVESEGMENTS2
            });
            remainingGeometry.computeBoundingBox();
            let remainingWidth = remainingGeometry.boundingBox.max.x - remainingGeometry.boundingBox.min.x;
            const position = {
              x: x + textWidth + offset2,
              y
            };
            const textMaterial = new ShaderMaterial({
              extensions: {
                derivatives: "#extension GL_OES_standard_derivatives : enable"
              },
              uniforms: {
                uOpacity: { value: 1 }
              },
              transparent: true,
              vertexShader: vertex_default4,
              fragmentShader: `
                          precision mediump float;
                          uniform float uOpacity;
  
                          void main() {
                             gl_FragColor = vec4(uOpacity,uOpacity,uOpacity,1.);
                          }
                      `
            });
            const mesh = new Mesh(charGeometry, textMaterial);
            mesh.position.x = position.x;
            mesh.position.y = position.y;
            this.scene.add(mesh);
            lineChars.push({
              text: text2,
              value: chars[j],
              mesh,
              geometry: charGeometry,
              position,
              progress: 1
            });
            offset2 = remainingWidth - textWidth;
          }
          lineChars.reverse();
          this.chars = this.chars.concat(lineChars);
        }
      }
      setTimeline() {
        this.timeline = gsapWithCSS2.timeline({
          onUpdate: () => {
            for (let char of this.chars) {
              char.mesh.position.y = char.position.y - char.text.size * (1 - char.progress);
              char.mesh.material.uniforms.uOpacity.value = char.progress;
            }
          }
        });
        this.timeline.from(this.chars, {
          progress: 0,
          duration: 2,
          stagger: 0.03,
          ease: "power4.out"
        });
      }
      reveal() {
        this.timeline.restart();
      }
      holdDown() {
        if (this.isHolding)
          return;
        this.holdBaseTime = Date.now();
        this.isHolding = true;
        this.moduleInstance.call("holdDown", HOLD_DURATION3, "Cursor");
      }
      holdUp(isComplete = false) {
        if (!this.isHolding)
          return;
        this.isHolding = false;
        this.moduleInstance.call("holdUp", HOLD_DURATION3, "Cursor");
        if (!isComplete) {
        }
      }
      updateHold() {
        if (!this.isHolding)
          return;
        const dateNow = Date.now();
        const elapsedTime = dateNow - this.holdBaseTime;
        if (elapsedTime > HOLD_DURATION3) {
          this.holdUp(true);
          this.reveal();
        }
      }
      setupPane() {
        if (!this.paneObj)
          return;
        const folder = this.paneObj.pane.addFolder({
          title: "Typo",
          expanded: true
        });
      }
    };
  
    // assets/scripts/classes/Canvas/Portal/shaders/fragment.glsl
    var fragment_default6 = "varying vec2 vUv;uniform float uTime;uniform float uProgress;void main(){float sinTime=abs(sin(uTime*1.));float computedProgress=sinTime*uProgress;gl_FragColor=vec4(vUv,computedProgress,1.);}";
  
    // assets/scripts/classes/Canvas/Portal/shaders/fragmentPortal.glsl
    var fragmentPortal_default = "varying vec2 vUv;uniform float uTime;uniform float uProgress;uniform vec2 uResolution;uniform sampler2D uPortalTexture;uniform vec2 uPortalTextureResolution;vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}void main(){vec2 texCoords=backgroundUV(vUv,uResolution,uPortalTextureResolution);vec4 texture=texture2D(uPortalTexture,texCoords);texture.a=texture.r;gl_FragColor=texture;}";
  
    // assets/scripts/classes/Canvas/Portal/shaders/vertex.glsl
    var vertex_default5 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Portal/Portal.js
    var Portal2 = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.planes = [];
        this.materials = [];
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: init`);
          this.portalTexture = yield getTexture("/assets/images/temp/portal.jpg").promise;
          this.setupPane();
          this.setPlane();
          this.setPortalPlane();
          this.setPortalTextureUniforms();
        });
      }
      destroy() {
        console.log(`${this.moduleInstance.playgroundId}: destroy`);
      }
      resize() {
        this.setResolutionUniforms();
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        let materialIndex = 0;
        while (materialIndex < this.materials.length) {
          const material = this.materials[materialIndex];
          material.uniforms.uTime.value = this.time;
          materialIndex++;
        }
      }
      pointerDown() {
        console.log(`${this.moduleInstance.playgroundId}: pointerDown`);
      }
      pointerUp() {
        console.log(`${this.moduleInstance.playgroundId}: pointerUp`);
      }
      mouseMove(mouseCoords) {
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
            uResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default5,
          fragmentShader: fragment_default6
        });
        this.materials.push(this.material);
        this.geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
        this.planes.push(this.plane);
      }
      setPortalPlane() {
        this.materialPortal = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
            uResolution: { value: [0, 0] },
            uPortalTexture: { value: null },
            uPortalTextureResolution: { value: [0, 0] }
          },
          transparent: true,
          vertexShader: vertex_default5,
          fragmentShader: fragmentPortal_default
        });
        this.materials.push(this.materialPortal);
        this.geometryPortal = new PlaneGeometry(1, 1, 1, 1);
        this.planePortal = new Mesh(this.geometryPortal, this.materialPortal);
        this.scene.add(this.planePortal);
        this.planes.push(this.planePortal);
      }
      setResolutionUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        let materialIndex = 0;
        while (materialIndex < this.materials.length) {
          const material = this.materials[materialIndex];
          material.uniforms.uResolution.value = [canvasWidth, canvasHeight];
          materialIndex++;
        }
      }
      setPortalTextureUniforms() {
        const texWidth = this.portalTexture.image.width;
        const texHeight = this.portalTexture.image.height;
        this.materialPortal.uniforms.uPortalTexture.value = this.portalTexture;
        this.materialPortal.uniforms.uPortalTextureResolution.value = [texWidth, texHeight];
      }
      setupPane() {
        if (!this.paneObj)
          return;
        const folder = this.paneObj.pane.addFolder({
          title: "Portal",
          expanded: true
        });
        this.paneObj.params.progress = 0;
        folder.addInput(this.paneObj.params, "progress", { min: 0, max: 1 }).on("change", (ev) => {
          const value = ev.value;
          if (this.material) {
            this.material.uniforms.uProgress.value = value;
          }
        });
      }
    };
  
    // assets/scripts/classes/Canvas/Glitch/shaders/fragment.glsl
    var fragment_default7 = "varying vec2 vUv;uniform float uTime;uniform sampler2D uVideoTexture;uniform vec2 uVideoTextureResolution;float random2d(vec2 n){return fract(sin(dot(n,vec2(12.9898,4.1414)))*43758.5453);}float randomRange(in vec2 seed,in float min,in float max){return min+random2d(seed)*(max-min);}float insideRange(float v,float bottom,float top){return step(bottom,v)-step(top,v);}float AMT=0.015;float SPEED=0.5;void main(){float time=floor(uTime*SPEED*60.0);vec2 uv=vUv;vec3 outCol=texture(uVideoTexture,uv).rgb;float maxOffset=AMT/2.0;for(float i=0.0;i<10.0*AMT;i+=1.0){float sliceY=random2d(vec2(time,2345.0+float(i)));float sliceH=random2d(vec2(time,9035.0+float(i)))*0.25;float hOffset=randomRange(vec2(time,9625.0+float(i)),-maxOffset,maxOffset);vec2 uvOff=uv;uvOff.x+=hOffset;if(insideRange(uv.y,sliceY,fract(sliceY+sliceH))==1.0){outCol=texture(uVideoTexture,uvOff).rgb;}}float maxColOffset=AMT/6.0;float rnd=random2d(vec2(time,9545.0));vec2 colOffset=vec2(randomRange(vec2(time,9545.0),-maxColOffset,maxColOffset),randomRange(vec2(time,7205.0),-maxColOffset,maxColOffset));if(rnd<0.33){outCol.r=texture(uVideoTexture,uv+colOffset).r;}else if(rnd<0.66){outCol.g=texture(uVideoTexture,uv+colOffset).g;}else{outCol.b=texture(uVideoTexture,uv+colOffset).b;}gl_FragColor=vec4(outCol,1.0);}";
  
    // assets/scripts/classes/Canvas/Glitch/shaders/vertex.glsl
    var vertex_default6 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Glitch/Glitch.js
    var Glitch = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: init`);
          this.setPlane();
          this.video = document.createElement("video");
          this.video.muted = true;
          this.video.autoplay = true;
          this.video.src = "/assets/images/temp/samplevideo.mp4";
          document.body.appendChild(this.video);
          gsapWithCSS2.set(this.video, { position: "absolute", top: 0, left: 0, width: "100vw", height: "100vh", zIndex: 10, opacity: 0, pointerEvents: "none" });
          this.videoTexture = yield getTexture(this.video);
          this.setVideoTextureUniforms();
          this.setupPane();
        });
      }
      destroy() {
        console.log(`${this.moduleInstance.playgroundId}: destroy`);
      }
      resize() {
        console.log(`${this.moduleInstance.playgroundId}: resize`);
        this.setResolutionUniforms();
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        this.setTimeUniforms();
        this.videoTexture.needsUpdate = true;
      }
      setPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uResolution: { value: [0, 0] },
            uPixelRatio: this.dpr,
            uVideoTexture: { value: null },
            uVideoTextureResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default6,
          fragmentShader: fragment_default7
        });
        this.geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
      }
      setResolutionUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        this.material.uniforms.uResolution.value = [canvasWidth, canvasHeight];
      }
      setTimeUniforms() {
        this.material.uniforms.uTime.value = this.time;
      }
      setVideoTextureUniforms() {
        this.material.uniforms.uVideoTexture.value = this.videoTexture;
        this.material.uniforms.uVideoTextureResolution.value = [this.videoTexture.image.width, this.videoTexture.image.height];
      }
      setupPane() {
        if (!this.paneObj)
          return;
        const folder = this.paneObj.pane.addFolder({
          title: this.moduleInstance.playgroundId,
          expanded: true
        });
      }
    };
  
    // assets/scripts/classes/Canvas/Introduction/shaders/fragment.glsl
    var fragment_default8 = "varying vec2 vUv;uniform float uTime;uniform float uProgress;void main(){float sinTime=abs(sin(uTime*1.));float computedProgress=sinTime*uProgress;gl_FragColor=vec4(vUv,computedProgress,1.);}";
  
    // assets/scripts/classes/Canvas/Introduction/shaders/fragmentPortal.glsl
    var fragmentPortal_default2 = "const float PI=3.1415926535897932384626433832795;varying vec2 vUv;uniform float uTime;uniform float uMouseVelocity;uniform float uIndex;uniform vec2 uMouse;uniform vec2 uThreshold;uniform float uProgress;uniform float uMaxMaskScale;uniform vec2 uResolution;uniform sampler2D uPortalTexture;uniform vec2 uPortalTextureResolution;vec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){float tAspect=texResolution.x/texResolution.y;float pAspect=resolution.x/resolution.y;float pwidth=resolution.x;float pheight=resolution.y;float width=0.0;float height=0.0;if(tAspect>pAspect){height=pheight;width=height*tAspect;}else{width=pwidth;height=width/tAspect;}float x=(pwidth-width)/2.0;float y=(pheight-height)/2.0;vec2 nUv=uv;nUv-=vec2(x,y)/resolution;nUv/=vec2(width,height)/resolution;return nUv;}vec2 rotateUV(vec2 uv,float rotation){float mid=0.5;return vec2(cos(rotation)*(uv.x-mid)+sin(rotation)*(uv.y-mid)+mid,cos(rotation)*(uv.y-mid)-sin(rotation)*(uv.x-mid)+mid);}vec3 backgroundColor=vec3(0.322,0.29,0.541);vec3 backgroundColor2=vec3(1,1,0.98);vec3 backgroundColor3=vec3(0.24,0.64,0.88);void main(){vec2 texCoords=backgroundUV(vUv,uResolution,uPortalTextureResolution);vec2 move=vec2(uMouse.x/uThreshold.x,uMouse.y/uThreshold.y)*smoothstep(0.0,1.4,uProgress*3.);texCoords=texCoords-move;texCoords=rotateUV(texCoords,PI/100.*uMouseVelocity);float scale=uMaxMaskScale*uProgress;texCoords*=1./scale;texCoords-=1./scale*.5-0.5;vec4 texture=texture2D(uPortalTexture,texCoords);texture.rgb*=smoothstep(0.45,0.55,texture.r);texture.a=1.-texture.r;if(texture.a<1.){texture.rgb=vec3(0.);texture.a=0.;}if(mod(uIndex,2.)==0.0){if(texture.a>0.){texture.rgb=backgroundColor;}}else if(mod(uIndex,2.)==1.0){if(texture.a>0.){texture.rgb=mix(backgroundColor3,backgroundColor2,uProgress*6.);}}gl_FragColor=texture;}";
  
    // assets/scripts/classes/Canvas/Introduction/shaders/vertex.glsl
    var vertex_default7 = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
  
    // assets/scripts/classes/Canvas/Introduction/Introduction.js
    var DEFAULT_PORTAL_CIRCLE_WIDTH3 = 288;
    var Introduction = class {
      constructor({ scene, renderer, paneObj, moduleInstance }) {
        this.scene = scene;
        this.renderer = renderer;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.time = 0;
        this.portalsCount = 20;
        this.portalsPool = [];
        this.materials = [];
        this.lastMouseX = 0;
        this.animationDuration = 3;
        this.portalsInView = 16;
        this.init();
      }
      init() {
        return __async(this, null, function* () {
          console.log(`${this.moduleInstance.playgroundId}: init`);
          this.portalTexture = yield getTexture("/assets/images/temp/mask.jpg").promise;
          this.setupPane();
          this.setBackgroundPlane();
          this.setPortalPlanes();
          this.setPortalTextureUniforms();
          this.resize();
          gsapWithCSS2.to(this.portalsPool, {
            progress: 1.6,
            duration: this.animationDuration,
            ease: "power3.inOut",
            stagger: this.animationDuration * 1 / this.portalsInView,
            onUpdate: () => {
              let index2 = 0;
              while (index2 < this.portalsPool.length) {
                const portal = this.portalsPool[index2];
                if (!portal)
                  return;
                portal.material.uniforms.uProgress.value = portal.progress;
                index2++;
              }
            }
          });
        });
      }
      destroy() {
        console.log(`${this.moduleInstance.playgroundId}: destroy`);
      }
      resize() {
        this.width = this.renderer.domElement.offsetWidth;
        this.height = this.renderer.domElement.offsetHeight;
        this.compute(this.width, this.height);
      }
      update(time, deltaTime, frame) {
        this.time += 0.01;
        let materialIndex = 0;
        while (materialIndex < this.materials.length) {
          const material = this.materials[materialIndex];
          material.uniforms.uTime.value = this.time;
          materialIndex++;
        }
      }
      pointerDown() {
        console.log(`${this.moduleInstance.playgroundId}: pointerDown`);
      }
      pointerUp() {
        console.log(`${this.moduleInstance.playgroundId}: pointerUp`);
      }
      mouseMove(mouseCoords) {
        let { x, y, smoothX, smoothY } = mouseCoords;
        const mouseVelocity = clamp5((smoothX - this.lastMouseX) / 20, -1, 1);
        let portalIndex = 0;
        while (portalIndex < this.portalsPool.length) {
          const portal = this.portalsPool[portalIndex];
          const halfX = portal.material.uniforms.uResolution.value[0] / 2;
          const halfY = portal.material.uniforms.uResolution.value[1] / 2;
          const normalizedx = (halfX - smoothX) / halfX;
          const normalizedy = (halfY - smoothY) / halfY;
          portal.material.uniforms.uMouse.value = [normalizedx, normalizedy];
          portal.material.uniforms.uMouseVelocity.value = mouseVelocity;
          portalIndex++;
        }
        this.lastMouseX = smoothX;
      }
      setBackgroundPlane() {
        this.material = new ShaderMaterial({
          extensions: {
            derivatives: "#extension GL_OES_standard_derivatives : enable"
          },
          side: DoubleSide,
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
            uResolution: { value: [0, 0] }
          },
          vertexShader: vertex_default7,
          fragmentShader: fragment_default8
        });
        this.materials.push(this.material);
        this.geometry = new PlaneGeometry(1, 1, 1, 1);
        this.plane = new Mesh(this.geometry, this.material);
        this.scene.add(this.plane);
      }
      setPortalPlanes() {
        let portalIndex = 0;
        while (portalIndex < this.portalsCount) {
          const material = new ShaderMaterial({
            extensions: {
              derivatives: "#extension GL_OES_standard_derivatives : enable"
            },
            side: DoubleSide,
            uniforms: {
              uTime: { value: 0 },
              uMouseVelocity: { value: 0 },
              uMouse: { value: [0, 0] },
              uThreshold: { value: [5, 95] },
              uProgress: { value: 0 },
              uResolution: { value: [0, 0] },
              uPortalTexture: { value: null },
              uPortalTextureResolution: { value: [0, 0] },
              uIndex: { value: portalIndex },
              uMaxMaskScale: { value: 0 }
            },
            vertexShader: vertex_default7,
            fragmentShader: fragmentPortal_default2,
            transparent: true,
            depthWrite: true
          });
          this.materials.push(material);
          this.geometryPortal = new PlaneGeometry(1, 1, 1, 1);
          const planePortal = new Mesh(this.geometryPortal, material);
          planePortal.progress = 0;
          this.scene.add(planePortal);
          this.portalsPool.push(planePortal);
          planePortal.renderOrder = this.portalsCount - portalIndex;
          portalIndex++;
        }
        this.portalsPool.forEach((portal, index2) => {
          portal.material.uniforms.uProgress.value = 0.25;
        });
      }
      compute(width, height) {
        var _a;
        (_a = this.setResolutionUniforms) == null ? void 0 : _a.call(this, width, height);
        this.reset();
      }
      computeMaskTextureScale(maskTexture) {
        if (!maskTexture)
          return 1;
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        const originalTexWidth = maskTexture.image.width;
        const originalTexHeight = maskTexture.image.height;
        const tAspect = originalTexWidth / originalTexHeight;
        const pAspect = canvasWidth / canvasHeight;
        const pwidth = canvasWidth;
        const pheight = canvasHeight;
        let currentTexWidth = 0;
        if (tAspect > pAspect) {
          currentTexWidth = pheight * tAspect;
        } else {
          currentTexWidth = pwidth;
        }
        return currentTexWidth / originalTexWidth;
      }
      reset() {
        var _a;
        const maskTextureScale = this.computeMaskTextureScale(this.maskTexture);
        console.log((_a = this.setMaxMaskScaleUniforms) == null ? void 0 : _a.call(this, maskTextureScale));
      }
      setResolutionUniforms() {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        let materialIndex = 0;
        while (materialIndex < this.materials.length) {
          const material = this.materials[materialIndex];
          material.uniforms.uResolution.value = [canvasWidth, canvasHeight];
          materialIndex++;
        }
      }
      setPortalTextureUniforms() {
        const texWidth = this.portalTexture.image.width;
        const texHeight = this.portalTexture.image.height;
        this.portalsPool.forEach((portal) => {
          portal.material.uniforms.uPortalTexture.value = this.portalTexture;
          portal.material.uniforms.uPortalTextureResolution.value = [texWidth, texHeight];
        });
      }
      setMaxMaskScaleUniforms(maskTextureScale) {
        const canvasWidth = this.renderer.domElement.offsetWidth;
        const canvasHeight = this.renderer.domElement.offsetHeight;
        const circleWidth = DEFAULT_PORTAL_CIRCLE_WIDTH3 * maskTextureScale;
        const pythA = canvasHeight / 2;
        const pythB = canvasWidth / 2;
        const hypot = Math.hypot(pythA, pythB);
        const originalScale = hypot / circleWidth * 2;
        const roundedScale = Math.round((originalScale + Number.EPSILON) * 100) / 100;
        this.portalsPool.forEach((portal) => {
          portal.material.uniforms.uMaxMaskScale.value = roundedScale;
        });
        return roundedScale;
      }
      setupPane() {
        if (!this.paneObj)
          return;
        const folder = this.paneObj.pane.addFolder({
          title: "Portal",
          expanded: true
        });
        this.paneObj.params.progress = 0;
        folder.addInput(this.paneObj.params, "progress", { min: 0, max: 1 }).on("change", (ev) => {
          const value = ev.value;
          if (this.material) {
            this.material.uniforms.uProgress.value = value;
          }
        });
      }
    };
  
    // assets/scripts/classes/Canvas/playgroundInstances.js
    var playgroundInstances_default = playgroundInstances = {
      "MASK": Mask,
      "DEPTH_MAP": Depthmap2,
      "TYPO": Typo2,
      "PORTAL": Portal2,
      "GLITCH": Glitch,
      "INTRODUCTION": Introduction
    };
  
    // assets/scripts/classes/Canvas/Canvas.js
    var Canvas = class {
      constructor({ $el, playgroundId, paneObj, moduleInstance, hasBloomPass }) {
        this.$el = $el;
        this.playgroundId = playgroundId;
        this.paneObj = paneObj;
        this.moduleInstance = moduleInstance;
        this.hasBloomPass = hasBloomPass;
        this.width = $el.offsetWidth;
        this.height = $el.offsetHeight;
        this.dpr = window.devicePixelRatio;
        this.createScene();
        this.createCamera();
        this.createRenderer();
        this.createBloomPass();
        this.init();
      }
      init() {
        const playgroundClass = playgroundInstances_default[this.playgroundId];
        this.playgroundInstance = new playgroundClass({
          scene: this.scene,
          renderer: this.renderer,
          paneObj: this.paneObj,
          moduleInstance: this.moduleInstance
        });
      }
      destroy() {
        var _a, _b;
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.destroy) == null ? void 0 : _b.call(_a);
      }
      resize() {
        var _a, _b;
        this.width = this.$el.offsetWidth;
        this.height = this.$el.offsetHeight;
        this.renderer.setSize(this.width, this.height);
        if (this.hasBloomPass) {
          this.composer.setSize(this.width, this.height);
        }
        this.camera.aspect = this.width / this.height;
        this.camera.updateProjectionMatrix();
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.resize) == null ? void 0 : _b.call(_a);
      }
      update(time, deltaTime, frame) {
        var _a, _b;
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a, time, deltaTime, frame);
        if (this.hasBloomPass) {
          this.composer.render(this.scene, this.camera);
        } else {
          this.renderer.render(this.scene, this.camera);
        }
      }
      pointerDown() {
        var _a, _b;
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.pointerDown) == null ? void 0 : _b.call(_a);
      }
      pointerUp() {
        var _a, _b;
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.pointerUp) == null ? void 0 : _b.call(_a);
      }
      mouseMove(mouseCoords) {
        var _a, _b;
        (_b = (_a = this.playgroundInstance) == null ? void 0 : _a.mouseMove) == null ? void 0 : _b.call(_a, mouseCoords);
      }
      createScene() {
        this.scene = new Scene();
      }
      createCamera() {
        const frustumSize = 1;
        let aspect2 = 1;
        if (this.playgroundId == "TYPO")
          aspect2 = window.innerWidth / window.innerHeight;
        this.camera = new OrthographicCamera(frustumSize * aspect2 / -2, frustumSize * aspect2 / 2, frustumSize / 2, frustumSize / -2, -1e3, 1e3);
        this.camera.position.set(0, 0, 2);
      }
      createRenderer() {
        const normalizedDpr = Math.min(this.dpr, 2);
        this.renderer = new WebGLRenderer({ antialias: true });
        this.renderer.setPixelRatio(normalizedDpr);
        this.renderer.setSize(this.width, this.height);
        this.renderer.setClearColor(0, 1);
        this.$el.appendChild(this.renderer.domElement);
      }
      createBloomPass() {
        const normalizedDpr = Math.min(this.dpr, 2);
        const params = {
          exposure: 1,
          bloomStrength: 0.6,
          bloomThreshold: 0.99,
          bloomRadius: 0.6
        };
        const renderScene = new RenderPass(this.scene, this.camera);
        this.bloomPass = new UnrealBloomPass(new Vector2(this.width, this.height), params.bloomStrength, params.bloomRadius, params.bloomThreshold);
        this.composer = new EffectComposer(this.renderer);
        this.composer.addPass(renderScene);
        this.composer.addPass(this.bloomPass);
        this.composer.setPixelRatio(normalizedDpr);
        this.composer.setSize(this.width, this.height);
      }
    };
  
    // assets/scripts/modules/AbstractPlayground.js
    var AbstractPlayground_default = class extends _default {
      constructor(m) {
        super(m);
        this.onResizeBind = this.onResize.bind(this);
        this.onFontsLoadedBind = this.onFontsLoaded.bind(this);
        this.onUpdateBind = this.onUpdate.bind(this);
        this.onPointerDownBind = this.onPointerDown.bind(this);
        this.onPointerUpBind = this.onPointerUp.bind(this);
        this.isRafPlaying = false;
        this.hasHoldAvailable = false;
      }
      init() {
        var _a;
        (_a = this._init) == null ? void 0 : _a.call(this);
        this.bindEvents();
        if (window.isFontsLoaded) {
          this.onFontsLoaded();
        }
        this.createPane();
        this.setupPane();
        this.initCanvas();
        this.play();
      }
      destroy() {
        var _a, _b, _c, _d, _e, _f;
        super.destroy();
        (_a = this._destroy) == null ? void 0 : _a.call(this);
        this.unbindEvents();
        this.pause();
        (_c = (_b = this.playgroundCanvas) == null ? void 0 : _b.destroy) == null ? void 0 : _c.call(_b);
        (_f = (_e = (_d = this.paneObj) == null ? void 0 : _d.pane) == null ? void 0 : _e.dispose) == null ? void 0 : _f.call(_e);
      }
      bindEvents() {
        window.addEventListener("resizeEnd", this.onResizeBind);
        window.addEventListener("fontsLoaded", this.onFontsLoadedBind);
        window.addEventListener("pointerdown", this.onPointerDownBind);
        window.addEventListener("pointerup", this.onPointerUpBind);
      }
      unbindEvents() {
        window.removeEventListener("resizeEnd", this.onResizeBind);
        window.removeEventListener("fontsLoaded", this.onFontsLoadedBind);
        window.removeEventListener("pointerdown", this.onPointerDownBind);
        window.removeEventListener("pointerup", this.onPointerUpBind);
      }
      onResize() {
        var _a, _b;
        (_b = (_a = this.playgroundCanvas) == null ? void 0 : _a.resize) == null ? void 0 : _b.call(_a);
      }
      onFontsLoaded() {
        var _a, _b;
        (_b = (_a = this.playgroundCanvas) == null ? void 0 : _a.resize) == null ? void 0 : _b.call(_a);
      }
      onUpdate(time, deltaTime, frame) {
        var _a, _b, _c, _d;
        (_b = (_a = this.playgroundCanvas) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a, time, deltaTime, frame);
        (_d = (_c = this.playgroundCanvas) == null ? void 0 : _c.mouseMove) == null ? void 0 : _d.call(_c, {
          x: Mouse_default.x,
          y: Mouse_default.y,
          smoothX: Mouse_default.smoothX,
          smoothY: Mouse_default.smoothY
        });
      }
      onPointerDown() {
        var _a, _b;
        (_b = (_a = this.playgroundCanvas) == null ? void 0 : _a.pointerDown) == null ? void 0 : _b.call(_a);
      }
      onPointerUp() {
        var _a, _b;
        (_b = (_a = this.playgroundCanvas) == null ? void 0 : _a.pointerUp) == null ? void 0 : _b.call(_a);
      }
      initCanvas() {
        this.playgroundCanvas = new Canvas({
          $el: this.el,
          playgroundId: this.playgroundId,
          paneObj: this.paneObj,
          moduleInstance: this,
          hasBloomPass: this.hasBloomPass
        });
      }
      play() {
        if (this.isRafPlaying)
          return;
        this.isRafPlaying = true;
        this.hasHoldAvailable = true;
        gsapWithCSS2.ticker.add(this.onUpdateBind);
      }
      pause() {
        if (!this.isRafPlaying)
          return;
        this.isRafPlaying = false;
        this.hasHoldAvailable = false;
        gsapWithCSS2.ticker.remove(this.onUpdateBind);
      }
      createPane() {
        this.paneObj = {};
        this.paneObj.pane = new import_tweakpane.Pane();
        this.paneObj.params = {};
      }
      setupPane() {
        const folder = this.paneObj.pane.addFolder({
          title: "Common tools",
          expanded: false
        });
        const toggleRafBtn = folder.addButton({
          title: "Play/Pause",
          label: "RAF"
        });
        toggleRafBtn.on("click", () => {
          if (this.isRafPlaying) {
            this.pause();
          } else {
            this.play();
          }
        });
        requestAnimationFrame(() => {
          if (this.playgroundCanvas && this.playgroundCanvas.bloomPass) {
            const bloomFolder = this.paneObj.pane.addFolder({
              title: "Bloom",
              expanded: false
            });
            this.paneObj.params.bloomStrength = this.playgroundCanvas.bloomPass.strength;
            bloomFolder.addInput(this.paneObj.params, "bloomStrength", { min: 0, max: 2 }).on("change", (ev) => {
              const value = ev.value;
              this.playgroundCanvas.bloomPass.strength = value;
            });
            this.paneObj.params.bloomThreshold = this.playgroundCanvas.bloomPass.threshold;
            bloomFolder.addInput(this.paneObj.params, "bloomThreshold", { min: 0, max: 1 }).on("change", (ev) => {
              const value = ev.value;
              this.playgroundCanvas.bloomPass.threshold = value;
            });
            this.paneObj.params.bloomRadius = this.playgroundCanvas.bloomPass.radius;
            bloomFolder.addInput(this.paneObj.params, "bloomRadius", { min: 0, max: 2 }).on("change", (ev) => {
              const value = ev.value;
              this.playgroundCanvas.bloomPass.radius = value;
            });
          }
        });
      }
    };
  
    // assets/scripts/modules/DepthmapPlayground.js
    var DepthmapPlayground_default = class extends AbstractPlayground_default {
      constructor() {
        super(...arguments);
        __publicField(this, "playgroundId", "DEPTH_MAP");
      }
    };
  
    // assets/scripts/utils/fontsLoader.js
    function fontsLoader(fonts2, callback) {
      return __async(this, null, function* () {
        const fontFaceObservers = [];
        if (!fonts2.length)
          return;
        fonts2.forEach((font) => {
          const observer = loadFont(font.name, font.style, font.weight);
          fontFaceObservers.push(observer);
        });
        try {
          yield Promise.all(fontFaceObservers);
          callback == null ? void 0 : callback();
        } catch (err) {
          console.warn("Some critical font are not available:", err);
        }
      });
    }
    function loadFont(fontName, fontStyle, fontWeight) {
      return new Promise((resolve) => {
        let loop = null;
        const clearLoop = () => {
          if (loop) {
            clearInterval(loop);
            loop = null;
          }
        };
        const tryToLoadFont = () => {
          let hasLoaded = false;
          try {
            hasLoaded = document.fonts.check(`${fontStyle} ${fontWeight} 16px ${fontName}`);
          } catch (error) {
            console.info(`CSS font loading API error with ${fontName} ${fontStyle} ${fontWeight}`, error);
            clearLoop();
            resolve();
          }
          if (hasLoaded) {
            clearLoop();
            resolve();
          }
        };
        loop = setInterval(tryToLoadFont, 500);
      });
    }
  
    // assets/scripts/utils/styleSheetsLoader.js
    function styleSheetsLoader($styleSheets, callback) {
      return __async(this, null, function* () {
        const styleSheetObservers = [];
        if (!$styleSheets.length)
          return console.log("Uh oh ! You need to select a <link> element");
        $styleSheets.forEach(($styleSheet) => {
          const observer = loadStylesheet($styleSheet);
          styleSheetObservers.push(observer);
        });
        try {
          yield Promise.all(styleSheetObservers);
          callback == null ? void 0 : callback();
        } catch (err) {
          console.warn("Some critical font are not available:", err);
        }
      });
    }
    function loadStylesheet($styleSheet) {
      return new Promise((resolve) => {
        let loop = null;
        const clearLoop = () => {
          if (loop) {
            clearInterval(loop);
            loop = null;
          }
        };
        const checkStyleSheetLoading = () => {
          let hasLoaded = false;
          try {
            hasLoaded = $styleSheet.getAttribute("data-is-loaded") == "true" ? true : false;
          } catch (error) {
            console.info(`Error with a styleSheet`, error);
            console.info(`This one ->`, $styleSheet);
            clearLoop();
            resolve();
          }
          if (hasLoaded) {
            console.info(`This stylesheet is loaded`, $styleSheet);
            clearLoop();
            resolve();
          }
        };
        loop = setInterval(checkStyleSheetLoading, 100);
      });
    }
  
    // assets/scripts/utils/debounce.js
    function debounce_default(func, wait, immediate) {
      let timeout;
      return function() {
        const context3 = this;
        const args = arguments;
        const later = function() {
          timeout = null;
          if (!immediate)
            func.apply(context3, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow)
          func.apply(context3, args);
      };
    }
  
    // assets/scripts/app.js
    var isMobileObj4 = isMobile();
    var IS_TOUCH_DEVICE4 = (isMobileObj4 == null ? void 0 : isMobileObj4.phone) || (isMobileObj4 == null ? void 0 : isMobileObj4.tablet);
    var fonts = [
      { name: "Lexend", style: "normal", weight: "300" },
      { name: "Lexend", style: "normal", weight: "400" },
      { name: "Lexend", style: "normal", weight: "500" },
      { name: "Libre Caslon Text", style: "normal", weight: "normal" },
      { name: "Libre Caslon Text", style: "italic", weight: "normal" }
    ];
    var app = new main_esm_default({
      modules: modules_exports
    });
    var onFontsLoaded = () => {
      html.classList.add("is-fonts-loaded");
    };
    var onImagesPreloaded = () => {
      html.classList.add("is-images-preloaded");
    };
    var onAllAssetsLoaded = () => {
      setTimeout(() => {
        html.classList.add("is-loaded");
        html.classList.add("is-first-loaded");
        html.classList.remove("is-loading");
        setTimeout(() => {
          html.classList.add("is-ready");
        }, 100);
      }, 400);
    };
    function init5() {
      var _a;
      window.currentTemplate = (_a = html.dataset) == null ? void 0 : _a.template;
      window.isFontsLoaded = false;
      let fontsPromise = new Promise((resolve) => {
        fontsLoader(fonts, () => {
          onFontsLoaded == null ? void 0 : onFontsLoaded();
          requestAnimationFrame(() => {
            const fontsLoadedEvent = new CustomEvent("fontsLoaded");
            window.dispatchEvent(fontsLoadedEvent);
            window.isFontsLoaded = true;
          });
          resolve();
        });
      });
      let imagesPromise = new Promise((resolve) => {
        preloadImages2(() => {
          onImagesPreloaded == null ? void 0 : onImagesPreloaded();
          resolve();
        });
      });
      Promise.all([fontsPromise, imagesPromise]).then(() => {
        onAllAssetsLoaded == null ? void 0 : onAllAssetsLoaded();
      });
      bindEvents2();
      if (IS_TOUCH_DEVICE4) {
        html.classList.add("is-touchable");
      }
      window.needIntro = !window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      onResize2();
      document.documentElement.style.setProperty("--vh-initial", `${document.documentElement.clientHeight * 0.01}px`);
      globals_default();
      app.init(app);
    }
    function bindEvents2() {
      const resizeEndEvent = new CustomEvent("resizeEnd");
      window.addEventListener("resize", debounce_default(() => {
        onResize2();
        window.dispatchEvent(resizeEndEvent);
      }, 200, false));
    }
    function onResize2() {
      let vw = html.offsetWidth * 0.01;
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vw", `${vw}px`);
      document.documentElement.style.setProperty("--vh", `${vh}px`);
    }
    window.onload = (event2) => {
      html.classList.remove("no-js");
      const $style = document.getElementById("main-css");
      if ($style) {
        styleSheetsLoader([$style], () => {
          init5();
        });
      } else {
        console.warn('The "main-css" stylesheet not found');
      }
    };
  })();
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /*!
   * CSSPlugin 3.11.3
   * https://greensock.com
   *
   * Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /*!
   * DrawSVGPlugin 3.11.3
   * https://greensock.com
   *
   * @license Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /*!
   * GSAP 3.11.3
   * https://greensock.com
   *
   * @license Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /*!
   * SplitText: 3.11.3
   * https://greensock.com
   *
   * @license Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /*!
   * strings: 3.11.3
   * https://greensock.com
   *
   * Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   */
  /*!
  * focus-trap 6.7.2
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  */
  /*!
  * tabbable 5.2.1
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  */
  /*! Tweakpane 3.0.5 (c) 2016 cocopon, licensed under the MIT license. */
  /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
  /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  //!\\ Textures are already loaded when the master animation is complete
  //# sourceMappingURL=app.js.map
  